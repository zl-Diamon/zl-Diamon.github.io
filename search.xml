<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ConcurrentHashMap原理</title>
    <url>/2021/01/06/ConcurrentHashMap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>1.在了解ConcurrentHashMap之前一定需要知道HashMap和HashTable的区别？</p>
<p>这是一个老生常谈的问题：</p>
<ol>
<li><p>线程安全方面：HashMap是非线程安全的，HashTable是线程安全的；HashTable内部的方法基本都经过synchronized修饰；</p>
</li>
<li><p>效率方面：因为线程安全的问题，HashMap要不HashTable效率高一点；</p>
<a id="more"></a>
</li>
<li><p>对Null的支持方面：HashMap中，null可以作为i键，这样的键只能有一个，可以有一个或多个键所对应的值为null，但是在HashTable中put进的键值只要有一个为null，会直接空指针异常(NullPointerException);</p>
</li>
<li><p>**初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</p>
</li>
<li><p><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8且数组长度大于64）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ol>
<p>2.还需要知道HashMap和ConcurrentHashMap的区别？</p>
<ol>
<li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li>
<li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li>
</ol>
<p>3.还需要HashTable和ConcurrentHashMap的区别？</p>
<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）</strong>： ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p>对比图：</p>
<p>HashTable：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/HashMap.png"></p>
<p>JDK1.7的ConcurrentHashMap：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/1.7ConcurrentHashMap.png"></p>
<p>JDK1.8的ConcurrentHashMap：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/1.8ConcurrentHashMap.png"></p>
<p>总结：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。但是 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</p>
<p>4.最后需要知道ConcurrentHashMap的底层实现原理？</p>
<p><strong>JDK1.7</strong></p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</p>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/low1.7.png"></p>
<ol>
<li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>
<li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>
</ol>
<p><strong>JDK1.8</strong></p>
<p>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<p>结构如下：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/low1.8.png"></p>
<p>来源于<a href="https://thinkwon.blog.csdn.net/article/details/104588551" target="_blank">Thinkwon</a></p>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile文件开发</title>
    <url>/2021/01/29/DockerFile%E6%96%87%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>Docker！真香，谁用谁知道，软件安装简单，部署简单，这是一个简单的dockerfile测试。</p>
<a id="more"></a>

<h4 id="1-在-根目录下的mydocker文件夹新建一个Dockerfile2文件"><a href="#1-在-根目录下的mydocker文件夹新建一个Dockerfile2文件" class="headerlink" title="1.在/根目录下的mydocker文件夹新建一个Dockerfile2文件"></a>1.在/根目录下的mydocker文件夹新建一个Dockerfile2文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd mydaocker</span><br><span class="line">vim Dockerfile2</span><br></pre></td></tr></table></figure>

<h4 id="2-手动编写Dockerfile2文件的内容，安装vim和ifconfig命令"><a href="#2-手动编写Dockerfile2文件的内容，安装vim和ifconfig命令" class="headerlink" title="2.手动编写Dockerfile2文件的内容，安装vim和ifconfig命令"></a>2.手动编写Dockerfile2文件的内容，安装vim和ifconfig命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER zl&lt;zllwsy@outlook.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;success----------ok&quot;</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<h4 id="3-运行命令"><a href="#3-运行命令" class="headerlink" title="3.运行命令"></a>3.运行命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;Dockerfile2 -t mycentos:1.3 .</span><br><span class="line">注意：末尾.前面有空格</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151404782.png" alt="image-20210129151404782"></p>
<h4 id="4-直到运行结束，出现Successfully-built-c708b989ac01"><a href="#4-直到运行结束，出现Successfully-built-c708b989ac01" class="headerlink" title="4.直到运行结束，出现Successfully built c708b989ac01"></a>4.直到运行结束，出现Successfully built c708b989ac01</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151412552.png" alt="image-20210129151412552"></p>
<h4 id="5-成功后，查看本机容器镜像，会发现出现了mycentos-1-3"><a href="#5-成功后，查看本机容器镜像，会发现出现了mycentos-1-3" class="headerlink" title="5.成功后，查看本机容器镜像，会发现出现了mycentos 1.3"></a>5.成功后，查看本机容器镜像，会发现出现了mycentos 1.3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images  </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151429270.png" alt="image-20210129151429270"></p>
<h4 id="6-启动新的mycentos-1-3"><a href="#6-启动新的mycentos-1-3" class="headerlink" title="6.启动新的mycentos:1.3"></a>6.启动新的mycentos:1.3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it mycentos:1.3</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151447056.png" alt="image-20210129151447056"></p>
<h4 id="7-使用ifconfig和vim命令，发现已经可以使用了"><a href="#7-使用ifconfig和vim命令，发现已经可以使用了" class="headerlink" title="7.使用ifconfig和vim命令，发现已经可以使用了"></a>7.使用ifconfig和vim命令，发现已经可以使用了</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151454647.png" alt="image-20210129151454647"></p>
<h4 id="8-使用命令，查看centos的更改历史"><a href="#8-使用命令，查看centos的更改历史" class="headerlink" title="8.使用命令，查看centos的更改历史"></a>8.使用命令，查看centos的更改历史</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker history c708b989ac01  后面为镜像ID</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151508675.png" alt="image-20210129151508675"></p>
<h4 id="9-可以再测试一下，新建Dockerfile3文件"><a href="#9-可以再测试一下，新建Dockerfile3文件" class="headerlink" title="9.可以再测试一下，新建Dockerfile3文件"></a>9.可以再测试一下，新建Dockerfile3文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim Dockerfile3</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151521931.png" alt="image-20210129151521931"></p>
<h4 id="10-手动编写，"><a href="#10-手动编写，" class="headerlink" title="10.手动编写，"></a>10.手动编写，</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install -y curl</span><br><span class="line">CMD [&quot;curl&quot;,&quot;-s&quot;,&quot;https:&#x2F;&#x2F;ip.cn&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="11-运行"><a href="#11-运行" class="headerlink" title="11.运行"></a>11.运行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -f &#x2F;mydocker&#x2F;Dockerfile3 -t myip .</span><br></pre></td></tr></table></figure>

<h4 id="12-同理，等待运行成功，出现successful-build"><a href="#12-同理，等待运行成功，出现successful-build" class="headerlink" title="12.同理，等待运行成功，出现successful build"></a>12.同理，等待运行成功，出现successful build</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151553309.png" alt="image-20210129151553309"></p>
<h4 id="13-查看新建的镜像容器"><a href="#13-查看新建的镜像容器" class="headerlink" title="13.查看新建的镜像容器"></a>13.查看新建的镜像容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images myip</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129151607370.png" alt="image-20210129151607370"></p>
<h4 id="14-运行容器"><a href="#14-运行容器" class="headerlink" title="14.运行容器"></a>14.运行容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it myip</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-Docker</category>
      </categories>
      <tags>
        <tag>-DockerFile -Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Kafka和Zookeeper及简单测试</title>
    <url>/2020/10/28/Docker%E5%AE%89%E8%A3%85Kafka%E5%92%8CZookeeper%E5%8F%8A%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>学完了Mqtt，我又想试试很热门的kafka，我在几个项目中都用过，但是未曾自己搭建一次，所以再次记录，我准备安装在linux系统中，使用Centos7系统，这次又加上了我很喜欢的docker容器，希望一切顺利，</p>
<a id="more"></a>

<p>1.基本操作，先启动docker容器，执行命令，然后查看一下镜像情况，没错，还是上次redis留下的东西，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/4.1.png" alt="4.1"></p>
<p>2.拉取zookeeper的镜像，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull wurstmeister&#x2F;zookeeper</span><br></pre></td></tr></table></figure>

<p>3.启动一个zookeeper镜像的实例，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 2181:2181 --name zookeeper --restart always xxx</span><br></pre></td></tr></table></figure>

<p>4.拉取kafka的镜像，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull wurstmeister&#x2F;kafka</span><br></pre></td></tr></table></figure>

<p>5.启动一个kafka镜像的实例，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID&#x3D;0 -e KAFKA_ZOOKEEPER_CONNECT&#x3D;10.0.10.188:2181&#x2F;kafka -e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;10.0.10.188:9092 -e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092 -v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime wurstmeister&#x2F;kafka</span><br><span class="line"></span><br><span class="line">#参数说明(这里是复制的，毕竟我也是第一次，命令我整理了一下)</span><br><span class="line">-e KAFKA_BROKER_ID&#x3D;0  在kafka集群中，每个kafka都有一个BROKER_ID来区分自己</span><br><span class="line">-e KAFKA_ZOOKEEPER_CONNECT&#x3D;10.0.10.188:2181&#x2F;kafka 配置zookeeper管理kafka的路径10.0.10.188:2181&#x2F;kafka</span><br><span class="line">-e KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;10.0.10.188:9092  把kafka的地址端口注册给zookeeper，如果是远程访问要改成外网IP,类如Java程序访问出现无法连接。</span><br><span class="line">-e KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092 配置kafka的监听端口</span><br><span class="line">-v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime 容器时间同步虚拟机的时间</span><br></pre></td></tr></table></figure>

<p>6.到此，两个实例都启动起来了，看一看运行状况，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps  #这是查看正在运行的，-a 查看所有</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/4.2.png" alt="4.2"></p>
<p>7.目前看起来没啥问题，那就简单的试试kafka的功能吧，进入容器内部，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it kafka &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<p>8.进入 /opt/kafka_2.13-2.6.0/bin目录，然后启动生成者，发送一条消息，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;kafka-console-producer.sh --broker-list localhost:9092 --topic sun</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/4.3.png" alt="4.3"></p>
<p>9.另外打开一个窗口，同样进入容器内部后，进入 /opt/kafka_2.13-2.6.0/bin目录，然后启动消费者，接收生产者发出的消息，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic sun --from-</span><br><span class="line">beginning</span><br></pre></td></tr></table></figure>

<p>10.其实可以看到，当生成者窗口发出消息后，消费者提示有新消息，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/4.4.png" alt="4.4"></p>
<p>总结，和其他docker安装其他软件一样，步骤很简单，后面测试我找命令找了一会，那个复制那一段来自<a href="https://www.cnblogs.com/engzhangkai/p/12676613.html" target="_blank">docker安装kafka</a>，over，下一篇将在Idea中连接测试，祝我一切顺利，木有bug。</p>
]]></content>
      <categories>
        <category>-Kafka</category>
      </categories>
      <tags>
        <tag>-Docker -Kafka -Zookeeper -Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>FeignClient远程调用</title>
    <url>/2021/01/29/FeignClient%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li><p>引入OpenFeign依赖</p>
</li>
<li><p>定义FeignClient接口类（注解<code>@FeignClient</code>），声明这个接口类是用来远程调用其他服务的</p>
<a id="more"></a>
</li>
<li><p>接口类中定义要远程调用的接口方法，指定远程服务方法的路径</p>
</li>
<li><p>Controller类中调用接口方法</p>
</li>
<li><p>开启远程调用（注解<code>@EnableFeignClients</code>）</p>
</li>
<li><p>远程调用的流程：</p>
<ul>
<li>@RequestBody将这个对象转为json</li>
<li>找到passjava-study服务，给study/studytime/member/list/test服务发送请求</li>
<li>将json放到请求体里面，发送请求</li>
<li>对方服务收到请求，请求体里有json数据</li>
<li>将请求体中的json数据转换成对方服务的参数类型。只需要两边的字段名称和类型是一致的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux快捷安装jdk</title>
    <url>/2020/11/01/Linux%E5%BF%AB%E6%8D%B7%E5%AE%89%E8%A3%85jdk/</url>
    <content><![CDATA[<p>快捷的在Linux系统中安装Java环境，</p>
<a id="more"></a>

<p>1.启动linux系统，查看可安装的jdk，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y list java*</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/7.1.png" alt="7.1"></p>
<p>2.选择1.8的版本安装，直到出现Complete，表示已经安装完成，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java-1.8.0-openjdk.x86_64</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/7.2.png" alt="7.2"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/7.3.png" alt="7.3"></p>
<p>3.查看java版本，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/7.4.png" alt="7.4"></p>
]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>-JDK -Linux -Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合的快速失败机制</title>
    <url>/2021/01/06/Java%E9%9B%86%E5%90%88%E7%9A%84%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><strong>”fail-fast“</strong></p>
<p>这是Java集合的一种错误监测机制，当多个线程对集合进行结构上的改变的操作的时候，就可能会产生fail-fast机制，</p>
<p><strong>原因</strong>：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历</p>
<p><strong>解决方案：</strong>1.使用synchornized关键字</p>
<p>​                   2.使用CopyOnWriteArrayList代替ArrayList</p>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-Fail-fast</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT两种服务器的安装使用</title>
    <url>/2020/10/28/MQTT%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>出差回来后，我又闲着无事了，公司让我学一下mqtt，第一时间我是懵逼的，没听说过呀，然后百度后知道了mqtt一般用于物联网，再顺势百度了一下物联网和互联网区别，哦哟不错呀，最后又百度了一下物联网、大数据和人工智能的联系，哇哦，物联网未来可期呀，所以，学一下mqtt，废话少说，上菜(本人第一次学习，有错就跪求大佬提醒一下)。</p>
<a id="more"></a>

<p>先说mqtt是啥，我语言能力差，在我看来，这就是一种特别一点的mq，只是它面向的对象是物联网而已，具体特性请参看这篇文章，<a href="https://www.jianshu.com/p/54e0238d3fae" target="_blank">MQTT详解</a>讲得还阔以。</p>
<p>1.常见的MQTT服务器一般有两种，分别是Apollo和Emqx，我先尝试了一下两个都装在Windows，首先，下载Apollo，知道我记性差，给个自己的百度云链接，不是给你们的(手动狗头)，</p>
<p>链接：<a href="https://pan.baidu.com/s/1FLA8snaBjwfLRLo0XYZ7lg">https://pan.baidu.com/s/1FLA8snaBjwfLRLo0XYZ7lg</a><br>提取码：zjba<br>下载后，解压，直接cmd进入该文件的bin目录，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apollo.cmd create mybroker  </span><br></pre></td></tr></table></figure>

<p>别问我为啥叫mybroker，因为MQTT服务被称为broker，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/1.1.png" alt="1.1"></p>
<p>2.这就安装好了，然后启动，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apollo-broker run</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/1.2.png" alt="1.2"></p>
<p>3.启动起来了，最下面给了地址和端口号，在浏览器打开，默认的账号是admin，密码是password。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/1.3.png" alt="1.3"></p>
<p>4.是不是感觉超级简单(因为就很基础的操作)，那再来看看Empx的安装启动，同样，为了有些人怕麻烦，不不不，我是给自己准备了一个链接，真没准备给你们用(QAQ)，</p>
<p>链接：<a href="https://pan.baidu.com/s/1LzBcPCPALe04K2pgxH2d2A">https://pan.baidu.com/s/1LzBcPCPALe04K2pgxH2d2A</a><br>提取码：8g83<br>下载后，解压，还是cmd进入该文件的bin目录，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emqx install</span><br></pre></td></tr></table></figure>

<p>手动图片：点快了，把窗口关了</p>
<p>5.这就安装好了，然后启动，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emqx start </span><br><span class="line">（几个常用命令：</span><br><span class="line">emqx start          启动</span><br><span class="line">emqx_ctl status     检查运行状态</span><br><span class="line">emqx uninstall      服务卸载</span><br><span class="line">emqx stop           停止）</span><br></pre></td></tr></table></figure>

<p>手动图片：不会输出任何信息，stop的时候会输出ok</p>
<p>6.启动成功，访问127.0.0.1:18083，默认的账号是admin，密码是public。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/1.4.png" alt="1.4"></p>
<p>总结，这两个都很好用，Empx有一部分功能需要收费，但是基本没影响，Empx连接更稳定一些，功能也强大一些，说实话，我觉得还更好看一些，可能暗黑风我比较喜欢吧，你喜欢哪一种呢？</p>
]]></content>
      <categories>
        <category>-MQTT</category>
      </categories>
      <tags>
        <tag>-MQTT -Apollo -Emqx</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT使用Java连接测试-一</title>
    <url>/2020/10/28/MQTT%E4%BD%BF%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95-%E4%B8%80/</url>
    <content><![CDATA[<p>到目前为止，服务装好了，客户端连接上了，如果还没搞定(不会吧不会还有人没搞定吧？)，请参看：</p>
<a id="more"></a>

<p><a href="../MQTT%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/index.html">MQTT两种服务器的安装使用</a></p>
<p><a href="../MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85%E5%B9%B6%E8%BF%9E%E6%8E%A5%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">MQTT客户端的安装并连接两种服务器</a></p>
<p>一切都完事了后，那么就开始重头戏，Springboot集成MQTT的测试了。</p>
<p>1.新建一个Springboot项目(这不可能有人不会吧)，查了多方资料，然后去maven仓库查看了一下，这三个依赖是需要滴，导入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- MQTT-jar --&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-integration-stream&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-integration-mqtt&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.首先写一下配置文件，自动生成的是properties文件，我不习惯，改成yml文件了，请注意，clientId一定要唯一，要唯一，要唯一，希望你能看出我吃了什么亏，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#mq配置</span><br><span class="line">com:</span><br><span class="line">  mqtt:</span><br><span class="line">    host: tcp:&#x2F;&#x2F;127.0.0.1:1883</span><br><span class="line">    clientId: exqmId  #一定要唯一</span><br><span class="line">    topic: good,test,yes</span><br><span class="line">    username: admin</span><br><span class="line">    password: public</span><br><span class="line">    timeout: 10</span><br><span class="line">    keepalive: 20</span><br></pre></td></tr></table></figure>

<p>3.为了方便测试，我在Idea里面写了两个客户端，一个用于发布，一个用于订阅，先说明，其实是可以写一个就行，客户端是既能发布又能订阅的，先写一个类来获取yml里面的配置信息(我也试了在实体类里面使用@Component和@Value来获取，是可行的)，新建了一个ymlUtil类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:配置类-从yml配置中获取数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/27 14:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ymlUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String MQTT_HOST;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String MQTT_CLIENTID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String MQTT_USER_NAME;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String MQTT_PASSWORD;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer MQTT_TIMEOUT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer MQTT_KEEP_ALIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        MQTT_HOST = loadMqttYml().getProperty(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        MQTT_CLIENTID = loadMqttYml().getProperty(<span class="string">&quot;clientId&quot;</span>);</span><br><span class="line">        MQTT_USER_NAME = loadMqttYml().getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        MQTT_PASSWORD = loadMqttYml().getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        MQTT_TIMEOUT = Integer.valueOf(loadMqttYml().getProperty(<span class="string">&quot;timeout&quot;</span>));</span><br><span class="line">        MQTT_KEEP_ALIVE = Integer.valueOf(loadMqttYml().getProperty(<span class="string">&quot;keepalive&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从yml从获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Properties <span class="title">loadMqttYml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputstream = ymlUtil.class.getResourceAsStream(&quot;/application.yml&quot;);</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(inputstream);</span><br><span class="line">            <span class="keyword">return</span> properties;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (inputstream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    inputstream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.然后新建一个MqttPushClient类，来发布消息，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.pub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.util.ymlUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.*;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:MQTT消息推送或订阅客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/27 14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttPushClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MqttClient client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> MqttPushClient mqttPushClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MqttPushClient <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mqttPushClient) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MqttPushClient.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mqttPushClient) &#123;</span><br><span class="line">                    mqttPushClient = <span class="keyword">new</span> MqttPushClient();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mqttPushClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MqttPushClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client = <span class="keyword">new</span> MqttClient(ymlUtil.MQTT_HOST, <span class="string">&quot;pub&quot;</span>, <span class="keyword">new</span> MemoryPersistence());</span><br><span class="line">            MqttConnectOptions options = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">            <span class="comment">//连接选项</span></span><br><span class="line">            options.setCleanSession(<span class="keyword">false</span>);</span><br><span class="line">            options.setUserName(ymlUtil.MQTT_USER_NAME);</span><br><span class="line">            options.setPassword(ymlUtil.MQTT_PASSWORD.toCharArray());</span><br><span class="line">            options.setConnectionTimeout(ymlUtil.MQTT_TIMEOUT);</span><br><span class="line">            options.setKeepAliveInterval(ymlUtil.MQTT_KEEP_ALIVE);</span><br><span class="line">            <span class="comment">//保留会话</span></span><br><span class="line">            options.setCleanSession(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//设置回调</span></span><br><span class="line">            client.setCallback(<span class="keyword">new</span> PushCallBack());</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            client.connect(options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发布，默认qos为0，非持久化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pushMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String topic, MqttMessage pushMessage)</span> </span>&#123;</span><br><span class="line">        publish(<span class="number">0</span>, <span class="keyword">false</span>, topic, pushMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(<span class="keyword">int</span> qos, <span class="keyword">boolean</span> retained, String topic, MqttMessage pushMessage)</span> </span>&#123;</span><br><span class="line">        MqttMessage mqttMessage = <span class="keyword">new</span> MqttMessage();</span><br><span class="line">        mqttMessage.setQos(qos);</span><br><span class="line">        mqttMessage.setRetained(retained);</span><br><span class="line">        mqttMessage.setPayload(pushMessage.toString().getBytes());</span><br><span class="line"></span><br><span class="line">        MqttTopic mqttTopic = client.getTopic(topic);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mqttTopic) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;topic not exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MqttDeliveryToken token;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            token = mqttTopic.publish(mqttMessage);</span><br><span class="line">            token.waitForCompletion();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.新建一个类，用于实现回调函数，实现一下MQttCallback类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.pub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttCallback;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:MQTT推送回调类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/27 14:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushCallBack</span> <span class="keyword">implements</span> <span class="title">MqttCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接丢失，用于重连</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionLost</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接已断开，尝试重新连接。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息已经送达，接收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mqttMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageArrived</span><span class="params">(String topic, MqttMessage mqttMessage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// subscribe后得到的消息会执行到这里面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息主题 : &quot;</span> + topic);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息Qos : &quot;</span> + mqttMessage.getQos());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息内容 : &quot;</span> + <span class="keyword">new</span> String(mqttMessage.getPayload()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * publish后会执行到这里，发送的状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iMqttDeliveryToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliveryComplete</span><span class="params">(IMqttDeliveryToken iMqttDeliveryToken)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deliveryComplete...&quot;</span> + iMqttDeliveryToken.isComplete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.新建一个类用于测试，我习惯于controller，所以新建了一个PushController类，清晰明了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.entity.Equiment;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.pub.MqttPushClient;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/27 14:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MqttPushClient instance = MqttPushClient.getInstance();</span><br><span class="line">        MqttMessage message = <span class="keyword">new</span> MqttMessage();</span><br><span class="line">        instance.publish(<span class="string">&quot;topicPub&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.发布的客户端搭建好了，再来以此建立一下订阅的客户端，新建MqttSubClient类，这里一定要注意，ClientId不能重复，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client &#x3D; new MqttClient(ymlUtil.MQTT_HOST, &quot;xxx&quot;, new MemoryPersistence());&#x2F;&#x2F;因为ClientId不能重复，所以这里我就没有再调用工具类来获取yml中的ClientId</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.pub.MqttPushClient;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.pub.PushCallBack;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.util.ymlUtil;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttClient;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttConnectOptions;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttException;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/27 17:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttSubClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MqttClient client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> MqttSubClient mqttSubClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MqttSubClient <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mqttSubClient) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MqttPushClient.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mqttSubClient) &#123;</span><br><span class="line">                    mqttSubClient = <span class="keyword">new</span> MqttSubClient();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mqttSubClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MqttSubClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       connect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client = <span class="keyword">new</span> MqttClient(ymlUtil.MQTT_HOST, <span class="string">&quot;sub&quot;</span>, <span class="keyword">new</span> MemoryPersistence());</span><br><span class="line">            MqttConnectOptions options = <span class="keyword">new</span> MqttConnectOptions();</span><br><span class="line">            <span class="comment">//连接选项</span></span><br><span class="line">            options.setCleanSession(<span class="keyword">false</span>);</span><br><span class="line">            options.setUserName(ymlUtil.MQTT_USER_NAME);</span><br><span class="line">            options.setPassword(ymlUtil.MQTT_PASSWORD.toCharArray());</span><br><span class="line">            options.setConnectionTimeout(ymlUtil.MQTT_TIMEOUT);</span><br><span class="line">            options.setKeepAliveInterval(ymlUtil.MQTT_KEEP_ALIVE);</span><br><span class="line">            <span class="comment">//保留会话</span></span><br><span class="line">            options.setCleanSession(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//设置回调</span></span><br><span class="line">            client.setCallback(<span class="keyword">new</span> PushCallBack());</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            client.connect(options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅某个主题，qos默认为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String topic)</span> </span>&#123;</span><br><span class="line">        subscribe(topic, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅某个主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> qos</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String topic, <span class="keyword">int</span> qos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.subscribe(topic, qos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MqttException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.订阅客户端的回调类，新建SubCallBack，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttCallback;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.paho.client.mqttv3.MqttMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:MQTT订阅回调类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/27 14:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubCallBack</span> <span class="keyword">implements</span> <span class="title">MqttCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接丢失，用于重连</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectionLost</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接已断开，尝试重新连接。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息已经送达，接收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mqttMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageArrived</span><span class="params">(String topic, MqttMessage mqttMessage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// subscribe后得到的消息会执行到这里面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息主题 : &quot;</span> + topic);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息Qos : &quot;</span> + mqttMessage.getQos());</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息内容 : &quot;</span> + <span class="keyword">new</span> String(mqttMessage.getPayload()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * publish后会执行到这里，发送的状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iMqttDeliveryToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliveryComplete</span><span class="params">(IMqttDeliveryToken iMqttDeliveryToken)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;deliveryComplete...&quot;</span> + iMqttDeliveryToken.isComplete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.新建SubController类，用于订阅主题，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.sub.MqttSubClient;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/27 17:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MqttSubClient instance = MqttSubClient.getInstance();</span><br><span class="line">        instance.subscribe(<span class="string">&quot;topicPub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结，由于篇幅太长，看起来很难受，就将测试放在了下一篇，点击<a href="../MQTT%E4%BD%BF%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95(%E4%BA%8C)/index.html">MQTT使用Java连接测试(二)</a>，另一个说明，有人问我为啥把引入的包都贴出来，一个是截图方便(ctrl+A,ctrl+c,ctrl+v)，二是搞错包也挺烦了，有时候出错就是包不对，有问题请指出。</p>
]]></content>
      <categories>
        <category>-MQTT</category>
      </categories>
      <tags>
        <tag>-MQTT -Apollo -Emqx -Springboot -Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT使用Java连接测试-二</title>
    <url>/2020/10/28/MQTT%E4%BD%BF%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95-%E4%BA%8C/</url>
    <content><![CDATA[<p>从服务器到客户端，再到java端，都搞好了，代码已经写好并贴出来了，还有找不到地方的请参看：</p>
<a id="more"></a>

<p><a href="../MQTT%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/index.html">MQTT两种服务器的安装使用</a></p>
<p><a href="../MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85%E5%B9%B6%E8%BF%9E%E6%8E%A5%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">MQTT客户端的安装并连接两种服务器</a></p>
<p><a href="../MQTT%E4%BD%BF%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95-%E4%B8%80/index.html">MQTT使用Java连接测试-一</a></p>
<p>开始测试，我会从Java的发布客户端发布主题后，既能在java的订阅客户端接收到，也能在Mqttfx上面接收到，然后在Mqttfx上发布主题，也必然是在Mqttfx上能接收到，还要在Java的订阅客户端上能接收到，请继续阅读(拷贝)，</p>
<p>1.使用PushController发布一个主题，并设置消息，注意这里就使用Mqtt给我们封装的MqttMessage，我尝试了不使用，然后自己封装一个实体，很麻烦，你如果需要一个实体，可以选择将实体转换为字符串放进去，</p>
<p>这是没有实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MqttPushClient instance = MqttPushClient.getInstance();</span><br><span class="line">        MqttMessage message = <span class="keyword">new</span> MqttMessage();</span><br><span class="line">        message.setPayload(<span class="string">&quot;发布一条消息&quot;</span>.getBytes());</span><br><span class="line">        instance.publish(<span class="string">&quot;topicPub&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建一个实体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/28 10:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Equiment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是发布实体的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MqttPushClient instance = MqttPushClient.getInstance();</span><br><span class="line">        MqttMessage message = <span class="keyword">new</span> MqttMessage();</span><br><span class="line">        Equiment equiment = <span class="keyword">new</span> Equiment();</span><br><span class="line">        equiment.setId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        equiment.setName(<span class="string">&quot;井盖&quot;</span>);</span><br><span class="line">        equiment.setWeight(<span class="string">&quot;25.5&quot;</span>);</span><br><span class="line">        equiment.setStatus(<span class="number">1</span>);</span><br><span class="line">        String s = JSONObject.toJSONString(equiment);</span><br><span class="line">        message.setPayload(s.getBytes());</span><br><span class="line">        instance.publish(<span class="string">&quot;topicPub&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在Mqttfx中订阅主题topicPub，在订阅客户端也订阅这个主题，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MqttSubClient instance = MqttSubClient.getInstance();</span><br><span class="line">        instance.subscribe(<span class="string">&quot;topicPub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.1.png" alt="3.1"></p>
<p>3.然后先将SubController跑起来，再跑PushController，</p>
<p>这是没有使用实体类的订阅客户端数据和Mqttfx数据，都接收到了</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.2.png" alt="3.2"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.3.png" alt="3.3"></p>
<p>4.再看一下实体类，这里需要导入一下fastjson的依赖，然后将实体类转为了字符串，可以看到都接收到了正确的主题内容，</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.4.png" alt="3.4"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.5.png" alt="3.5"></p>
<p>5.再测试一下从Mqttfx发布一个主题，看Java端和Mqttfx端能否同时接收到，同样需要先订阅，再发布，</p>
<p>发布主题及其内容：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.6.png" alt="3.6"></p>
<p>Mqttfx端接收：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.7.png" alt="3.7"></p>
<p>Java端接收;</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.8.png" alt="3.8"></p>
<p>6.测试都没有问题了，我们再看一下Emqx给提供的后台管理界面，首页就不看了，一些监控信息，看一下客户端，</p>
<p>push就是Java中的发布端客户端，sub就是Java中的订阅端客户端，fx就是Mqttfx工具的客户端：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.9.png" alt="3.9"></p>
<p>这是刚刚测试的两个主题：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/3.10.png" alt="3.10"></p>
<p>总结，我自己也测试了一下Apollo，也没有问题的，操作一模一样，就不贴出来了，感觉还是Emqx安逸一点，另外一点就是我还没有尝试将其放在linux上，甚至docker上，但是想来应该差不多吧，只要对linux和docker熟悉一点，差异不会太大，最后提醒：ClientId必须唯一，真别忘了，希望明年的我看到我自己的文章，会有不错的回忆。</p>
]]></content>
      <categories>
        <category>-MQTT</category>
      </categories>
      <tags>
        <tag>-MQTT -Apollo -Emqx -Springboot -Java -Mqttfx</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT客户端的安装并连接两种服务器</title>
    <url>/2020/10/28/MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85%E5%B9%B6%E8%BF%9E%E6%8E%A5%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>在上一篇文章中搞定了服务器的问题，那么这里再安装一波MQTT的客户端，同样先给自己留下以后方便使用的百度云链接，服务器安装可参看：</p>
<p><a href="../MQTT%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/index.html">MQTT两种服务器的安装使用</a></p>
<a id="more"></a>

<p>链接：<a href="https://pan.baidu.com/s/1hm8Tx7z5ko7TdLcyt8oCDQ">https://pan.baidu.com/s/1hm8Tx7z5ko7TdLcyt8oCDQ</a><br>提取码：szj0 </p>
<p>下载，解压，安装。。。</p>
<p>1.安装好了，我也试了两种服务器的连接，首先是Apollo，ip是本地ip也就是127.0.0.1(linux应该是自己设置的静态ip)，端口就是服务器启动时的tcp连接的端口61613，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.1.png" alt="2.1"></p>
<p>2.打开MQTTfx软件，点击设置(可以说很形象了)，请注意未连接的时候是灰色的，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.2.png" alt="2.2"></p>
<p>3.配置一下Apollo，然后OK或者Apply都行，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.3.png" alt="2.3"></p>
<p>4.配置好了就可以快乐的点击连接Connect了，请注意，连接成功的时候小锁会打开，颜色会变，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.4.png" alt="2.4"></p>
<p>5.最后，当然是在Apollo提供的后台管理页面查看是否连接成功啦，这里没有进行测试，是因为我会在后面使用Springboot来集成MQTT，到时候一起测试，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.5.png" alt="2.5"></p>
<p>6.测试成功了Apollo，当然还要试试Emqx，毕竟我更喜欢它，还是先启动起来（不会吧不会吧，不会有人这几个命令都记不住吧），好吧，我就忘了，翻看了一下上一篇笔记<a href="../MQTT%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/index.html">MQTT两种服务器的安装使用</a>，好记性不如烂笔头，因为Emqx启动不会有信息打印，建议使用命令查看一下服务器的状态，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.6.png" alt="2.6"></p>
<p>7.同样点击连接，然后点击左下角的加号新增一个连接，注意Emqx连接端口是1883，然后点击连接，小锁一开，颜色一变，Emqx后台管理页面一看，没毛病。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.7.png" alt="2.7"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.8.png" alt="2.8"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.9.png" alt="2.9"></p>
<p>总结：依然没啥难度，我，胖虎，膨胀了，值得一提的是，要注意ClientId要保持唯一(别问我咋知道的，反正自己看图)，接下来就准备后台连接测试了，我写的比较详细，都是自己的理解，我也是第一次用，为了以后自己能看懂，有错的话也请大佬提出来，感谢万分。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/2.10.png" alt="2.10"></p>
]]></content>
      <categories>
        <category>-MQTT</category>
      </categories>
      <tags>
        <tag>-MQTT -Apollo -Emqx -Mqttfx</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT接收消息存储到数据库-使用Knife4j框架</title>
    <url>/2020/11/06/MQTT%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BD%BF%E7%94%A8Knife4j%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>MQTT数据测试也没得问题了，虽然我也不知道为啥消息要存储要数据库，但是老大有需求，责无旁贷嘛，顺便我还想试试Knife4j框架，是基于Swagger搭建的，不会Swagger和MQTT消息发布接受请参看：</p>
<a id="more"></a>

<p><a href="../Springboot%E6%95%B4%E5%90%88Swagger/index.xml">Springboot整合Swagger</a></p>
<p><a href="../MQTT%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%89%E8%A3%85%E5%B9%B6%E8%BF%9E%E6%8E%A5%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8/index.xml">MQTT客户端的安装并连接两种服务器</a></p>
<p><a href="../MQTT%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/index.xml">MQTT两种服务器的安装使用</a></p>
<p><a href="../MQTT%E4%BD%BF%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95-%E4%B8%80/index.xml">MQTT使用Java连接测试-一</a></p>
<p><a href="../MQTT%E4%BD%BF%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95-%E4%BA%8C/index.xml">MQTT使用Java连接测试-二</a></p>
<p>1.毫无疑问先导包，导入Knife4j、Druid、MybatisPlus以及Mysql的依赖，需要更换其他版本，可以去中央仓库更换(md，两次非人类验证就很烦)，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--        引入mybatis-plus的依赖--&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.3.2&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;!--        引入数据源连接池德鲁伊Druid--&gt;</span><br><span class="line">   &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.1.20&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.github.xiaoymin&#x2F;swagger-bootstrap-ui --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.9.6&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-validation&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.github.xiaoymin&#x2F;knife4j-spring-boot-starter --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;knife4j-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;2.0.4&lt;&#x2F;version&gt;</span><br><span class="line">   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.新建实体类，这里主要说一下主键生成策略，我试了一下MybatisPlus提供的@TableId(value = “ID”,type = IdType.AUTO)方式，又试了一下JPA提供的@GeneratedValue(strategy = GenerationType.IDENTITY)方式，说实话，md，一模一样，随便用哪种，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/16.1.png" alt="16.1"></p>
<p>3.新建一个Mapper，用于继承MybatisPlus的baseMapper，简单的CRUD我真觉得没必要写啊，你说复杂的连表多表之类谢谢sql，这种还写sql纯属有点浪费时间了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootmqtt.entity.AlertInfo;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/5 16:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AlertInfoMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">AlertInfo</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.好像忘了说Knife4j的框架，主要是和Swagger一模一样，就给忘了，就是换一下依赖，登录的路径不一样，其他？md，一样的啊，说一下开启Authorize加token吧，(虽然我这里没用到，但是在我上一个项目用了，感觉很舒服),注意和我上一篇文章对比一下，就知道了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.classmate.TypeResolver;</span><br><span class="line"><span class="keyword">import</span> com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;</span><br><span class="line"><span class="keyword">import</span> com.github.xiaoymin.swaggerbootstrapui.service.SpringAddtionalModelService;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"><span class="keyword">import</span> springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.*;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.service.contexts.SecurityContext;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/5 11:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启Swagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="meta">@Import(BeanValidatorPluginsConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;groupRestApi&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">groupRestApi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;设备模块&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;cn.zl.springbootmqtt.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .securityContexts(Lists.newArrayList(securityContext(),securityContext())).securitySchemes(Lists.&lt;SecurityScheme&gt;newArrayList(apiKey()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiKey <span class="title">apiKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiKey(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> SecurityContext <span class="title">securityContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .forPaths(PathSelectors.regex(<span class="string">&quot;/.*&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;SecurityReference&gt; <span class="title">defaultAuth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AuthorizationScope authorizationScope = <span class="keyword">new</span> AuthorizationScope(<span class="string">&quot;global&quot;</span>, <span class="string">&quot;accessEverything&quot;</span>);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = <span class="keyword">new</span> AuthorizationScope[<span class="number">1</span>];</span><br><span class="line">        authorizationScopes[<span class="number">0</span>] = authorizationScope;</span><br><span class="line">        <span class="keyword">return</span> Lists.newArrayList(<span class="keyword">new</span> SecurityReference(<span class="string">&quot;token&quot;</span>, authorizationScopes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Swagger信息-apiInfo</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//作者信息</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;ZL&quot;</span>,<span class="string">&quot;http://www.zllwsy.com&quot;</span>,<span class="string">&quot;zllwsy@outlook.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;ZL的SwaggerAPI文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;学习永无止境&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;localhost:8088/doc.html&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.写一写Controller，我把发布和订阅放在一起了，方便调用接口，参数是我为了测试一下Knife4j的功能展示，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags = &quot;订阅发布&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/topic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqttController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="meta">@ApiOperationSupport(author = &quot;zllwsy&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;发布消息&quot;, notes=&quot;发布消息&quot;, produces=&quot;application/json&quot;)</span></span><br><span class="line">    <span class="meta">@ApiImplicitParams(&#123;</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;word&quot;, value = &quot;单词&quot;, paramType = &quot;query&quot;, required = true, dataType = &quot;String&quot;),</span></span><br><span class="line"><span class="meta">            @ApiImplicitParam(name = &quot;name&quot;, value = &quot;名字&quot;, paramType = &quot;query&quot;, required = true, dataType = &quot;String&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/push&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushTopic</span><span class="params">(String word,String name)</span> </span>&#123;</span><br><span class="line">        MqttPushClient instance = MqttPushClient.getInstance();</span><br><span class="line">        MqttMessage message = <span class="keyword">new</span> MqttMessage();</span><br><span class="line">        AlertInfo alertInfo = <span class="keyword">new</span> AlertInfo();</span><br><span class="line">        alertInfo.setWdaDeviceCode(<span class="string">&quot;007&quot;</span>);</span><br><span class="line">        alertInfo.setWdaDeviceType(<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        alertInfo.setWdaAlarmType(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        alertInfo.setWdaAlarmTime(<span class="keyword">new</span> Date());</span><br><span class="line">        alertInfo.setWdaAlarmContent(<span class="string">&quot;到底啥数据呀&quot;</span>);</span><br><span class="line">        alertInfo.setWdaRemark(<span class="string">&quot;我傻了&quot;</span>);</span><br><span class="line">        String s = JSONObject.toJSONString(alertInfo);</span><br><span class="line">        message.setPayload(s.getBytes());</span><br><span class="line">        instance.publish(<span class="string">&quot;topicPub&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperationSupport(author = &quot;zllwsy&quot;)</span></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;订阅消息&quot;, notes=&quot;订阅消息&quot;, produces=&quot;application/json&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sub&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subTopic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MqttSubClient instance = MqttSubClient.getInstance();</span><br><span class="line">        instance.subscribe(<span class="string">&quot;topicPub&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.在订阅客户端的回调函数里面对接收到的消息进行处理，也是在上次的基础上添加的，不懂得一定要看看另外几篇，我觉得挺详细的，因为MQTT接收的数据是byte[]格式，我就把它放进队列里面，然后再取出来转为了String，再将String转换为实体类，然后就插入数据库了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息已经送达，接收到消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mqttMessage</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageArrived</span><span class="params">(String topic, MqttMessage mqttMessage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// subscribe后得到的消息会执行到这里面</span></span><br><span class="line">    System.out.println(<span class="string">&quot;接收消息主题 : &quot;</span> + topic);</span><br><span class="line">    System.out.println(<span class="string">&quot;接收消息Qos : &quot;</span> + mqttMessage.getQos());</span><br><span class="line">    System.out.println(<span class="string">&quot;接收消息内容 : &quot;</span> + <span class="keyword">new</span> String(mqttMessage.getPayload()));</span><br><span class="line">    Queue&lt;<span class="keyword">byte</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line">    q.add(mqttMessage.getPayload()); <span class="comment">//放入队列</span></span><br><span class="line">    <span class="keyword">byte</span>[] c = q.peek(); <span class="comment">//取得队头元素</span></span><br><span class="line">    String res = <span class="keyword">new</span> String(c);<span class="comment">//使用构造函数转换成字符串</span></span><br><span class="line">    AlertInfo alertInfo = JSONObject.parseObject(res , AlertInfo.class);</span><br><span class="line">    System.out.println(alertInfo);</span><br><span class="line">    <span class="keyword">if</span> (alertInfo != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            alertInfoMapper = BeanUtil.getBean(AlertInfoMapper.class);</span><br><span class="line">            alertInfoMapper.insert(alertInfo);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.debug(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;device的值为null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.如果是认真在看再学的已经发现了一下问题，这里我使用了手动获取bean，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/16.2.png" alt="16.2"></p>
<p>8.为啥手动获取？(手动黑脸)，没办法啊，不知道为啥注入一直失败报alertInfoMapper为null，Mapper和Service都失败，我找了好久的问题，最后可能是这个回调方法运行的时候，Mapper都还没有开始加载，反正就一直alertInfoMapper报空指针，最后实在没办法，我就只有手动写个工具获取bean，(可别说我没写@MapperScan注解了，谁试谁知道，)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootmqtt.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/5 10:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtil</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContextParam)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            applicationContext=applicationContextParam;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getObject</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">            Object object = <span class="keyword">null</span>;</span><br><span class="line">            object = applicationContext.getBean(id);</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getObject</span><span class="params">(Class&lt;T&gt; tClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> applicationContext.getBean(tClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String tClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> applicationContext.getBean(tClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; tClass)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> applicationContext.getBean(tClass);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.害，勉强过得去，启动项目，记得加上@EnableSwagger2注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableSwagger2</span><br><span class="line">@MapperScan(&quot;cn.zl.springbootmqtt.mapper&quot;)</span><br><span class="line">public class SpringbootMqttApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootMqttApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.在浏览器输入路径，<a href="http://localhost:8088/doc.html%EF%BC%8C%E5%BD%93%E7%84%B6%E4%BD%A0%E8%BE%93%E5%85%A5%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84ip%E5%92%8C%E7%AB%AF%E5%8F%A3%EF%BC%8C%E5%88%AB%E8%AF%B4%EF%BC%8C%E8%BF%98%E6%8C%BA%E5%A5%BD%E7%9C%8B%EF%BC%8C">http://localhost:8088/doc.html，当然你输入你自己的ip和端口，别说，还挺好看，</a></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/16.3.png" alt="16.3"></p>
<p>11.测试，先订阅，再发布，很抱歉，这里是回调函数，没得返回的参数，就很尴尬，所以还是看控制台的输出和数据库数据的生成把，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/16.4.png" alt="16.4"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/16.5.png" alt="16.5"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/16.6.png" alt="16.6"></p>
<p>12.差点忘了，还有个yml配置，还是需要给一份，万一以后我自己忘了呢，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#mq配置</span><br><span class="line">com:</span><br><span class="line">  mqtt:</span><br><span class="line">    host: tcp:&#x2F;&#x2F;x.x.x.x:1883</span><br><span class="line">    clientId: SubServer  #一定要唯一</span><br><span class="line">    topic: good,test,yes</span><br><span class="line">    username: admin</span><br><span class="line">    password: public</span><br><span class="line">    timeout: 10</span><br><span class="line">    keepalive: 20</span><br><span class="line"></span><br><span class="line">#配置数据库</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: xxxx</span><br><span class="line">    password: xxxx</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;x.x.x.x:3306&#x2F;lslmp?characterEncoding&#x3D;UTF-8&amp;serverTimezone&#x3D;UTC</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">#日志</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">    cn:</span><br><span class="line">      zl:</span><br><span class="line">       springbootmqtt: debug</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">    map-underscore-to-camel-case: true</span><br><span class="line">  type-aliases-package: cn.zl.springbootmqtt.entity</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8088</span><br></pre></td></tr></table></figure>

<p>13.有一个时区的问题，将数据库连接的时候serverTimezone=UTC改为serverTimezone=GMT%2B8就可以了，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/16.7.png" alt="16.7"></p>
<p>14.给一下接口框架的常用注解解析，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api：修饰整个类，描述Controller的作用</span><br><span class="line"></span><br><span class="line">@ApiOperation：描述一个类的一个方法，或者说一个接口</span><br><span class="line"></span><br><span class="line">@ApiParam：单个参数描述</span><br><span class="line"></span><br><span class="line">@ApiModel：用对象来接收参数</span><br><span class="line"></span><br><span class="line">@ApiProperty：用对象接收参数时，描述对象的一个字段</span><br><span class="line"></span><br><span class="line">@ApiResponse：HTTP响应其中1个描述</span><br><span class="line"></span><br><span class="line">@ApiResponses：HTTP响应整体描述</span><br><span class="line"></span><br><span class="line">@ApiIgnore：使用该注解忽略这个API</span><br><span class="line"></span><br><span class="line">@ApiError ：发生错误返回的信息</span><br><span class="line"></span><br><span class="line">@ApiImplicitParam：描述一个请求参数，可以配置参数的中文含义，还可以给参数设置默认值</span><br><span class="line"></span><br><span class="line">@ApiImplicitParams：描述由多个 @ApiImplicitParam 注解的参数组成的请求参数列表</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>总结，遇到了一些问题，尤其是Mapper那里为null的时候，真的找了好久，其实现在也不是很确定原因，总归是实现了，你学到了嘛，</p>
]]></content>
      <categories>
        <category>-MQTT</category>
      </categories>
      <tags>
        <tag>-MQTT -Apollo -Emqx -Mqttfx -Knife4j -Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis中的Type和Map</title>
    <url>/2020/09/14/Mybatis%E4%B8%AD%E7%9A%84Type%E5%92%8CMap/</url>
    <content><![CDATA[<h4 id="restultMap与resultType"><a href="#restultMap与resultType" class="headerlink" title="restultMap与resultType"></a>restultMap与resultType</h4><p>偶然发现有点分不清两者的具体区别，查阅资料，翻看了一些博客，总结了一下。</p>
<p>Map：映射；Type：Java类型</p>
<a id="more"></a>

<p>resutltType：当使用resultType做SQL语句返回结果类型处理时，对于SQL语句查询出的字段在相应的pojo中必须有和它相同的字段对应，而resultType中的内容就是pojo在本项目中的位置，也就说说实体类中必须有的字段才行，要么就单独建一个包含这几个字段的实体类用来映射，一般适用于简单数据类型；</p>
<p>resultMap：当使用resultMap做SQL语句返回结果类型处理时，通常需要在mapper.xml中定义ResultMap进行pojo和相应表字段的对应。还可以表示对象间一对一、一对多、多对多、多对一等关系，适用于多表查询；</p>
<p>ResultMap标签及其子标签部分属性：</p>
<p>　　　　id：指定查询结果集中的唯一标识，即主键，可配置多个； 　　　column：查询结果集中的列名； 　　　property：需要映射到java对象中的属性名。    　ResultType：将查询结果集中的各个列，一一映射到java对象中与列名一致的属性中。换句话说，此处查询结果集到java对象的映射关系是固定的，只有列名和属性名相同，该列才能映射成功。多表例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;AMap&quot; type&#x3D;&quot;cn.zl.AInfo&quot;&gt;</span><br><span class="line">   &lt;result property&#x3D;&quot;id&quot; column&#x3D;&quot;ID&quot; &#x2F;&gt;</span><br><span class="line">   &lt;result property&#x3D;&quot;code&quot; column&#x3D;&quot;CODE&quot; &#x2F;&gt;</span><br><span class="line">       &lt;association property&#x3D;&quot;BMap&quot; javaType&#x3D;&quot;cn.zl.BInfo&quot;&gt;</span><br><span class="line">       &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;ID&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">       &lt;result property&#x3D;&quot;pid&quot; column&#x3D;&quot;PID&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">       &lt;&#x2F;association&gt;</span><br><span class="line">       &lt;association property&#x3D;&quot;CMap&quot; javaType&#x3D;&quot;cn.zl.CInfo&quot;&gt;</span><br><span class="line">       &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;ID&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">       &lt;result property&#x3D;&quot;typeId&quot; column&#x3D;&quot;TYPE_ID&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">       &lt;&#x2F;association&gt;</span><br><span class="line">       &lt;association property&#x3D;&quot;DMap&quot;javaType&#x3D;&quot;cn.zl.DInfo&quot;&gt;</span><br><span class="line">       &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;ID&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">       &lt;result property&#x3D;&quot;inoutId&quot; column&#x3D;&quot;INOUT_ID&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">       &lt;result property&#x3D;&quot;materialId&quot; column&#x3D;&quot;MATERIAL_ID&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">       &lt;&#x2F;association&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>

<h4 id="ParameterMap-不推荐-和parameterType"><a href="#ParameterMap-不推荐-和parameterType" class="headerlink" title="ParameterMap(不推荐)和parameterType"></a>ParameterMap(不推荐)和parameterType</h4><p>ParameterMap和resultMap类似，表示将查询结果集中列值的类型——映射到java对象属性的类型上，一般开发中不适用这种方式</p>
<p>一般使用parameterType直接将查询结果列值类型自动对应到java对象属性类型上，不再配置映射关系一一对应</p>
]]></content>
      <categories>
        <category>-mybatis</category>
      </categories>
      <tags>
        <tag>-resultMap -resultType -ParameterMap -parameterType</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT部署EMQX到云服务器</title>
    <url>/2020/11/06/MQTT%E9%83%A8%E7%BD%B2EMQX%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>因为是试用的云服务器，迫切的想尝试一切可以试用的，我也把Mqtt的Emqx放到了云服务器中，然后IDEA修改配置即可，其他没有差别，稍微记录一下，Windows可以参看:</p>
<a id="more"></a>

<p><a href="../MQTT%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/index.html">MQTT两种服务器的安装使用</a></p>
<p>1.首先安装一些工具包，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/12.1.png" alt="12.1"></p>
<p>2.安装设置Emqx的镜像库，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https:&#x2F;&#x2F;repos.emqx.io&#x2F;emqx-ce&#x2F;redhat&#x2F;centos&#x2F;7&#x2F;emqx-ce.repo</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/12.2.png" alt="12.2"></p>
<p>3.直接安装最新版的Emqx，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install emqx</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/12.3.png" alt="12.3"></p>
<p>4.启动Emqx，执行命令;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emqx start</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/12.4.png" alt="12.4"></p>
<p>5.外网通过ip+端口访问，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/12.5.png" alt="12.5"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/12.6.png" alt="12.6"></p>
<p>总结，我自己在后台测试了，还是开始一样的测试，只是改了ip而已，数据和主题都没变，再传上来就很繁琐重复了，果然说的和Windows没啥差别，只要稍微会一点Linux基本命令就行。</p>
<p>测试不会的可以参看：</p>
<p><a href="../MQTT%E8%AF%95%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95-%E4%B8%80/index.html">MQTT试用Java连接测试-一</a></p>
<p><a href="../MQTT%E8%AF%95%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95-%E4%BA%8C/index.html">MQTT试用Java连接测试-二</a></p>
]]></content>
      <categories>
        <category>-MQTT</category>
      </categories>
      <tags>
        <tag>-MQTT -Apollo -Emqx -Mqttfx -阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Docker安装Mysql</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-Docker%E5%AE%89%E8%A3%85Mysql/</url>
    <content><![CDATA[<p>Docker中安装Mysql镜像。</p>
<a id="more"></a>

<p>1.首先照例查看服务器是否已经安装了mysql，执行命令查看，如果安装了回打印路径，没有安装则无提示，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201111153336249.png" alt="image-20201111153336249"></p>
<p>2.使用docker拉取mysql5.7，因为这是最稳定的版本，Docker安装不会的请参看<a href="./redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">redis在docker中的使用</a>,不使用docker安装mysql8.0请参看<a href="../%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%BA%8C-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85mysql/index.html">阿里云安装mysql</a>,直接执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201111153918232.png" alt="image-20201111153918232"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201111154946580.png" alt="image-20201111154946580"></p>
<p>3.mysql5.7的镜像已经安装完成，然后直接创建一个实例并运行，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v &#x2F;home&#x2F;user&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-v &#x2F;home&#x2F;user&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;home&#x2F;user&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201111155009782.png" alt="image-20201111155009782"></p>
<p>4.进入conf文件夹，新建mysql.conf配置文件，添加mysql的配置文件，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">&#x2F;&#x2F;mysqlde utf8字符集默认为3位的，不支持emoji表情及部分不常见的汉字，故推荐使用utf8mb4</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">&#x2F;&#x2F;设置client连接mysql时的字符集,防止乱码</span><br><span class="line">init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_general_ci&#39;</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数据库默认字符集</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数据库字符集对应一些排序等规则，注意要和character-set-server对应</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳过mysql程序起动时的字符参数设置 ，使用服务器端字符集设置</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这是几个重点需要设置的，涉及到docker下mysql的编码问题，方便复制：</span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure>

<p>5.设置实例开机启动，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker update --restart&#x3D;always 实例ID&#x2F;name</span><br></pre></td></tr></table></figure>

<p>6.进入mysql容器，并登录，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql &#x2F;bin&#x2F;bash &#x2F;&#x2F;进入容器</span><br><span class="line"></span><br><span class="line">mysql -uroot -p  &#x2F;&#x2F;运行mysql</span><br></pre></td></tr></table></figure>

<p>7.上述的进入容器本身是没有问题的，但是不支持中文啊，mysql难免需要输入中文，头疼，查了许久，修改命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql env LANG&#x3D;C.UTF-8 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112100130712.png" alt="image-20201112100130712"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112092648977.png" alt="image-20201112092648977"></p>
<p>8.docker下没问题了，就尝试远程连接，使用windows下的可视化工具连接一下，并建一个数据库和表测试，连接的话，就是连接阿里云的公网ip，端口3306，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112092809303.png" alt="image-20201112092809303"></p>
<p>9.再进入docker下的mysql，查看数据库和表，数据是否正确，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112092951220.png" alt="image-20201112092951220"></p>
<p>总结，别笑话，这编码我弄了好久，我试了很久，查看日志也一直是没有报错信息，我查看了docker运行mysql的内部配置文件，也是没问题的，其实最后好的也莫名奇妙，因为这个配置我最开始就试过，但是还是没法输入中文，就算我在navicat中建表输入中文都会报错，但是莫名又好了，这是一次糟糕的情况，因为没找到问题，也一头雾水的好了(手动黑脸)。</p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Sql性能分析及优化</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-Explain%E8%BF%9B%E8%A1%8CSql%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="MySQL-Query-Optimizer-的作用"><a href="#MySQL-Query-Optimizer-的作用" class="headerlink" title="MySQL Query Optimizer 的作用"></a>MySQL Query Optimizer 的作用</h4><a id="more"></a>

<ol>
<li>MySQL 中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（MySQL认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间）</li>
<li>当客户端向MySQL 请求一条Query，命令解析器模块完成请求分类，区别出是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer 首先会对整条Query进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对Query中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query中的Hint信息（如果有），看显示Hint信息是否可以完全确定该Query的执行计划。如果没有Hint 或Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据Query进行写相应的计算分析，然后再得出最后的执行计划。</li>
</ol>
<h4 id="Mysql常见瓶颈"><a href="#Mysql常见瓶颈" class="headerlink" title="Mysql常见瓶颈"></a>Mysql常见瓶颈</h4><ol>
<li>CPU ：CPU在饱和的时候一般发生在数据装入在内存或从磁盘上读取数据时候</li>
<li>IO ：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li>
<li>服务器硬件的性能瓶颈：top、free、iostat和vmstat来查看系统的性能状态</li>
</ol>
<h4 id="Explain的使用"><a href="#Explain的使用" class="headerlink" title="Explain的使用"></a>Explain的使用</h4><h5 id="Explain是什么？"><a href="#Explain是什么？" class="headerlink" title="Explain是什么？"></a><strong>Explain是什么？</strong></h5><p>使用Explain关键字可以模拟优化器执行SQL语句，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈</p>
<h5 id="Explain能干嘛？"><a href="#Explain能干嘛？" class="headerlink" title="Explain能干嘛？"></a><strong>Explain能干嘛？</strong></h5><p>表的读取顺序</p>
<p>数据读取操作的操作类型</p>
<p>哪些索引可以使用</p>
<p>哪些索引被实际使用</p>
<p>表之间的引用</p>
<p>每张表有多少行被优化器查询</p>
<h5 id="Explain怎么用？"><a href="#Explain怎么用？" class="headerlink" title="Explain怎么用？"></a><strong>Explain怎么用？</strong></h5><p>Explain + SQL语句</p>
<p><img src="D:\zl\Typora\Mysql\image\image-20201112161534995.png" alt="image-20201112161534995"></p>
<p>执行计划包含的信息(字段)：</p>
<p><img src="D:\zl\Typora\Mysql\image\image-20201112161743172.png" alt="image-20201112161743172"></p>
<h5 id="Explain字段详解"><a href="#Explain字段详解" class="headerlink" title="Explain字段详解"></a>Explain字段详解</h5><blockquote>
<h6 id="id："><a href="#id：" class="headerlink" title="id："></a>id：</h6><p>select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p>
</blockquote>
<p>id的值有三种情况：</p>
<ol>
<li><p><strong>id相同</strong>，表示执行顺序由上至下，执行顺序是t1、t2、t3</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format2.png" alt="format2"></p>
</li>
<li><p><strong>id不同</strong>，如果是子查询，id的序号会递增，<strong>id值越大优先级越高，越先被执行</strong>，所以执行顺序是t3、t2、t1</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format3.png" alt="format3"></p>
</li>
<li><p><strong>id相同不同</strong>，同时存在：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行；衍生=DERIVED.执行顺序为t3、derived2、t2</p>
</li>
</ol>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format4.png" alt="format4"></p>
<blockquote>
<h6 id="select-type："><a href="#select-type：" class="headerlink" title="select_type："></a>select_type：</h6><p>查询的类型，主要用于区别普通查询、联合查询、子查询等复杂查询</p>
</blockquote>
<ol>
<li><strong>SIMPLE</strong>：简单的select查询，查询中不包含子查询或者UNION</li>
<li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</li>
<li><strong>SUBQUERY</strong>：在SELECT或者WHERE列表中包含了子查询</li>
<li><strong>DERIVED</strong>：在FROM列表中包含的子查询被标记为DERIVED（衍生）MySQL会递归执行这些子查询，把结果放在临时表里</li>
<li><strong>UNION</strong>：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</li>
<li><strong>UNION RESULT</strong>：从UNION表获取结果的SELECT</li>
</ol>
<p>测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain </span><br><span class="line">select * from tbl_emp emp left join tbl_dept dept on emp.deptId &#x3D; dept.id  </span><br><span class="line">union </span><br><span class="line">select * from tbl_emp emp right join tbl_dept dept on emp.deptId &#x3D; dept.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112164913746.png" alt="image-20201112164913746"></p>
<blockquote>
<h6 id="table：显示这一行的数据是关于哪张表的"><a href="#table：显示这一行的数据是关于哪张表的" class="headerlink" title="table：显示这一行的数据是关于哪张表的"></a><strong>table：显示这一行的数据是关于哪张表的</strong></h6></blockquote>
<blockquote>
<h6 id="type：访问类型排列，显示查询使用了何种类型"><a href="#type：访问类型排列，显示查询使用了何种类型" class="headerlink" title="type：访问类型排列，显示查询使用了何种类型"></a><strong>type：访问类型排列，显示查询使用了何种类型</strong></h6></blockquote>
<ol>
<li><p>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是，百万级数据量尤为注意，All为全表扫描：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">system&gt;const&gt;eq_ref&gt;ref&gt;fultext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;ALL</span><br></pre></td></tr></table></figure>
</li>
<li><p>挑重要的来说：<code>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</code>，一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
</li>
</ol>
<hr>
<p><strong>从最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong></p>
<p>1.<strong>system</strong>：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计</p>
<p>2.<strong>const</strong>：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format5.png" alt="format5"></p>
<p>3.<strong>eq_ref</strong>：唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format6.png" alt="format6"></p>
<p>4.<strong>ref</strong>：非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format7.png" alt="format7"></p>
<p>5.<strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了<code>between</code>、<code>&lt;</code>、<code>&gt;</code>、<code>in</code>等的查询这种范围扫描索引扫描比全表扫描要好，因为他<strong>只需要开始索引的某一点，而结束于另一点，不用扫描全部索引</strong></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format9.png" alt="format9"></p>
<p>6.<strong>index</strong>：Full Index Scan，index与ALL区别为index类型<strong>只遍历索引树</strong>。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说<strong>虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘数据库文件中读的</strong>）</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format10.png" alt="format10"></p>
<p>7.<strong>all</strong>：FullTable Scan，<strong>将遍历全表以找到匹配的行（全表扫描）</strong></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format11.png" alt="format11"></p>
<blockquote>
<h6 id="possible-keys："><a href="#possible-keys：" class="headerlink" title="possible_keys："></a>possible_keys：</h6><p>显示可能应用在这张表中的索引，一个或多个；查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用；</strong></p>
</blockquote>
<blockquote>
<h6 id="key："><a href="#key：" class="headerlink" title="key："></a>key：</h6><p>实际使用的索引，如果为null，则表示没有使用索引；若查询中使用了覆盖索引，则该索引仅出现在key列表中；</p>
</blockquote>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format12.png" alt="format12"></p>
<blockquote>
<h6 id="key-len："><a href="#key-len：" class="headerlink" title="key_len："></a>key_len：</h6><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好；<br>key_len显示的值为索引最大可能长度，<strong>并非实际使用长度</strong>，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
</blockquote>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format13.png" alt="format13"></p>
<blockquote>
<h6 id="ref："><a href="#ref：" class="headerlink" title="ref："></a>ref：</h6><p>显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值；</p>
</blockquote>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113095835988.png" alt="image-20201113095835988"></p>
<blockquote>
<h6 id="rows："><a href="#rows：" class="headerlink" title="rows："></a>rows：</h6><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p>
</blockquote>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format14.png" alt="format14"></p>
<blockquote>
<h6 id="Extra："><a href="#Extra：" class="headerlink" title="Extra："></a>Extra：</h6><p>包含不适合在其他列中显示但十分重要的额外信息，三千个较为重要</p>
</blockquote>
<p>1.<strong>Using filesort（文件排序）：</strong></p>
<ul>
<li>MySQL中无法利用索引完成排序操作成为“文件排序”</li>
<li>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取</li>
<li><strong>出现 Using filesort 不好（九死一生），需要尽快优化 SQL</strong></li>
<li>示例中第一个查询只使用了 col1 和 col3，原有索引派不上用场，所以进行了外部文件排序</li>
<li>示例中第二个查询使用了 col1、col2 和 col3，原有索引派上用场，无需进行文件排序</li>
</ul>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format15.png" alt="format15"></p>
<p>2.<strong>Using temporaty(创建了临时表)：</strong></p>
<ul>
<li>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by</li>
<li><strong>出现 Using temporary 超级不好（十死无生），需要立即优化 SQL</strong></li>
<li>示例中第一个查询只使用了 col1，原有索引派不上用场，所以创建了临时表进行分组</li>
<li>示例中第二个查询使用了 col1、col2，原有索引派上用场，无需创建临时表</li>
</ul>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format16.png" alt="format16"></p>
<p>3.<strong>Using index(覆盖索引)：</strong></p>
<ul>
<li>表示相应的select操作中使用了覆盖索引（Coveing Index），避免访问了表的数据行，效率不错！</li>
<li>如果同时出现using where，表明索引被用来执行索引键值的查找</li>
<li>如果没有同时出现using where，表明索引用来读取数据而非执行查找动作</li>
<li><strong>覆盖索引（Covering Index），也说为索引覆盖</strong><ul>
<li>理解方式一：就是<strong>select的数据列只用从索引中就能够取得，不必读取数据行</strong>，MySQL可以<strong>利用索引返回select列表中的字段，而不必根据索引再次读取数据文件</strong>，换句话说查询列要被所建的索引覆盖。</li>
<li>理解方式二：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。</li>
<li>注意：<strong>如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可<code>select *</code></strong> ，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format17.png" alt="format17"></p>
<p>4.Using where：表明使用了where过滤</p>
<p>5.Using join buffer：表明使用了连接缓存</p>
<p>6.impossible where：where子句的值总是false，不能用来获取任何元组</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format18.png" alt="format18"></p>
<p>7.select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化<code>COUNT(*)</code>操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p>
<p>8.distinct：优化distinct，在找到第一匹配的元组后即停止找同样值的工作</p>
<h5 id="Explain之热身Case"><a href="#Explain之热身Case" class="headerlink" title="Explain之热身Case"></a>Explain之热身Case</h5><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format19.png" alt="format19"></p>
<p>执行流程分析：</p>
<ol>
<li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为<code>&lt;derived3&gt;</code>，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【<code>select d1.name ...</code>】</li>
<li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【<code>select id, name from t1 where other_column= &#39; &#39;</code>】</li>
<li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【<code>select id from t3</code>】</li>
<li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【<code>select name, id from t2</code>】</li>
<li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1, 4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果进行uinion操作】</li>
</ol>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -优化 -Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Mysql性能差分析</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-Mysql%E6%80%A7%E8%83%BD%E5%B7%AE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>性能下降SQL慢，执行时间长，等待时间长，分析：</p>
<a id="more"></a>

<p>a.查询语句写的烂，</p>
<p>b.索引失效,</p>
<p>索引分为单值索引，复合索引</p>
<p>例子：</p>
<p>id name email weixinNumber</p>
<p>select * from user where name = “ “ and email = “ “</p>
<p>单值索引：</p>
<p>create index idx_user_name on user(name)</p>
<p>复合索引：</p>
<p>create index idx_user_nameEmail on user(name,email)</p>
<p>c.关联太多join(设计缺陷或不得已的需求)</p>
<p>d.服务器调优以及各个参数设置(缓存、线程数等)</p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-MySQL -索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Mysql索引分类</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-Mysql%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>索引的分类：</p>
<a id="more"></a>

<ol>
<li>普通索引：是最基本的索引，它没有任何限制，即一个索引只包含单个列，一个表可以有多个单列索引；建议一张表索引不要超过5个，优先考虑复合索引</li>
<li>唯一索引：与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一</li>
<li>主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：</li>
<li>复合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</li>
<li>全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配</li>
</ol>
<p>基本语法：</p>
<p> 创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：CREATE[unique] INDEX indexName ON mytable （columnname(length)）；</span><br><span class="line"></span><br><span class="line">方式二：ALTER mytable ADD [unique] index [indexName] ON （columnname(length)）;</span><br></pre></td></tr></table></figure>

<p>删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX[indexName] ON mytable;</span><br></pre></td></tr></table></figure>

<p>查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM table_name</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112144315965.png" alt="image-20201112144315965"></p>
<p><strong>使用 ALTER 命令，有四种方式来添加数据表的索引：</strong></p>
<ol>
<li><code>ALTER TABLE tbl_name ADD PRIMARY KEY(column_list)</code>：该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><code>ALTER TABLE tbl_name ADD UNIQUE index_name(column_list)</code>：这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><code>ALTER TABLE tbl_name ADD INDEX index_name(column_list)</code>：.添加普通索引，索引值可出现多次。</li>
<li><code>ALTER TABLE tbl_name ADD FULLTEXT index_name(column_list)</code>：该语句指定了索引为FULLTEXT，用于全文索引。</li>
</ol>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Mysql索引结构</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-Mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h4 id="1-Btree索引"><a href="#1-Btree索引" class="headerlink" title="1.Btree索引"></a>1.Btree索引</h4><p>【初始化介绍】</p>
<a id="more"></a>

<ol>
<li>一颗 b 树， 浅蓝色的块我们称之为一个磁盘块， 可以看到每个磁盘块包含几个数据项（深蓝色所示） 和指针（黄色所示），如磁盘块 1 包含数据项 17 和 35， 包含指针 P1、 P2、 P3</li>
<li>P1 表示小于 17 的磁盘块， P2 表示在 17 和 35 之间的磁盘块， P3 表示大于 35 的磁盘块</li>
<li>真实的数据存在于叶子节点和非叶子节点中，非叶子节点只不存储真实的数据，只存指引索引方向的数据项，如17、35并不真实存在于数据表中，</li>
</ol>
<p>【查找过程】</p>
<ol>
<li>如果要查找数据项 29， 那么首先会把磁盘块 1 由磁盘加载到内存， 此时发生一次 IO， 在内存中用二分查找确定 29在 17 和 35 之间， 锁定磁盘块 1 的 P2 指针， 内存时间因为非常短（相比磁盘的 IO） 可以忽略不计</li>
<li>通过磁盘块 1的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存， 发生第二次 IO， 29 在 26 和 30 之间， 锁定磁盘块 3 的 P2 指针</li>
<li>通过指针加载磁盘块 8 到内存， 发生第三次 IO， 同时内存中做二分查找找到 29， 结束查询， 总计三次 IO。</li>
<li>而真实的情况是，3层是B+树可以标识上百万的数据，如果上百万的数据查找只需要三次IO，这种性能的提升将是非常巨大，如果没有索引，每个数据都要发生一次IO，那么上百万次的IO，其效率和成本都难以估算。</li>
</ol>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format.png" alt="format"></p>
<h5 id="2-B-tree索引"><a href="#2-B-tree索引" class="headerlink" title="2.B+tree索引"></a>2.B+tree索引</h5><p>【B+Tree 与 BTree 的区别】</p>
<p>B-树的关键字（数据项）和记录是放在一起的； B+树的非叶子节点中只有关键字和指向下一个节点的索引， 记录只放在叶子节点中。</p>
<p>【B+Tree 与 BTree 的查找过程】</p>
<ol>
<li>在 B 树中， 越靠近根节点的记录查找时间越快， 只要找到关键字即可确定记录的存在； 而 B+ 树中每个记录的查找时间基本是一样的， 都需要从根节点走到叶子节点， 而且在叶子节点中还要再比较关键字。</li>
<li>从这个角度看 B 树的性能好像要比 B+ 树好， 而在实际应用中却是 B+ 树的性能要好些。 因为 B+ 树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比 B 树多， 树高比 B 树小， 这样带来的好处是减少磁盘访问次数。</li>
<li>尽管 B+ 树找到一个记录所需的比较次数要比 B 树多， 但是一次磁盘访问的时间相当于成百上千次内存比较的时间， 因此实际中B+ 树的性能可能还会好些， 而且 B+树的叶子节点使用指针连接在一起， 方便顺序遍历（范围搜索）， 这也是很多数据库和文件系统使用 B+树的缘故。</li>
</ol>
<p>【思考： 为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？】</p>
<ol>
<li><p>B+树的磁盘读写代价更低：B+树的内部结点并没有指向关键字具体信息的指针。 因此其内部结点相对 B 树更小。 如果把所有同一内部结点的关键字存放在同一盘块中， 那么盘块所能容纳的关键字数量也越多。 一次性读入内存中的需要查找的关键字也就越多。 相对来说 IO 读写次数也就降低了。</p>
</li>
<li><p>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点， 而只是叶子结点中关键字的索引。 所以任何关键字的查找必须走一条从根结点到叶子结点的路。 所有关键字查询的路径长度相同， 导致每一个数据的查询效率相当。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/format1.png" alt="format1"></p>
</li>
</ol>
<h5 id="3-哪些情况需要创建索引？"><a href="#3-哪些情况需要创建索引？" class="headerlink" title="3.哪些情况需要创建索引？"></a>3.哪些情况需要创建索引？</h5><ol>
<li><strong>主键自动建立唯一索引</strong></li>
<li><strong>频繁作为查询的条件的字段</strong>应该创建索引</li>
<li><strong>查询中与其他表关联的字段</strong>，外键关系建立索引</li>
<li><strong>频繁更新的字段</strong>不适合创建索引</li>
<li><strong>Where 条件里用不到的字段</strong>不创建索引</li>
<li>单间/组合索引的选择问题，Who？（在高并发下倾向创建组合索引）</li>
<li><strong>查询中排序的字段</strong>，排序字段若通过索引去访问将大大提高排序的速度</li>
<li><strong>查询中统计或者分组字段</strong></li>
</ol>
<h5 id="4-哪些情况不需要创建索引？"><a href="#4-哪些情况不需要创建索引？" class="headerlink" title="4.哪些情况不需要创建索引？"></a>4.哪些情况不需要创建索引？</h5><ol>
<li><strong>表记录太少</strong></li>
<li><strong>经常增删改的表</strong></li>
<li><strong>数据重复且分布平均的表字段</strong>，因此应该只为经常查询和经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li>
</ol>
<p><strong>案例分析：</strong></p>
<ol>
<li>假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。</li>
<li>索引的选择性是指索引列中不同值的数目与表中记录数的比。如果一个表中有2000条记录，表索引列有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。</li>
<li>一个索引的选择性越接近于1，这个索引的效率就越高。</li>
</ol>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Mysql配置文件</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-Mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>Docker中Mysql配置和普通配置稍有不同。</p>
<a id="more"></a>

<p>1.windows下的默认配置文件是my.ini，而linux下默认是/etc/my.cnf，我是因为是使用docker进行配置，所以是自己设置的路径，我的路径为/home/user/mysql/conf/my.cnf。</p>
<p>2.二进制日志log-bin代表主从复制，</p>
<p>3.错误日志log-error记录严重的警告和错误日志，默认为关闭的，</p>
<p>docker需要查看镜像日志可使用 docker logs xx命令， 如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs -f -t --since&#x3D;&quot;2019-08-09&quot; --tail&#x3D;50 mysql（容器名称，即NAMES）</span><br></pre></td></tr></table></figure>

<p>其中 -f 为查看实时日志， -t为时间 –since为从何时起</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112102005751.png" alt="image-20201112102005751"></p>
<p>4.关于系统的文件，也就是数据库的位置，为了方便观看，我使用Xftp来查看一下，具体的库情况，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112102341330.png" alt="image-20201112102341330"></p>
<p>5.有几个关键的文件，查看默认库mysql可以看到，frm文件中是用于存放表结构，myd文件是存放表数据，myi文件是存放表索引</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112102551749.png" alt="image-20201112102551749"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Sql语句的机读手写顺序</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-Sql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9C%BA%E8%AF%BB%E6%89%8B%E5%86%99%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>每个人都写过无数的sql语句，那你是否清晰的了解，它是如果运行的呢？机器的运行和编写sql语句有什么关系呢？</p>
<a id="more"></a>

<p>1.sql的执行顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">手写的顺序：</span><br><span class="line">SELECT DISTINCT</span><br><span class="line">         &lt;select_list&gt;</span><br><span class="line">FROM</span><br><span class="line">          &lt;left table&gt; &lt;join type&gt;</span><br><span class="line">          </span><br><span class="line">JOIN &lt;right_table&gt; ON &lt;join_codition&gt;</span><br><span class="line"></span><br><span class="line">WHERE</span><br><span class="line">          &lt;where_condition&gt;</span><br><span class="line">HAVING</span><br><span class="line">          &lt;having_condition&gt;</span><br><span class="line">ORDER BY</span><br><span class="line">          &lt;order_by_condition&gt;</span><br><span class="line">LIMIT      </span><br><span class="line">          &lt;limit number&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">机读的顺序：</span><br><span class="line">1 FROM &lt;left_table&gt;</span><br><span class="line"></span><br><span class="line">2 ON &lt;join_condition&gt;</span><br><span class="line"></span><br><span class="line">3 &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line"></span><br><span class="line">4 WHERE &lt;where_condition&gt;</span><br><span class="line"></span><br><span class="line">5 GROUP BY &lt;group by_list&gt;</span><br><span class="line"></span><br><span class="line">6 HAVING &lt;having_condition&gt;</span><br><span class="line"></span><br><span class="line">7 SELECT</span><br><span class="line"></span><br><span class="line">8 DISTINCT &lt;select_list&gt;</span><br><span class="line"></span><br><span class="line">9 ORDER BY &lt;order_by_condition&gt;</span><br><span class="line"></span><br><span class="line">10 LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112111928112.png" alt="image-20201112111928112"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -机读 -手写</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--Show Profile进行Sql分析及优化</title>
    <url>/2020/11/29/Mysql%E8%BF%9B%E9%98%B6-Show-Profile%E8%BF%9B%E8%A1%8CSql%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><strong>Show Profile的作用</strong></p>
<p>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量，</p>
<a id="more"></a>

<p>官网：<a href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p>
<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
<p>11.首先使用命令查看是否开启，OFF表示处于关闭状态，NO表示开启状态，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;profiling%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125095548068.png" alt="image-20201125095548068"></p>
<p>2.使用命令开始profiling，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set profiling&#x3D;on; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125095709137.png" alt="image-20201125095709137"></p>
<p>3.执行Sql进行测试，先查询普通sql，输入语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp;</span><br><span class="line">select * from tbl_emp e inner join tbl_dept d on e.deptId &#x3D; d.id;</span><br><span class="line">select * from tbl_emp e left join tbl_dept d on e.deptId &#x3D; d.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125095919371.png" alt="image-20201125095919371"></p>
<p>为了让执行时长变长便于观察，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp group by id limit 30000;</span><br><span class="line">select * from emp group by id limit 40000;</span><br><span class="line">select * from emp group by id limit 50000;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125100848551.png" alt="image-20201125100848551"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125101027572.png" alt="image-20201125101027572"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125100939970.png" alt="image-20201125100939970"></p>
<p>4.使用命令查看刚刚执行的Sql语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125104958313.png" alt="image-20201125104958313"></p>
<p>5.然后使用命令来通过Quert_Id来诊断Sql语句，如果有需要，还可以加需要查看的参数，这四个是主要的，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show profile cpu, block io for query SQL编号;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201125105216354.png" alt="image-20201125105216354"></p>
<p>参数介绍：</p>
<ol>
<li>ALL：显示所有的开销信息</li>
<li>BLOCK IO：显示块IO相关开销</li>
<li>CONTEXT SWITCHES：上下文切换相关开销</li>
<li>CPU：显示CPU相关开销信息</li>
<li>IPC：显示发送和接收相关开销信息</li>
<li>MEMORY：显示内存相关开销信息</li>
<li>PAGE FAULTS：显示页面错误相关开销信息</li>
<li>SOURCE：显示和Source_function，Source_file，Source_line相关的开销信息</li>
<li>SWAPS：显示交换次数相关开销的信息</li>
</ol>
<p>6.日常开发问题总结，如果profile诊断出现以下字段，则表示Sql存在问题，需要优化，</p>
<p>converting HEAP to MyISAM：查询结果太大，内存都不够用了往磁盘上搬了。</p>
<p>Creating tmp table：创建临时表，mysql 先将拷贝数据到临时表，然后用完再将临时表删除</p>
<p>Copying to tmp table on disk：把内存中临时表复制到磁盘，危险！！！</p>
<p>locked：锁表</p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -优化 -Show Profile</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--七种Join连表查询</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-%E4%B8%83%E7%A7%8DJoin%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/Image.png" alt="Image"></p>
<p>先给上这张经典的图片，在开发中，不可避免的会涉及到多张表的连查，join更是常常出现在我们的SQL语句中，那么七种Join到底有什么联系和区别呢？</p>
<a id="more"></a>

<p>1.建表，数据库就用我最开始测试的test数据库，执行use test切换数据库，然后执行建表语句生成数据库表，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;tbl_emp&#96;  (</span><br><span class="line">&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">&#96;name&#96; varchar(20)  DEFAULT NULL,</span><br><span class="line">&#96;deptId&#96; int(11) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (&#96;id&#96;) ,</span><br><span class="line">KEY &#96;fk_dept_id&#96;(&#96;deptId&#96;)</span><br><span class="line">)ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 1 CHARACTER SET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;tbl_dept&#96;  (</span><br><span class="line">&#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,&#96;deptName&#96; varchar(30) DEFAULT NULL,</span><br><span class="line">&#96;locAdd&#96; varchar(40) DEFAULT NULL,</span><br><span class="line"> PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 1 CHARACTER SET &#x3D; utf8;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112114236774.png" alt="image-20201112114236774"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112114301891.png" alt="image-20201112114301891"></p>
<p>2.插入测试数据，并查看表结构及数据是否正确，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;RD&#39;,11);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;HR&#39;,12);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;MK&#39;,13);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;MIS&#39;,14);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;FD&#39;,15);</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;z3&#39;,1);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;z4&#39;,1);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;z5&#39;,1);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;w5&#39;,2);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;w6&#39;,2);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;s7&#39;,3);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;s8&#39;,4);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;s9&#39;,51);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112114538686.png" alt="image-20201112114538686"></p>
<p>3.数据造好，然后开始一条条的测试join语句，</p>
<p><strong>内连接 innrt join</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp emp inner join tbl_dept dept on emp.deptId &#x3D; dept.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112132113826.png" alt="image-20201112132113826"></p>
<p>可以看到只有两者的共有部分；</p>
<p><strong>左连接 left join</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp emp left join tbl_dept dept on emp.deptId &#x3D; dept.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112132515944.png" alt="image-20201112132515944"></p>
<p>1-7数据没有变化，但是8号数据却是tbl_emp独有的数据，左表查出所有，右边补充，没有的补null；</p>
<p><strong>右连接 right join</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp emp right join tbl_dept dept on emp.deptId &#x3D; dept.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112133006185.png" alt="image-20201112133006185"></p>
<p>右表查出所有，左表有的就补充，没有的补null；</p>
<p><strong>emp独有（a表独有的数据）</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp emp left join tbl_dept dept on emp.deptId &#x3D; dept.id where dept.id is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112133619801.png" alt="image-20201112133619801"></p>
<p>**dept独有(b表独有的数据)**：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp emp right join tbl_dept dept on emp.deptId &#x3D; dept.id where emp.DeptId is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112133719237.png" alt="image-20201112133719237"></p>
<p><strong>全有 full join（已经不支持该语法，所以使用union联合来实现查所有的语法）</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp emp left join tbl_dept dept on emp.deptId &#x3D; dept.id</span><br><span class="line">union</span><br><span class="line">select * from tbl_emp emp right join tbl_dept dept on emp.deptId &#x3D; dept.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112134509325.png" alt="image-20201112134509325"></p>
<p>union是自带去重，所以1-7的数据都只有一条，8为emp独有，9为dept独有</p>
<p>**emp和dept各自的独有(a、b表各自独有的数据)**：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp emp left join tbl_dept dept on emp.deptId &#x3D; dept.id where dept.id is null</span><br><span class="line">union</span><br><span class="line">select * from tbl_emp emp right join tbl_dept dept on emp.deptId &#x3D; dept.id where emp.DeptId is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201112134842519.png" alt="image-20201112134842519"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -join</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--慢查询日志</title>
    <url>/2020/11/23/Mysql%E8%BF%9B%E9%98%B6-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<blockquote>
<h4 id="首先要知道什么是慢查询日志"><a href="#首先要知道什么是慢查询日志" class="headerlink" title="首先要知道什么是慢查询日志"></a>首先要知道什么是慢查询日志</h4></blockquote>
<ol>
<li><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来<strong>记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中。</p>
<a id="more"></a>
</li>
<li><p>long_query_time的默认值为10，意思是运行10秒以上的SQL语句会被记录下来</p>
</li>
<li><p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p>
</li>
</ol>
<blockquote>
<h4 id="慢查询如何操作"><a href="#慢查询如何操作" class="headerlink" title="慢查询如何操作"></a>慢查询如何操作</h4></blockquote>
<ol>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。</li>
<li>当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</li>
</ol>
<p><strong>查看是否开启及如何开启</strong></p>
<ul>
<li><p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的</p>
</li>
<li><p>可以通过设置<strong>slow_query_log</strong>的值来开启</p>
</li>
<li><p>通过命令查看 mysql 的慢查询日志是否开启，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123153420862.png" alt="image-20201123153420862"></p>
</li>
<li><p>通过命令来开启慢查询日志，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123153746759.png" alt="image-20201123153746759"></p>
</li>
<li><p>可以通过设置配置文件，让慢查询日志永久生效，进入my.cnf文件，在mysqld下增加两行参数，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D;1   &#x2F;&#x2F;设置开启</span><br><span class="line">slow_query_log_file&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;ffb64f81b5c7-slow.log   &#x2F;&#x2F;如果不设置则系统会自动生成</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<h5 id="long-query-time参数"><a href="#long-query-time参数" class="headerlink" title="long_query_time参数"></a>long_query_time参数</h5></blockquote>
<p>1.查看数据库的long_query_time值，一般来说初始默认是10秒，意思超过10秒的SQL就抓取出来，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123154447027.png" alt="image-20201123154447027"></p>
<p>2.设置或my.cnf中永久修改默认时间，这里先设置为3秒，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global long_query_time&#x3D;3;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123154740307.png" alt="image-20201123154740307"></p>
<p>3.在上一步中可以看到，明明设置成功了，但是查询默认时间还是10秒，这是因为需要重新连接或新开一个，或者使用下面命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global variables like&#39;long_query_time&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123154952873.png" alt="image-20201123154952873"></p>
<p>4.进行一个超过3秒的sql测试，使用sleep字段，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select sleep(4); </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123155508274.png" alt="image-20201123155508274"></p>
<p>5.另外打开一个会话，进入刚刚设置或展示的目录，使用cat命令查看，可以看到刚刚查到语句，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123160416217.png" alt="image-20201123160416217"></p>
<p>6.可以查看当前系统中慢查询的条数，其实慢查询出现的语句都是有问题的语句，这个命令可以当作检测当前系统Sql运行情况的语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show global status like &#39;%Slow_queries%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123160632137.png" alt="image-20201123160632137"></p>
<blockquote>
<h5 id="日志分析命令-mysqldumpslow"><a href="#日志分析命令-mysqldumpslow" class="headerlink" title="日志分析命令 mysqldumpslow"></a><strong>日志分析命令 mysqldumpslow</strong></h5></blockquote>
<p><strong>mysqldumpslow是什么？</strong></p>
<p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具mysqldumpslow。</p>
<p>1.可以使用命令查看一下mysqldumpslow的作用，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123161029857.png" alt="image-20201123161029857"></p>
<p><strong>参数详解：</strong></p>
<p><strong>mysqldumpshow 参数解释</strong></p>
<ol>
<li>s：是表示按何种方式排序</li>
<li>c：访问次数</li>
<li>l：锁定时间</li>
<li>r：返回记录</li>
<li>t：查询时间</li>
<li>al：平均锁定时间</li>
<li>ar：平均返回记录数</li>
<li>at：平均查询时间</li>
<li>t：即为返回前面多少条的数据</li>
<li>g：后边搭配一个正则匹配模式，大小写不敏感的</li>
</ol>
<p>2.得到范围记录集最多的10条SQL，注意由于我本身就在mysql路径下，所以直接写的log的文件名，其他位置需要加上路径，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 ffb64f81b5c7-slow.log</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123161317000.png" alt="image-20201123161317000"></p>
<p>3.得到访问次数最多的10条SQL，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s c -t 10 ffb64f81b5c7-slow.log</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123161625146.png" alt="image-20201123161625146"></p>
<p>4.得到按照时间排序的前10条里面含有左连接的查询语句,没有返回表示没有，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; ffb64f81b5c7-slow.log</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123161642567.png" alt="image-20201123161642567"></p>
<p>5.另外建议在使用这些命令时结合 | 和more使用，否则有可能出现爆屏情况,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s r -t 10 ffb64f81b5c7-slow.log|more</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123161711236.png" alt="image-20201123161711236"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -慢查询 -Mysqldumpslow</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--全局查询日志</title>
    <url>/2020/11/29/Mysql%E8%BF%9B%E9%98%B6-%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>首先需要记住的是<strong>永远不要在生产环境开启这个功能，</strong>一般都是测试环境开启监测。</p>
<a id="more"></a>

<p>1.使用命令设置开启全局日志查询，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global general_log&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>2.设置日志输出，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global log_output&#x3D;&#39;TABLE&#39;;</span><br></pre></td></tr></table></figure>

<p>3.这个时候，所有编写的Sql语句，都会记录到Mysql库中的gengeral_log表，然后可以使用命令查看，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from mysql.general_log;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201126103044684.png" alt="image-20201126103044684"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -全局日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--批量新增数据脚本</title>
    <url>/2020/11/24/Mysql%E8%BF%9B%E9%98%B6-%E6%89%B9%E9%87%8F%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>编写存储过程应该很多了吧，我记得我面试的时候都问过我有没有写过存储过程，其实存储过程就是函数，就和Mysql中的now()类似，只不过now是Mysql系统为我们提供的，而我们是需要自己写，</p>
<a id="more"></a>

<p>1.新建一个dept表和emp表，用于测试，执行SQL语句直接创建，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept</span><br><span class="line">(</span><br><span class="line">    deptno int unsigned primary key auto_increment,</span><br><span class="line">    dname varchar(20) not null default &quot;&quot;,</span><br><span class="line">    loc varchar(8) not null default &quot;&quot;</span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp</span><br><span class="line">(</span><br><span class="line">    id int unsigned primary key auto_increment,</span><br><span class="line">    empno mediumint unsigned not null default 0,</span><br><span class="line">    ename varchar(20) not null default &quot;&quot;,</span><br><span class="line">    job varchar(9) not null default &quot;&quot;,</span><br><span class="line">    mgr mediumint unsigned not null default 0,</span><br><span class="line">    hiredate date not null,</span><br><span class="line">    sal decimal(7,2) not null,</span><br><span class="line">    comm decimal(7,2) not null,</span><br><span class="line">    deptno mediumint unsigned not null default 0</span><br><span class="line">)ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124163004273.png" alt="image-20201124163004273"></p>
<p>2.设置参数，</p>
<p>创建函数，假如报错：This function has none of DETERMINISTIC………</p>
<p>由于开启过慢查询日志，因为我们开启了bin-log，我们就必须为我们的function指定一个参数。它控制是否可以信任存储函数创建者，不会创建写入二进制日志引起不安全事件的存储函数。默认为0即关闭，</p>
<p>首先使用命令查看一下参数情况，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;log_bin_trust_function_creators&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124163438238.png" alt="image-20201124163438238"></p>
<p>3.使用后命令修改参数，执行命令，通过图片能看到已经变为了NO，表示开启，如果需要永久生效，需要在配置文件中配置log_bin_trust_function_creators=1即可，但是实际一般都不需要，就像慢查询一样，平时也不会插入过多数据，有需要的时候开启一下就行，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global log_bin_trust_function_creators&#x3D;1;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124163635478.png" alt="image-20201124163635478"></p>
<p>4.创建函数，用于保证每条数据都不同，rand_string是自己定义的，declare是定义字段，执行语句，注意，执行后，语句结束需要用两个$$符号，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $$ # 两个 $$ 表示结束</span><br><span class="line">create function rand_string(n int) returns varchar(255)</span><br><span class="line">begin</span><br><span class="line">    declare chars_str varchar(100) default &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;</span><br><span class="line">    declare return_str varchar(255) default &#39;&#39;;</span><br><span class="line">    declare i int default 0;</span><br><span class="line">    while i &lt; n do</span><br><span class="line">        set return_str &#x3D; concat(return_str,substring(chars_str,floor(1+rand()*52),1));</span><br><span class="line">        set i&#x3D;i+1;</span><br><span class="line">    end while;</span><br><span class="line">    return return_str;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124164635014.png" alt="image-20201124164635014"></p>
<p>5.再创建一个随机产生部门编号的函数，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create function rand_num() returns int(5)</span><br><span class="line">begin</span><br><span class="line">    declare i int default 0;</span><br><span class="line">    set i&#x3D;floor(100+rand()*10);</span><br><span class="line">    return i;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124164825080.png" alt="image-20201124164825080"></p>
<p>6.创建存储过程，创建往emp表中插入数据的存储过程，rand_string和rand_num都是刚刚写的函数，set autocommit = 0代表取消自动提交，避免插入一条执行一次，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure insert_emp(in start int(10),in max_num int(10))</span><br><span class="line">begin</span><br><span class="line">    declare i int default 0;</span><br><span class="line">    set autocommit &#x3D; 0;</span><br><span class="line">    repeat</span><br><span class="line">        set i &#x3D; i+1;</span><br><span class="line">        insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),rand_string(6),&#39;salesman&#39;,0001,curdate(),2000,400,rand_num());</span><br><span class="line">        until i&#x3D;max_num</span><br><span class="line">        end repeat;</span><br><span class="line">    commit;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124165234592.png" alt="image-20201124165234592"></p>
<p>7.创建存储过程，创建往dept表中插入数据的存储过程，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure insert_dept(in start int(10),in max_num int(10))</span><br><span class="line">begin</span><br><span class="line">    declare i int default 0;</span><br><span class="line">    set autocommit &#x3D; 0;</span><br><span class="line">    repeat</span><br><span class="line">        set i &#x3D; i+1;</span><br><span class="line">        insert into dept(deptno,dname,loc) values((start+i),rand_string(10),rand_string(8));</span><br><span class="line">        until i&#x3D;max_num</span><br><span class="line">        end repeat;</span><br><span class="line">    commit;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124165356062.png" alt="image-20201124165356062"></p>
<p>8.调用存储过程，这里将结尾符号调整为原来的分号，CALL insert_dept(100,10)代表条用刚刚写的函数，从100开始，插入10条数据，语句内容就是刚刚设置的rand_string来随机生成，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER ;</span><br><span class="line">CALL insert_dept(100, 10);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124165705491.png" alt="image-20201124165705491"></p>
<p>9.十条数据几乎0s就完成了，这里再尝试一下五十万条数据，用了大概25s左右，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELIMITER ;</span><br><span class="line">CALL insert_emp(100001, 500000);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124170605143.png" alt="image-20201124170605143"></p>
<p>再查看一下，最后几条语句是否正确，执行语句，很抱歉，这命令行查询实在太久，我使用可视化工具直接查看了，可以看到每页一千条，共五百页，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from emp;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124171013156.png" alt="image-20201124171013156"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124170850141.png" alt="image-20201124170850141"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -存储过程 -函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--索引两表优化</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E4%B8%A4%E8%A1%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>单表优化已经完成，这里再进行两表优化，单表优化有所困惑的请参看上一篇文章:</p>
<a id="more"></a>

<p><a href="../Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E5%8D%95%E8%A1%A8%E4%BC%98%E5%8C%96/index.html">Mysql进阶-索引单表优化</a></p>
<p>1.为了展示两张表的索引优化，再创建一张class表和book表，并插入部分数据，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS class(</span><br><span class="line">    id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE IF NOT EXISTS book(</span><br><span class="line">    bookid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    PRIMARY KEY(bookid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO class(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line"></span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO book(card) VALUES(FLOOR(1+(RAND()*20)));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113133541475.png" alt="image-20201113133541475"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113133557936.png" alt="image-20201113133557936"></p>
<p>2.两张表数据已经没问题，业务需求：连表查询，条件为class.card = book.card，左表class表是驱动表，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM class LEFT JOIN book ON class.card &#x3D; book.card;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113133907035.png" alt="image-20201113133907035"></p>
<p>3.照例对语句进行Explain分析，不错所料，type为ALL，也就是查询了每一条数据，rows为表中数据总行数，说明class和book进行了全表检索，也就是说，每一次class表对book表进行左外连接的时候，都会在book表中进行一次全表检索，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Explain SELECT * FROM class LEFT JOIN book ON class.card &#x3D; book.card;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113134329715.png" alt="image-20201113134329715"></p>
<p>4.给book表的card字段添加索引优化，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113135110795.png" alt="image-20201113135110795"></p>
<p>5.再使用Explain分析，book表的type变为了ref</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113135151469.png" alt="image-20201113135151469"></p>
<p>6.再试试加class表，同样加card字段，先删除开始的book表的索引，再新建class表索引，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index Y on book;</span><br><span class="line">ALTER TABLE class ADD INDEX X(card);</span><br></pre></td></tr></table></figure>

<p>7.再次分析，注意，这次是class表的索引，查看两种情况，对sql执行的影响，可以看到class表的type变为index，并且rows也再一次达到了20+21=41，也就是两表都进行了全表检索，</p>
<p>注意两种情况，class表左连接book表，</p>
<p>当card索引加在book右表，type为ref；</p>
<p>当card索引加在class左表，type为index，别忘记了type好坏的比较：<code>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</code>，</p>
<p>分析其原因：</p>
<ul>
<li>这是由左连接特性决定的。LEFT JOIN条件用于确定如何从右表搜索行，左边一定都有，所以右边是我们的关键点，一定需要在右表建立索引。</li>
<li><strong>左表连接右表，则需要拿着左表的数据去右表里面查，索引需要在右表中建立索引</strong></li>
</ul>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113140155923.png" alt="image-20201113140155923"></p>
<p>在这种情况下，也许索引就很不适合，但是DBA表示这索引也是为其他地方服务，不能修改删除，那么就可以试试右连接，可以看到class表变为了ref，并且rows总数也变为了21，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Explain SELECT * FROM class right JOIN book ON class.card &#x3D; book.card;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113141636914.png" alt="image-20201113141636914"></p>
<p>分析其原因：</p>
<ul>
<li>这是因为RIGHT JOIN条件用于确定如何从左表搜索行，右边一定都有，所以左边是我们的关键点，一定需要建立索引。</li>
<li>class RIGHT JOIN book ：book 里面的数据一定存在于结果集中，我们需要拿着 book 表中的数据，去 class 表中搜索，所以索引需要建立在 class 表中</li>
</ul>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -优化 -Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--查询截取优化</title>
    <url>/2020/11/23/Mysql%E8%BF%9B%E9%98%B6-%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="SQL分析性能步骤："><a href="#SQL分析性能步骤：" class="headerlink" title="SQL分析性能步骤："></a>SQL分析性能步骤：</h4><p>1.观察，至少跑一天，观察生产的慢SQL情况</p>
<p>2.开启慢查询日志，设置阈值，比如超过5秒的就是慢SQL，并将其抓取出来</p>
<a id="more"></a>

<p>3.explain+慢SQL分析</p>
<p>4.show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况</p>
<p>5.SQL数据库服务器的参数调优</p>
<h4 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略;"></a>优化策略;</h4><blockquote>
<h5 id="保证小表驱动大表，类似嵌套Nested-Loop"><a href="#保证小表驱动大表，类似嵌套Nested-Loop" class="headerlink" title="保证小表驱动大表，类似嵌套Nested Loop"></a>保证小表驱动大表，类似嵌套Nested Loop</h5></blockquote>
<ol>
<li><p>EXISTS 语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM table WHERE EXISTS(subquery)</span><br><span class="line"></span><br><span class="line">该语法可以理解为：将查询的数据，放到子查询中做条件验证，根据验证结果（TRUE或FALSE）来决定主查询的数据结果是否得以保留。</span><br></pre></td></tr></table></figure>
</li>
<li><p>EXISTS(subquery) 只返回TRUE或FALSE，因此子查询中的<code>SELECT *</code>也可以是<code>SELECT 1</code>或其他，官方说法是实际执行时会忽略SELECT清单，因此没有区别</p>
</li>
<li><p>EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比，如果担忧效率问题，可进行实际检验以确定是否有效率问题。</p>
</li>
<li><p>EXISTS子查询往往也可以用条件表达式、其他子查询或者JOIN来替代，何种最优需要具体问题具体分析</p>
</li>
</ol>
<h6 id="in-和-exists-的用法"><a href="#in-和-exists-的用法" class="headerlink" title="in 和 exists 的用法"></a><strong>in 和 exists 的用法</strong></h6><p>1.首先选择数据库，然后查询两张表数据，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use test;</span><br><span class="line">select * from tbl_emp;</span><br><span class="line">select * from tbl_dept;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123142124694.png" alt="image-20201123142124694"></p>
<p>2.in的语法，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp e where e.deptId in (select id from tbl_dept);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123142234703.png" alt="image-20201123142234703"></p>
<p>3.exists语法，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tbl_emp e where exists (select 1 from tbl_dept d where e.deptId &#x3D; d.id);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123142347512.png" alt="image-20201123142347512"></p>
<h6 id="结论："><a href="#结论：" class="headerlink" title="结论："></a><strong>结论：</strong></h6><ol>
<li>保证小表驱动大表</li>
<li>当 B 表数据集小于 A 表数据集时，使用 in</li>
<li>当 A 表数据集小于 B 表数据集时，使用 exist</li>
</ol>
<blockquote>
<h5 id="ORDER-BY关键字优化，ORDER-BY子句，尽量使用Index方式排序，避免使用FileSort方式排序"><a href="#ORDER-BY关键字优化，ORDER-BY子句，尽量使用Index方式排序，避免使用FileSort方式排序" class="headerlink" title="ORDER BY关键字优化，ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序"></a>ORDER BY关键字优化，<strong>ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序</strong></h5></blockquote>
<p>首先说明filesort和index的区别，为什么要避免filesort？</p>
<p>其实在Explain中的extra字段中就解释了，Using filesort是说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，效率很低，这种SQL情况都很不好，一般都需要优化，</p>
<p>而Index效率很高，是指MySQL扫描索引本身完成排序，效率很高，</p>
<p>1.建一张表用于测试，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table tblA(</span><br><span class="line">    #id int primary key not null auto_increment,</span><br><span class="line">    age int,</span><br><span class="line">    birth timestamp not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into tblA(age, birth) values(22, now());</span><br><span class="line">insert into tblA(age, birth) values(23, now());</span><br><span class="line">insert into tblA(age, birth) values(24, now());</span><br><span class="line"></span><br><span class="line">create index idx_A_ageBirth on tblA(age, birth);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123142703085.png" alt="image-20201123142703085"></p>
<p>2.查看一下表中数据，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tblA;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123142828134.png" alt="image-20201123142828134"></p>
<p>3.查看表中的索引，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from tblA;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123143040739.png" alt="image-20201123143040739"></p>
<p>4.随便测试一个语句，来观察order by会不会导致出现filesort，也就是文件排序，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tblA where age&gt;20 order by age;</span><br><span class="line"></span><br><span class="line">type&#x3D;index，毫无疑问，索引生效了</span><br><span class="line">key &#x3D; idx_A_ageBirth，表明索引生效</span><br><span class="line">ref &#x3D; null，说明ref没有索引常量生效，还可以看出extra中没有出现filesort，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123143311257.png" alt="image-20201123143311257"></p>
<p>那再试试对age和birth同时排序，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tblA where age&gt;20 order by age,birth;</span><br><span class="line"></span><br><span class="line">结果和上方一样，这没有出现filesort，而这里是按照索引顺序进行排序的，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123144229919.png" alt="image-20201123144229919"></p>
<p>再使用birth作为where条件，使用order by进行排序，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tblA where birth&gt;&#39;2016-01-28 00:00:00&#39; order by birth;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM tblA where birth&gt;&#39;2016-01-28 00:00:00&#39; order by age;</span><br><span class="line"></span><br><span class="line">可以看到，使用birth进行排序时，出现了filesort，继续测试，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123145219556.png" alt="image-20201123145219556"></p>
<p>5.单独对birth进行排序，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tblA where age&gt;20 order by birth;</span><br><span class="line"></span><br><span class="line">type&#x3D;index，毫无疑问，索引生效了</span><br><span class="line">key &#x3D; idx_A_ageBirth，表明索引生效</span><br><span class="line">ref &#x3D; null，说明ref没有索引常量生效，而不同的是extra中出现了filesort，这里和上面唯一的区别就是，带头大哥age没了，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123144004855.png" alt="image-20201123144004855"></p>
<p>那再试试使用birth，age进行排序，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tblA where age&gt;20 order by birth,age;</span><br><span class="line"></span><br><span class="line">可以看到，同样出现了filesort，这里能够得出，能使用索引进行排序的要遵守最佳左前缀法则，也就是带头大哥不死，中间不断，否则就会导致出现filesort，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123144620984.png" alt="image-20201123144620984"></p>
<p>6.已经得出了影响order by的原因，那再看一下我们常用的倒序和正序，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tblA ORDER BY age ASC, birth ASC;</span><br><span class="line">EXPLAIN SELECT * FROM tblA ORDER BY age DESC, birth DESC;</span><br><span class="line"></span><br><span class="line">毫无疑问，都没有问题，也没有出现filesort，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123145555580.png" alt="image-20201123145555580"></p>
<p><strong>结论：</strong></p>
<ol>
<li>MySQL支持二种方式的排序，FileSort和Index，<strong>Index效率高，它指MySQL扫描索引本身完成排序</strong>，FileSort方式效率较低。</li>
<li>ORDER BY满足两情况（最佳左前缀原则），会使用Index方式排序<ul>
<li>ORDER BY语句使用索引最左前列</li>
<li>使用where子句与OrderBy子句条件列组合满足索引最左前列</li>
</ul>
</li>
<li>尽可能在索引列上完成排序操作，遵照索引建的<strong>最佳左前缀</strong></li>
</ol>
<blockquote>
<h5 id="如果未在索引列上完成排序，mysql-会启动-filesort-的两种算法：双路排序和单路排序"><a href="#如果未在索引列上完成排序，mysql-会启动-filesort-的两种算法：双路排序和单路排序" class="headerlink" title="如果未在索引列上完成排序，mysql 会启动 filesort 的两种算法：双路排序和单路排序"></a><strong>如果未在索引列上完成排序，mysql 会启动 filesort 的两种算法：双路排序和单路排序</strong></h5></blockquote>
<ol>
<li>双路排序<ul>
<li>MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。读取行指针和将要进行order by操作的列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输</li>
<li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</li>
</ul>
</li>
<li>单路排序<ul>
<li>取一批数据，要对磁盘进行两次扫描，众所周知，I/O是很耗时的，所以在mysql4.1之后，出现了改进的算法，就是单路排序。</li>
<li>从磁盘读取查询需要的所有列，按照将要进行orderby的列，在sort buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li>
</ul>
</li>
<li>结论及引申出的问题：<ul>
<li>由于单路是改进的算法，总体而言好过双路</li>
<li>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排…… 从而会导致多次I/O。</li>
<li>结论：本来想省一次I/O操作，反而导致了大量的/O操作，反而得不偿失。</li>
</ul>
</li>
<li>更深层次的优化策略：<ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_length_for_sort_data参数的设置</li>
</ul>
</li>
</ol>
<p><strong>遵循如下规则，可提高Order By的速度</strong></p>
<ol>
<li>Order by时select *是一个大忌，只Query需要的字段，这点非常重要。在这里的影响是：<ul>
<li>当Query的字段大小总和小于max_length_for_sort_data，而且排序字段不是TEXT|BLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。</li>
<li>两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size。</li>
</ul>
</li>
<li>尝试提高 sort_buffer_size不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的</li>
<li>尝试提高max_length_for_sort_data提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率。</li>
</ol>
<blockquote>
<h5 id="group-by-关键字优化"><a href="#group-by-关键字优化" class="headerlink" title="group by 关键字优化"></a>group by 关键字优化</h5></blockquote>
<ol>
<li>group by实质是<strong>先排序后进行分组，遵照索引的最佳左前缀</strong></li>
<li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了</li>
<li>其余的规则均和 order by 一致</li>
</ol>
<p><strong>总结：</strong></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/24fcdacdf4ec65c0307f64c5dc59f904.png" alt="24fcdacdf4ec65c0307f64c5dc59f904"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -Exists -Explain -In</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--索引三表优化</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E4%B8%89%E8%A1%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>单表和量表的优化已经完成，这里再进行三表的优化，前面单表和两表优化有不懂的请参看：</p>
<a id="more"></a>

<p><a href="../Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E5%8D%95%E8%A1%A8%E4%BC%98%E5%8C%96/index.html">Mysql进阶-索引单表优化</a></p>
<p><a href="../Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E4%B8%A4%E8%A1%A8%E4%BC%98%E5%8C%96/index.html">Mysql进阶-索引两表优化</a></p>
<p>1.首先删除class的card索引，再查看两张表的索引情况，保证没有索引，为三表索引测试做准备，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index X on class;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113141223745.png" alt="image-20201113141223745"></p>
<p>2.再建一张phone表，并插入部分数据，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS phone(</span><br><span class="line">    phoneid INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,</span><br><span class="line">    card INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    PRIMARY KEY(phoneid)</span><br><span class="line">)ENGINE&#x3D;INNODB;</span><br><span class="line"></span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br><span class="line">INSERT INTO phone(card) VALUES(FLOOR(1+(RAND()*20)));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113144239640.png" alt="image-20201113144239640"></p>
<p>3.首先三表连查，查询条件为class.card = book.card和book.card = phone.card，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM class LEFT JOIN book ON class.card &#x3D; book.card LEFT JOIN phone ON book.card &#x3D; phone.card;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113144534808.png" alt="image-20201113144534808"></p>
<p>4.还是先对Sql进行一下性能分析查看，拉满，三张表全部全表检索，这还是数据量小，如果百万数据，，，</p>
<p>分析其原因：</p>
<ul>
<li>type 为All ，rows 为表数据总行数，说明 class、 book 和 phone 表都进行了全表检索</li>
<li>Extra 中 Using join buffer ，表明连接过程中使用了 join 缓冲区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Explain SELECT * FROM class LEFT JOIN book ON class.card &#x3D; book.card LEFT JOIN phone ON book.card &#x3D; phone.card;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113145023055.png" alt="image-20201113145023055"></p>
<p>5.建立索引，因为class表为驱动表，所以给book表和phone表分别建立card字段的索引，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE book ADD INDEX Y (card);</span><br><span class="line">ALTER TABLE phone ADD INDEX Z (card);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113145428911.png" alt="image-20201113145428911"></p>
<p>6.再来性能分析，可以看到，book表和phone表的type都变为了ref，而rows也变为了21+1+1，Extra也没有了Using join buffer，ref可以看到两个索引字段，优化效果良好，因此索引最好设置在需要经常查询的字段中，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113145534493.png" alt="image-20201113145534493"></p>
<p>总结，Join语句的优化：</p>
<p><strong>将 left join 看作是两层嵌套 for 循环</strong></p>
<ol>
<li>尽可能减少Join语句中的NestedLoop的循环总次数；“<strong>永远用小结果集驱动大的结果集</strong>”（在大结果集中建立索引，在小结果集中遍历全表）；</li>
<li>优先优化NestedLoop的内层循环；(相当于外层 for 循环的次数少，内层 for 循环的次数多)</li>
<li>保证Join语句中被驱动表上Join条件字段已经被索引；</li>
<li>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置；</li>
</ol>
<p>综上所述，使用小表驱动大表，在大表中建立了索引</p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -优化 -Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--索引优化梳理总结</title>
    <url>/2020/11/23/Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%A2%B3%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>到目前为止，已经了解了索引的原理，分类，结构，失效准则等等，我觉得有必要对其进行一系列的测试和总结，</p>
<a id="more"></a>

<p>1.新建表，并插入部分数据，创建索引，执行命令，然后查看表中数据是否正确，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test03(</span><br><span class="line">    id int primary key not null auto_increment,</span><br><span class="line">    c1 char(10),</span><br><span class="line">    c2 char(10),</span><br><span class="line">    c3 char(10),</span><br><span class="line">    c4 char(10),</span><br><span class="line">    c5 char(10)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values (&#39;a1&#39;,&#39;a2&#39;,&#39;a3&#39;,&#39;a4&#39;,&#39;a5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values (&#39;b1&#39;,&#39;b2&#39;,&#39;b3&#39;,&#39;b4&#39;,&#39;b5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values (&#39;c1&#39;,&#39;c2&#39;,&#39;c3&#39;,&#39;c4&#39;,&#39;c5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values (&#39;d1&#39;,&#39;d2&#39;,&#39;d3&#39;,&#39;d4&#39;,&#39;d5&#39;);</span><br><span class="line">insert into test03(c1,c2,c3,c4,c5) values (&#39;e1&#39;,&#39;e2&#39;,&#39;e3&#39;,&#39;e4&#39;,&#39;e5&#39;);</span><br><span class="line"></span><br><span class="line">create index idx_test03_c1234 on test03(c1,c2,c3,c4);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201116134535821.png" alt="image-20201116134535821"></p>
<p>2.查看test03表的索引，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from test03;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201116134725438.png" alt="image-20201116134725438"></p>
<p>3.问题：我们创建了复合索引idx_test03_c1234，根据一下Sql分析下索引使用情况？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全值匹配情况：</span><br><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; AND c3&#x3D;&#39;a3&#39; AND c4&#x3D;&#39;a4&#39;;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">ref&#x3D;const，const，const，const，表明了索引查询的四个常量，</span><br><span class="line">key_len的大小会跟随着索引的长度变化，索引长度越长数值越大，164表明四个索引都生效了。</span><br><span class="line">结论：优化全面生效，复合全值匹配情况</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201116135138233.png" alt="image-20201116135138233"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c4&#x3D;&#39;a4&#39; AND c3&#x3D;&#39;a3&#39; AND c2&#x3D;&#39;a2&#39; AND c1&#x3D;&#39;a1&#39;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; AND c4&#x3D;&#39;a4&#39; AND c3&#x3D;&#39;a3&#39;;</span><br><span class="line"></span><br><span class="line">对条件的顺序进行了调换，但是由于都是全值匹配，mysql 优化器进行了优化，所以我们的索引依然都生效了，但是最好按照索引顺序进行，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201116135819127.png" alt="image-20201116135819127"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; AND c3&gt;&#39;a3&#39; AND c4&#x3D;&#39;a4&#39;;</span><br><span class="line"></span><br><span class="line">对c3进行范围检索：</span><br><span class="line">type&#x3D;range，表明索引生效，但是范围检索后的索引全失效，</span><br><span class="line">key_len&#x3D;123表明只有三个索引常量生效，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201116140759673.png" alt="image-20201116140759673"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; AND c4&gt;&#39;a4&#39; AND c3&#x3D;&#39;a3&#39;;</span><br><span class="line">type&#x3D;range，表明索引生效，但是范围检索后的索引全失效，</span><br><span class="line">但是key_len&#x3D;164表明四个索引常量生效，这是因为mysql 优化器进行了优化，它还是会先调用全值匹配的c3，所以我们的索引都生效了，在 c4 时进行了范围搜索后失效，已经不影响索引了，所以长度是164，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201116141448388.png" alt="image-20201116141448388"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; AND c4&#x3D;&#39;a4&#39; ORDER BY c3;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;82表明只有两个索引常量生效，分别是c1和c2，因为根据索引失效准则中的最佳左匹配法则，c1c2c3c4中的c3失效，导致c4的索引失效，这里要注意，索引有两个作用，查找和排序，这里的c3是进行了排序而不是查找</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201116141908837.png" alt="image-20201116141908837"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; ORDER BY c3;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;82表明只有两个索引常量生效，分别是c1和c2，c3用于排序，和上面的区别是这里直接没有c4的条件，更别说索引，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122095122277.png" alt="image-20201122095122277"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; ORDER BY c4;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;82表明只有两个索引常量生效，分别是c1和c2，因为没有c3,c4的索引就失效了，再使用c4进行排序，就会导致了文件排序，出现filesort，代表了必须要进行优化了，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122095527877.png" alt="image-20201122095527877"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c5&#x3D;&#39;a5&#39; ORDER BY c2, c3;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;41，表明只有一个索引常量生效，代表c1的索引，而c2和c3的功能是排序，所以c2，c3并没有索引失效，无filesort出现，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122095901827.png" alt="image-20201122095901827"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c5&#x3D;&#39;a5&#39; ORDER BY c3，c2;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;41，表明只有一个索引常量生效，代表c1的索引，而c2和c3的功能是排序，但是竟然出现了filesort，这条语句和上一条唯一的区别就是c2和c3的位置调换，那会不会是c5的影响呢，先继续测试，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122100404497.png" alt="image-20201122100404497"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; ORDER BY c2, c3;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;82，表明只有两个个索引生效，代表c1和c2索引，没有出现filesort，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122100828511.png" alt="image-20201122100828511"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; AND c5&#x3D;&#39;a5&#39; ORDER BY c2, c3;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;82，表明只有两个索引常量生效，代表c1和c2索引，没有出现filesort，说明和c5是没有关系的，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122100942302.png" alt="image-20201122100942302"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c2&#x3D;&#39;a2&#39; AND c5&#x3D;&#39;a5&#39; ORDER BY c3, c2;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;82，表明只有两个索引常量生效，代表c1和c2索引，但是竟然没有出现filesort，刚刚已经证明了c5没有导致出现filesort，那么这里来写一下刚刚出现filesort的sql语句，看一下差别：</span><br><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c5&#x3D;&#39;a5&#39; ORDER BY c3，c2;</span><br><span class="line">可以看到，是多了一个c2&#x3D;&#39;a2&#39;，那肯定就是这句话的影响，这是因为c2是一个全值匹配，一个常量是不用也不能排序的，所以c2的排序失效了，所以只有c3的排序不会出现filesort，因为c3本来就存在于索引中，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122101144318.png" alt="image-20201122101144318"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c4&#x3D;&#39;a4&#39; GROUP BY c2,c3;</span><br><span class="line"></span><br><span class="line">这里遇到了一个错误问题：</span><br><span class="line">ONLY_FULL_GROUP_BY的意思是：对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中，也就是说查出来的列必须在group by后面出现，否则就会报错，或者这个字段出现在聚合函数里面。 </span><br><span class="line">然后输入命令关掉ONLY_FULL_GROUP_BY：</span><br><span class="line">set sql_mode&#x3D;&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#39;;</span><br><span class="line"></span><br><span class="line">再执行Sql语句，</span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;41，表明只有一个索引常量生效，而没有出现filesort，因为c1作为查询常量生效，c2和c3作为排序生效，既没有开头失效，也没有中途断掉，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122103057922.png" alt="image-20201122103057922"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM test03 WHERE c1&#x3D;&#39;a1&#39; AND c4&#x3D;&#39;a4&#39; GROUP BY c3, c2;</span><br><span class="line"></span><br><span class="line">type&#x3D;ref，表明索引生效，</span><br><span class="line">key_len&#x3D;41，表明只有一个索引常量生效，但是竟然同时出现了</span><br><span class="line">Using temporary(创建了临时表)和Using filesort(文件排序),可以说这句Sql情况十分危急了， 因为c2处于c3后面，导致索引中间断开，索引失效，出现了filesort，又因为group by的缘故，创建了临时表，</span><br><span class="line">group by 和 order by 在索引上的问题基本是一样的，但是</span><br><span class="line">order by是给个范围，group by基本上都需要进行排序，分组之前必排序，如果错乱，会有临时表的产生，</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201122103431494.png" alt="image-20201122103431494"></p>
<p>总结：</p>
<p>一般性建议：</p>
<p>A.对于单键索引，尽量选择针对当前query过滤性更好的索引;</p>
<p>B.在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠左越好;</p>
<p>C.在选择组合索引的时候，尽量选择可以能包含当前query中的where子句中更多字段的索引;</p>
<p>D.尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的;</p>
<p>便于记忆：</p>
<p>全值匹配我最爱， 最左前缀要遵守；</p>
<p>带头大哥不能死， 中间兄弟不能断；</p>
<p>索引列上少计算， 范围之后全失效；</p>
<p>LIKE 百分写最右， 覆盖索引不写 *；</p>
<p>不等空值还有 OR， 索引影响要注意；</p>
<p>VAR 引号不可丢， SQL 优化有诀窍。</p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -优化 -Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--索引单表优化</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E5%8D%95%E8%A1%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>对一张表进行索引的优化。</p>
<a id="more"></a>

<p>1.一张表的索引优化策略，先创建一张表并插入部分数据，，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS article(</span><br><span class="line">    id INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    author_id INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    category_id INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    views INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    comments INT(10) UNSIGNED NOT NULL,</span><br><span class="line">    title VARCHAR(255) NOT NULL,</span><br><span class="line">    content TEXT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO article(author_id,category_id,views,comments,title,content)</span><br><span class="line">VALUES</span><br><span class="line">(1,1,1,1,&#39;1&#39;,&#39;1&#39;),</span><br><span class="line">(2,2,2,2,&#39;2&#39;,&#39;2&#39;),</span><br><span class="line">(1,1,3,3,&#39;3&#39;,&#39;3&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113104907590.png" alt="image-20201113104907590"></p>
<p>2.业务需求：查询category_id为1且comments 大于1的情况下，views最多的article_id，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id,category_id from article where category_id &#x3D; 1 and comments &gt; 1 order by views limit 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113110103872.png" alt="image-20201113110103872"></p>
<p>3.语句没问题，然后查看一下索引，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from articel;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113105924870.png" alt="image-20201113105924870"></p>
<p>4.然后进行性能分析，使用Explain关键字，很明显，type是ALL，也就是查询了每一条数据，Extra里还出现了Using filesort，这可是九死一生的情况，数据量少还不明显，但是如果是百万级数据量，优化是势在必行，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113105637712.png" alt="image-20201113105637712"></p>
<p>5.开始优化，</p>
<p>新建索引(两种创建方式)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ALTER TABLE article ADD INDEX idx_article_ccv(&#39;category_id&#39;, &#39;comments&#39;, &#39;views&#39;); </span><br><span class="line">create index idx_article_ccv on article(category_id, comments, views);</span><br></pre></td></tr></table></figure>

<p>执行Sql语句后，再查看索引情况：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113110659535.png" alt="image-20201113110659535"></p>
<p>6.索引设置成功，再来进行性能分析情况，可以看到type变为了range，但是Extra还是Using where；Using filesort，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113110821446.png" alt="image-20201113110821446"></p>
<p>7.尝试修改Sql语句，尝试将comments &gt; 1 修改为 = 1，可以看到Using filesort消息了，这是什么导致的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Explain select id,category_id from article where category_id &#x3D; 1 and comments &#x3D; 1 order by views limit 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113111357485.png" alt="image-20201113111357485"></p>
<p>8.继续分析，两者最大的区别，就是&gt;是一种范围，而=是代表一种常量，这就是原因：</p>
<ul>
<li>这是因为按照B+Tree索引的工作原理，先排序 category_id，如果遇到相同的 category_id 则再排序comments，如果遇到相同的 comments 则再排序 views。</li>
<li>当comments字段在联合索引里处于中间位置时，<strong>因为<code>comments&gt;1</code>条件是一个范围值</strong>（所谓 range），MySQL 无法利用索引再对后面的views部分进行检索，即 <strong>range 类型查询字段后面的索引无效</strong>。</li>
</ul>
<p>9.删除刚刚创建的索引，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX idx_article_ccv ON article;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113112141285.png" alt="image-20201113112141285"></p>
<p>10.再分析查看 = 和 &gt;的性能分析，可以发现，两者都一样了，type都是ALL，Extra都是Using filesort，因为都没有使用索引了，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113112354965.png" alt="image-20201113112354965"></p>
<p>11.再次回到原题，既然是range 后（<code>comments &gt; 1</code>）导致了索引失效，那么是不是可以跳过comments，不创建comments的索引，创建新的索引，执行语句，可以和上面的索引进行对比，少了一个comments，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ALTER TABLE article ADD INDEX idx_article_ccv(&#39;category_id&#39;,  &#39;views&#39;); </span><br><span class="line">create index idx_article_ccv on article(category_id, views);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113113433308.png" alt="image-20201113113433308"></p>
<p>12.再新索引的基础上进行性能分析，可以看到type变为了ref，Extra也没有了Using filesort，结果很理想</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Explain select id,category_id from article where category_id &#x3D; 1 and comments &gt; 1 order by views limit 1;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113113621864.png" alt="image-20201113113621864"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -优化 -Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle分组过滤数据总结</title>
    <url>/2021/01/29/Oracle%E5%88%86%E7%BB%84%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>没怎么用过Oracle，以为差不多，这不就遇到一个坑，因为连表查询，表关系为一对多，要把连查出来的数据过滤为两条，也就是对b表数据进行分组或者说过滤吧，</p>
<a id="more"></a>

<p>1.首先尝试了group by，发现对单个字段是可以的，也就是select后面只能是单个字段，这个字段也是分组的字段，这样是有效的，否则无效；</p>
<p>2.尝试distinct，发现发现只能过滤某一个字段生效，多个无效，而一般实际开发情况，是整条数据都是需要的；</p>
<p>3.最后百度很久才找到关键字 row_number() OVER(PARTITION BY 使用子查询对重复数据按照123…排序，再条件需要为1的，直接仿照着写就好，需要使用聚合函数，就直接在外层的select后面写，替换掉查全部；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">            t.*</span><br><span class="line">        FROM</span><br><span class="line">            (SELECT row_number() over (partition BY tor.content ORDER BY tor.CREATE_TIME DESC)rn, tor.* FROM KH_APPRAISE_SCORE tor WHERE</span><br><span class="line">            tor.DEL_FLAG &#x3D; &#39;0&#39; AND tor.MASTER_ID &#x3D; #&#123;id&#125;) t</span><br><span class="line">        WHERE</span><br><span class="line">            t.rn &#x3D; 1</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>-oracle</category>
      </categories>
      <tags>
        <tag>-oracle -过滤</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet线程是否安全及原因</title>
    <url>/2021/01/06/Servlet%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8%E5%8F%8A%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<p>Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p>
<p>Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。</p>
<p>SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。</p>
<p>Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。</p>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动装配原理</title>
    <url>/2021/01/29/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>读了一下源码，找了一下自动装配的原因。</p>
<a id="more"></a>

<h4 id="1-SpringBoot项目使用主类启动，其核心注解是：-SpringApplication注解"><a href="#1-SpringBoot项目使用主类启动，其核心注解是：-SpringApplication注解" class="headerlink" title="1.SpringBoot项目使用主类启动，其核心注解是：@SpringApplication注解"></a>1.SpringBoot项目使用主类启动，其核心注解是：@SpringApplication注解</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129143511845.png" alt="image-20210129143511845"></p>
<h4 id="2-进入-SpringApplication注解，在这个注解里面，最主要的注解就是：-EnableAutoConfiguration，看名字就能看出这是进行自动装配的注解"><a href="#2-进入-SpringApplication注解，在这个注解里面，最主要的注解就是：-EnableAutoConfiguration，看名字就能看出这是进行自动装配的注解" class="headerlink" title="2.进入@SpringApplication注解，在这个注解里面，最主要的注解就是：@EnableAutoConfiguration，看名字就能看出这是进行自动装配的注解"></a>2.进入@SpringApplication注解，在这个注解里面，最主要的注解就是：@EnableAutoConfiguration，看名字就能看出这是进行自动装配的注解</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129143527902.png" alt="image-20210129143527902"></p>
<h4 id="3-进入-EnableAutoConfiguration注解，会发现这其实就是通过注解：-import注解来完成导入配置的功能"><a href="#3-进入-EnableAutoConfiguration注解，会发现这其实就是通过注解：-import注解来完成导入配置的功能" class="headerlink" title="3.进入@EnableAutoConfiguration注解，会发现这其实就是通过注解：@import注解来完成导入配置的功能"></a>3.进入@EnableAutoConfiguration注解，会发现这其实就是通过注解：@import注解来完成导入配置的功能</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129143545152.png" alt="image-20210129143545152"></p>
<h4 id="4-SpringFactoriesLoader-loadFactoryNames-核心方法读取-ClassPath-目录下面的-META-INF-spring-factories-文件。找到进入内部类AutoConfigurationImportSelector-class，SpringFactoriesLoader-loadFactoryNames-核心方法读取-ClassPath-目录下面的-META-INF-spring-factories-文件"><a href="#4-SpringFactoriesLoader-loadFactoryNames-核心方法读取-ClassPath-目录下面的-META-INF-spring-factories-文件。找到进入内部类AutoConfigurationImportSelector-class，SpringFactoriesLoader-loadFactoryNames-核心方法读取-ClassPath-目录下面的-META-INF-spring-factories-文件" class="headerlink" title="4. SpringFactoriesLoader.loadFactoryNames() 核心方法读取 ClassPath 目录下面的 META-INF/spring.factories 文件。找到进入内部类AutoConfigurationImportSelector.class，SpringFactoriesLoader.loadFactoryNames() 核心方法读取 ClassPath 目录下面的 META-INF/spring.factories 文件"></a>4. SpringFactoriesLoader.loadFactoryNames() 核心方法读取 ClassPath 目录下面的 META-INF/spring.factories 文件。找到进入内部类AutoConfigurationImportSelector.class，SpringFactoriesLoader.loadFactoryNames() 核心方法读取 ClassPath 目录下面的 META-INF/spring.factories 文件</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129143608859.png" alt="image-20210129143608859"></p>
<h4 id="5-spring-factories-文件中配置了SpringBoot自动配置类"><a href="#5-spring-factories-文件中配置了SpringBoot自动配置类" class="headerlink" title="5.spring.factories 文件中配置了SpringBoot自动配置类"></a>5.spring.factories 文件中配置了SpringBoot自动配置类</h4><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129143620491.png"></p>
<h4 id="6-总结："><a href="#6-总结：" class="headerlink" title="6.总结："></a>6.总结：</h4><p>进入@SpringApplication注解；   </p>
<p>找到@EnableAutoConfiguration注解，开启自动配置；   </p>
<p>进入注解@Import；   </p>
<p>找到SpringFactoriesLoader.loadFactoryNames() 核心方法；   </p>
<p>读取 ClassPath 目录下面的 META-INF/spring.factories 文件；   spring.factories 文件中装配了常见的自动配置</p>
]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>-自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot定时任务</title>
    <url>/2020/11/24/Springboot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>定时任务在实际开发中，可以说是应用特别的广泛，以往用的都是Timer对象，而现在用的更多的Scheduled类，那么两个有什么区别呢，这里将一一讲解一下，</p>
<a id="more"></a>

<p>1.先说一下Timer对象，它是位于util包下的一个类，并且timer对象是线程安全的，具备原子性，因为Timer内部先使用synchronized对queue队列进行加锁，再对里面的每一个task进行加锁，保证了安全，</p>
<p>2.新建一个测试，来感受一下,需要注意的是实例化Timer对象后，调用的是它的schedule方法，它的参数及其含义我都给予表明，而另一个关注的点就是它是多线程运行的，我使用main去调用test，而运行的却是单独的线程，可以在run方法内定义多个定时任务一起运行，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建timer对象,线程安全的，原子性的，先使用synchronized对queue队列进行加锁，再对里面的每一个task进行加锁</span></span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();<span class="comment">//一个timer对象在执行多个任务的时候执行的一个线程</span></span><br><span class="line">    <span class="comment">//执行定时任务</span></span><br><span class="line">    <span class="comment">//参数1：timerTask对象  定时任务对象</span></span><br><span class="line">    <span class="comment">//参数2：任务什么时候启动</span></span><br><span class="line">    <span class="comment">//参数3：执行任务的间隔时间</span></span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="comment">//定时任务</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;启动定时任务1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="keyword">new</span> Date(),<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//main方法在这里结束了，而定时任务是另一个线程，定时任务是多线程运行的</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程结束了&quot;</span>);</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;启动定时任务2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="keyword">new</span> Date(),<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124154535077.png" alt="image-20201124154535077"></p>
<p>3.Timer结束，那再看一下Scheduled，它是使用注解配置来实现的，跟随启动器启动而一起加载，它最大的好处就是它的功能更加强大，可以用来完成更多有细节要求的定时任务，下面先看一下@Scheduled注解的最主要的参数，</p>
<h3 id="Scheduled参数描述"><a href="#Scheduled参数描述" class="headerlink" title="@Scheduled参数描述"></a><strong>@Scheduled参数描述</strong></h3><ul>
<li><strong>@Scheduled(fixedRate=3000)*<em>：上一次**</em>开始执行时间*</strong>点后<strong>3秒</strong>再次执行；</li>
<li><strong>@Scheduled(fixedDelay=3000)*<em>：上一次**</em>执行完毕时间*</strong>点<strong>3秒</strong>再次执行；</li>
<li><strong>@Scheduled(initialDelay=1000, fixedDelay=3000)**：第一次延迟</strong>1秒<strong>执行，然后在上一次**<em>执行完毕时间</em></strong>点<strong>3秒</strong>再次执行；</li>
<li><strong>@Scheduled(cron=”* * * * * ?”)**：按</strong>cron**规则执行；</li>
</ul>
<p>cron参数的是接收一个cron表达式，cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124160001510.png" alt="image-20201124160001510"></p>
<h6 id="通配符说明-来源于sprinkle-liz"><a href="#通配符说明-来源于sprinkle-liz" class="headerlink" title="通配符说明(来源于sprinkle_liz):"></a>通配符说明(来源于<a href="https://www.jianshu.com/p/1defb0f22ed1" target="_blank"><a href="https://www.jianshu.com/u/c13f3c6ada04">sprinkle_liz</a></a>):</h6><ul>
<li><code>*</code> 表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。</li>
<li><code>?</code> 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?</li>
<li><code>-</code> 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。</li>
<li><code>,</code> 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li>
<li><code>/</code> 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在日字段上设置’1/3’所示每月1号开始，每隔三天触发一次。</li>
<li><code>L</code> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”</li>
<li><code>W</code> 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。</li>
<li><code>#</code> 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。</li>
</ul>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>每隔5秒执行一次：*/5 * * * * ?</p>
<p>每隔1分钟执行一次：0 */1 * * * ?</p>
<p>每天23点执行一次：0 0 23 * * ?</p>
<p>每天凌晨1点执行一次：0 0 1 * * ?</p>
<p>每月1号凌晨1点执行一次：0 0 1 1 * ?</p>
<p>每月最后一天23点执行一次：0 0 23 L * ?</p>
<p>每周星期六凌晨1点实行一次：0 0 1 ? * L</p>
<p>在26分、29分、33分执行一次：0 26,29,33 * * * ?</p>
<p>每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</p>
<p>4.编写一个配置文件，添加注解，由于记住cron表达式实在过于艰难，自然就有大佬为了方便编写了<a href="https://www.jianshu.com/p/1defb0f22ed1" target="_blank">在线cron表达式生成器</a>，强烈建议使用，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">//修饰范围：用在类上 作用：用来标识这个类是一个定时任务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒 分 时 天 月 周 ，* 表示该域中任意值 //Spring框架封装corn表达式</span></span><br><span class="line">    <span class="comment">//每小时的1-33分钟的每分钟的1-10秒执行任务</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;1-10 1-33 * * * ?&quot;)</span> <span class="comment">//修饰范围：用在方法上 作用：标识这个方法是一个定时任务</span></span><br><span class="line">    <span class="comment">//corn 作用：用来决定当前任务方法循环周期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;12-20 1-33 * * * ?&quot;)</span> <span class="comment">//修饰范围：用在方法上 作用：标识这个方法是一个定时任务</span></span><br><span class="line">    <span class="comment">//corn 作用：用来决定当前任务方法循环周期</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周不做限制，每年10月、11月的9号和25号的17时、18时、19时的第1分钟到第33分钟的第1秒到第10秒执行</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;10-20 1-33 17,18,19 9,25 10,11 ?&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;定时任务2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124161205842.png" alt="image-20201124161205842"></p>
<p><strong>总结：</strong></p>
<p>可以清晰的看到，task执行了10s的任务，再间隔2s后执行task3，这样的定时任务更加灵活，定时任务用的相对还是较少，主要现在更倾向于接收广播，接收到特定的消息后，然后再去执行操作，而不是通过定时任务来完成。</p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot整合Shiro</title>
    <url>/2021/01/29/SpringBoot%E6%95%B4%E5%90%88Shiro/</url>
    <content><![CDATA[<p>shiro是较为轻量的权限框架，学习使用一下，但是现在确实这个用的不多了，<strong>Spring Security</strong>确实更香。</p>
<a id="more"></a>

<h4 id="1-导入依赖"><a href="#1-导入依赖" class="headerlink" title="1.导入依赖"></a>1.导入依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--        Shiro整合Spring包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.5.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-配置shiro"><a href="#2-配置shiro" class="headerlink" title="2.配置shiro"></a>2.配置shiro</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.zl.shiro.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import at.pollux.thymeleaf.shiro.dialect.ShiroDialect;</span><br><span class="line">import org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line">import org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @author zhanglang</span><br><span class="line">* @Date 2020&#x2F;6&#x2F;30</span><br><span class="line">*&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class ShiroConfig &#123;</span><br><span class="line">    &#x2F;&#x2F;3.ShiroFilterFactoryBean</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(&quot;securityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager)&#123;</span><br><span class="line">        ShiroFilterFactoryBean bean &#x3D; new ShiroFilterFactoryBean();</span><br><span class="line">        &#x2F;&#x2F;设置安全管理器</span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 添加shiro的内置过滤器</span><br><span class="line">         * anon：无需认证就可以访问</span><br><span class="line">         * authc：必须认证才能访问</span><br><span class="line">         * user：必须拥有 记住我 这个功能才能用</span><br><span class="line">         * perms：拥有对某个资源的权限才能访问</span><br><span class="line">         * role：拥有某个角色权限才能访问</span><br><span class="line">         *</span><br><span class="line">         * &#x2F;&#x2F;        filterMap.put(&quot;&#x2F;user&#x2F;add&quot;,&quot;authc&quot;);</span><br><span class="line">         * &#x2F;&#x2F;        filterMap.put(&quot;&#x2F;user&#x2F;update&quot;,&quot;authc&quot;);</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;拦截</span><br><span class="line">        Map&lt;String,String&gt; filterMap&#x3D;new LinkedHashMap&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;设置请求权限</span><br><span class="line">&#x2F;&#x2F;        filterMap.put(&quot;&#x2F;user&#x2F;add&quot;,&quot;authc&quot;);</span><br><span class="line">&#x2F;&#x2F;        filterMap.put(&quot;&#x2F;user&#x2F;update&quot;,&quot;authc&quot;);</span><br><span class="line">        &#x2F;&#x2F;授权,正常的情况下，没有授权会跳转到未授权页面</span><br><span class="line">        filterMap.put(&quot;&#x2F;user&#x2F;add&quot;,&quot;perms[user:add]&quot;);</span><br><span class="line">        filterMap.put(&quot;&#x2F;user&#x2F;update&quot;,&quot;perms[user:update]&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置为user下所有请求的权限</span><br><span class="line">&#x2F;&#x2F;        filterMap.put(&quot;&#x2F;user&#x2F;*&quot;,&quot;authc&quot;);</span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line">        &#x2F;&#x2F;设置登录的请求</span><br><span class="line">        bean.setLoginUrl(&quot;&#x2F;toLogin&quot;);</span><br><span class="line">        &#x2F;&#x2F;设置未授权页面</span><br><span class="line">        bean.setUnauthorizedUrl(&quot;&#x2F;noauth&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.DefaultWebSecurityManager</span><br><span class="line">    @Bean(name &#x3D; &quot;securityManager&quot;)</span><br><span class="line">    public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(&quot;userRealm&quot;) UserRealm userRealm)&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager &#x3D; new DefaultWebSecurityManager();</span><br><span class="line">        &#x2F;&#x2F;关联UserRealm</span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.创建Realm,需要自定义类</span><br><span class="line">    @Bean</span><br><span class="line">    public UserRealm userRealm()&#123;</span><br><span class="line">        return new UserRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;整合ShiroDialect:用来整合shiro thymeleaf</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroDialect getShiroDialect()&#123;</span><br><span class="line">        return new ShiroDialect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-配置shiro的授权和认证"><a href="#3-配置shiro的授权和认证" class="headerlink" title="3.配置shiro的授权和认证"></a>3.配置shiro的授权和认证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.zl.shiro.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import cn.zl.shiro.pojo.User;</span><br><span class="line">import cn.zl.shiro.service.UserService;</span><br><span class="line">import jdk.nashorn.internal.parser.Token;</span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line">import org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class="line">import org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @author zhanglang</span><br><span class="line">* @Date 2020&#x2F;6&#x2F;30</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F;自定义的UserRealm</span><br><span class="line">public class UserRealm extends AuthorizingRealm &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line">    &#x2F;&#x2F;授权</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">        System.out.println(&quot;执行了&#x3D;&gt;授权doGetAuthorizationInfo&quot;);</span><br><span class="line">        SimpleAuthorizationInfo info &#x3D; new SimpleAuthorizationInfo();</span><br><span class="line">        info.addStringPermission(&quot;user:add&quot;);</span><br><span class="line">        &#x2F;&#x2F;拿到当前登录的这个对象</span><br><span class="line">        Subject subject&#x3D;SecurityUtils.getSubject();</span><br><span class="line">        User currentUser &#x3D; (User) subject.getPrincipal();</span><br><span class="line">        &#x2F;&#x2F;设置当前用户的权限</span><br><span class="line">        info.addStringPermission(currentUser.getPerms());</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;认证</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">        System.out.println(&quot;执行了&#x3D;&gt;认证doGetAuthenticationInfo&quot;);</span><br><span class="line">        UsernamePasswordToken userToken &#x3D; (UsernamePasswordToken) token;</span><br><span class="line">        &#x2F;&#x2F;用户名，密码   从数据库中获取</span><br><span class="line">        User user &#x3D; userService.queryUserByName(userToken.getUsername());</span><br><span class="line">        if(user&#x3D;&#x3D;null)&#123;&#x2F;&#x2F;用户不存在</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Subject currentSubject &#x3D; SecurityUtils.getSubject();</span><br><span class="line">        Session session &#x3D; currentSubject.getSession();</span><br><span class="line">        session.setAttribute(&quot;loginUser&quot;,user);</span><br><span class="line">        &#x2F;&#x2F;密码认证，shiro自己做,密码进行了加密</span><br><span class="line">        return new SimpleAuthenticationInfo(user,user.getPwd(),&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-控制器发起请求"><a href="#4-控制器发起请求" class="headerlink" title="4.控制器发起请求"></a>4.控制器发起请求</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.zl.shiro.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.IncorrectCredentialsException;</span><br><span class="line">import org.apache.shiro.authc.UnknownAccountException;</span><br><span class="line">import org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class="line">import org.apache.shiro.session.Session;</span><br><span class="line">import org.apache.shiro.subject.Subject;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import javax.jws.WebParam;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @author zhanglang</span><br><span class="line">* @Date 2020&#x2F;6&#x2F;30</span><br><span class="line">*&#x2F;</span><br><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line">    @RequestMapping(&#123;&quot;&#x2F;&quot;,&quot;&#x2F;index&quot;&#125;)</span><br><span class="line">    public String toIndex(Model model)&#123;</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,&quot;hello,Shiro&quot;);</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;user&#x2F;add&quot;)</span><br><span class="line">    public String add()&#123;</span><br><span class="line">        return &quot;user&#x2F;add&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;user&#x2F;update&quot;)</span><br><span class="line">    public String update()&#123;</span><br><span class="line">        return &quot;user&#x2F;update&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;toLogin&quot;)</span><br><span class="line">    public String toLogin()&#123;</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">    public String login(String username,String password,Model model)&#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前的用户</span><br><span class="line">        Subject subject &#x3D; SecurityUtils.getSubject();</span><br><span class="line">        &#x2F;&#x2F;封装用户的登录数据</span><br><span class="line">        UsernamePasswordToken token &#x3D; new UsernamePasswordToken(username, password);</span><br><span class="line">        try&#123;</span><br><span class="line">            subject.login(token);&#x2F;&#x2F;执行登录方法，如果没有异常就说明OK了，</span><br><span class="line">            return &quot;index&quot;;</span><br><span class="line">        &#125;catch (UnknownAccountException e)&#123;&#x2F;&#x2F;用户名不存在</span><br><span class="line">            model.addAttribute(&quot;msg&quot;,&quot;用户名错误&quot;);</span><br><span class="line">            return &quot;login&quot;;</span><br><span class="line">        &#125;catch (IncorrectCredentialsException e) &#123;&#x2F;&#x2F;密码不存在</span><br><span class="line">            model.addAttribute(&quot;msg&quot;, &quot;密码错误&quot;);</span><br><span class="line">            return &quot;login&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;noauth&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String unauthorized()&#123;</span><br><span class="line">        return &quot;未经授权无法访问此页面&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-shiro</category>
      </categories>
      <tags>
        <tag>-shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot整合MybatisPlus</title>
    <url>/2020/09/14/Springboot%E6%95%B4%E5%90%88MybatisPlus/</url>
    <content><![CDATA[<p>​          对于MybatisPlus，最好的解释就来自于官网：<a href="https://github.com/baomidou/mybatis-plus" target="_blank">Mybatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生，清晰明了，就是为了方便来的，说通俗点，就是懒，一切技术的发展都是为了更简单高效，为了减少常见的增删改查代码的代码量，MP帮我们在底层封装了大量的基础sql语句，它能够根据我们的数据库表，提供我们需要的常见方法接口，这里写了一个demo进行学习。</p>
<a id="more"></a>

<p>1.新建一个Springboot项目，导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--        引入mybatis-plus的依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--        引入数据源连接池德鲁伊Druid--&gt;</span><br><span class="line">        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.alibaba&#x2F;druid --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.20&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>2.设计一个简单的数据库user表</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/user1.jpg" alt="user1"></p>
<p>3.编写yml配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis-plus?characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">cn:</span></span><br><span class="line">      <span class="attr">zl:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>4.编写pojo实体类，实体类中可以写许多的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span><span class="comment">//默认是将类名作为表名的，但是也可以设置为数据库中的表名，会于该类名相对应</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;,type = IdType.AUTO)</span><span class="comment">//指定数据表的主键，如果不设置默认就是id</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date bir;</span><br><span class="line">    <span class="meta">@TableField(exist = false)</span><span class="comment">//代表不映射数据库</span></span><br><span class="line">    <span class="keyword">private</span> String aaa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写mapper接口，只需要继承BaseMapper<User>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.zl.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用mybatis-plus增强</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.编写测试方法，Mybatis-Plus拥有大量的条件构造器，这里只是测试了一部分，更多详情请查看<a href="https://mybatis.plus/guide/wrapper.html" target="_blank">Mybatis-Plus</a>官网</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.zl.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.zl.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.Wrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询所有</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        users.forEach(user -&gt; System.out.println(<span class="string">&quot;user= &quot;</span>+user));</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据主键查询一个</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//queryWrapper其中放入条件查询，默认为查询全部</span></span><br><span class="line">        User user=userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user= &quot;</span>+user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        <span class="comment">//queryWrapper.eq(&quot;age&quot;,&quot;19&quot;);//设置等值查询</span></span><br><span class="line">        queryWrapper.lt(<span class="string">&quot;age&quot;</span>,<span class="number">19</span>);<span class="comment">//设置小于查询</span></span><br><span class="line">        <span class="comment">//queryWrapper.le(&quot;age&quot;,19);//设置小于等于查询，gt是大于，ge是大于等于</span></span><br><span class="line">        List&lt;User&gt; users=userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(user -&gt; System.out.println(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模糊查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindLike</span><span class="params">()</span></span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        <span class="comment">//queryWrapper.like(&quot;name&quot;,&quot;o&quot;);</span></span><br><span class="line">        queryWrapper.likeLeft(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;d&quot;</span>);<span class="comment">//以XXX结尾，likeRight以XXX开头</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">        users.forEach(user -&gt; System.out.println(<span class="string">&quot;user= &quot;</span>+user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User entity=<span class="keyword">new</span> User();</span><br><span class="line">        entity.setName(<span class="string">&quot;Who&quot;</span>).setAge(<span class="number">20</span>).setBir(<span class="keyword">new</span> Date());</span><br><span class="line">        userMapper.insert(entity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改方法</span></span><br><span class="line">    <span class="comment">//基于主键id进行数据的修改</span></span><br><span class="line">    <span class="comment">//@Test</span></span><br><span class="line"><span class="comment">//    public void testUpdateById()&#123;</span></span><br><span class="line"><span class="comment">//        User user = userMapper.selectById(5);</span></span><br><span class="line"><span class="comment">//        user.setName(&quot;Love&quot;);</span></span><br><span class="line"><span class="comment">//        userMapper.updateById(user);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//批量修改。</span></span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line"><span class="comment">//    public  void testUpdate()&#123;</span></span><br><span class="line"><span class="comment">//        User user = userMapper.selectById(5);</span></span><br><span class="line"><span class="comment">//        user.setName(&quot;Maybe&quot;);</span></span><br><span class="line"><span class="comment">//        user.setBir(null).setAge(null);</span></span><br><span class="line"><span class="comment">//        QueryWrapper&lt;User&gt; updateWrapper=new QueryWrapper&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        updateWrapper.eq(&quot;age&quot;,19);</span></span><br><span class="line"><span class="comment">//        userMapper.update(user,updateWrapper);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于id删除一个</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userMapper.deleteById(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于条件删除</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        queryWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        userMapper.delete(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结:</p>
<p>越使用越感觉到Mybatis-Plus功能的强大，代码生成器、分页插件、Sequence主键等等，很多功能我都还未使用到，它还支持很多的插件扩展，更多详情请查看<a href="https://mybatis.plus/guide/wrapper.html" target="_blank">Mybatis-Plus</a>官网</p>
]]></content>
      <categories>
        <category>-mybatis</category>
      </categories>
      <tags>
        <tag>-MybatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot连接Docker中的Kafka测试</title>
    <url>/2020/10/28/Springboot%E8%BF%9E%E6%8E%A5Docker%E4%B8%AD%E7%9A%84Kafka%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>在Linux中安装了docker，在docker安装了kafka和zookeeper，如有不懂得，请参看：</p>
<a id="more"></a>

<p><a href="../Docker%E5%AE%89%E8%A3%85Kafka%E5%92%8CZookeeper%E5%8F%8A%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/index.html">Docker安装Kafka和Zookeeper及简单测试</a></p>
<p>下面我就开始在Idea中使用Springboot项目来连接Kafka来进行一些消息的生产和消费。</p>
<p>1.新建项目就不多说了，编写配置文件application.yml(不一定要yml呀，只是我习惯而已)，我也试了通过@Configuration写在配置类里面，但是说实话还是配置文件安逸，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">10.0</span><span class="number">.10</span><span class="number">.188</span><span class="string">:9092</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">0</span>   <span class="comment">#发生错误后，消息重发的次数</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span>   <span class="comment">#当有多个消息需要被发送到同一个分区时，生产者会把它们放在同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算。</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span>   <span class="comment">#设置生产者内存缓冲区的大小</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span>   <span class="comment">#键的序列化方式</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span>   <span class="comment">#值的序列化方式</span></span><br><span class="line">      <span class="comment"># acks=0 ： 生产者在成功写入消息之前不会等待任何来自服务器的响应。</span></span><br><span class="line">      <span class="comment"># acks=1 ： 只要集群的首领节点收到消息，生产者就会收到一个来自服务器成功响应。</span></span><br><span class="line">      <span class="comment"># acks=all ：只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="comment"># 自动提交的时间间隔 在spring boot 2.X 版本中这里采用的是值的类型为Duration 需要符合特定的格式，如1S,1M,2H,5D</span></span><br><span class="line">      <span class="attr">auto-commit-interval:</span> <span class="string">1S</span></span><br><span class="line">      <span class="comment"># 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该作何处理：</span></span><br><span class="line">      <span class="comment"># latest（默认值）在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）</span></span><br><span class="line">      <span class="comment"># earliest ：在偏移量无效的情况下，消费者将从起始位置读取分区的记录</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span></span><br><span class="line">      <span class="comment"># 是否自动提交偏移量，默认值是true,为了避免出现重复数据和数据丢失，可以把它设置为false,然后手动提交偏移量</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 键的反序列化方式</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="comment"># 值的反序列化方式</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="comment"># 在侦听器容器中运行的线程数。</span></span><br><span class="line">      <span class="attr">concurrency:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment">#listner负责ack，每调用一次，就立即commit</span></span><br><span class="line">      <span class="attr">ack-mode:</span> <span class="string">manual_immediate</span></span><br><span class="line">      <span class="attr">missing-topics-fatal:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>2.新建KafkaProducter类，这就是消息的生产者了，我的规划是一个生产者，两个消费者，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootkafka.product;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.support.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFuture;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.concurrent.ListenableFutureCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:kafka生产者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/28 16:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(KafkaProducter.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义topic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_ONE=<span class="string">&quot;topic.one&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_Group1=<span class="string">&quot;topic.group1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_Group2=<span class="string">&quot;topic.group2&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;准备发送消息为：&#123;&#125;&quot;</span>, JSONObject.toJSONString(obj));</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        ListenableFuture&lt;SendResult&lt;String,Object&gt;&gt; future=kafkaTemplate.send(TOPIC_ONE,obj);</span><br><span class="line">        future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;SendResult&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//发送失败的处理</span></span><br><span class="line">                logger.info(TOPIC_ONE+<span class="string">&quot; - 生产者 发送消息失败：&quot;</span>+throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult&lt;String, Object&gt; stringObjectSendResult)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//成功的处理</span></span><br><span class="line">                logger.info(TOPIC_ONE+<span class="string">&quot; - 生产者 发送消息成功：&quot;</span>+stringObjectSendResult.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.新建KafkaConsumer类，也就是消费者，把消费者分到两个不同的组中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootkafka.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootkafka.product.KafkaProducter;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.support.Acknowledgment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.support.KafkaHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Header;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:Kafka消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/28 16:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(KafkaConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = KafkaProducter.TOPIC_ONE,groupId = KafkaProducter.TOPIC_Group1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic_test1</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span></span>&#123;</span><br><span class="line">        Optional message=Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (message.isPresent())&#123;</span><br><span class="line">            Object msg=message.get();</span><br><span class="line">            logger.info(<span class="string">&quot;topic_test1 消费了： +++++++++++++++ Topic:&quot;</span> + topic+<span class="string">&quot;,Record:&quot;</span> + record+<span class="string">&quot;,Message:&quot;</span> + msg);</span><br><span class="line">            ack.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = KafkaProducter.TOPIC_ONE,groupId = KafkaProducter.TOPIC_Group2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topic_test2</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record, Acknowledgment ack, <span class="meta">@Header(KafkaHeaders.RECEIVED_TOPIC)</span> String topic)</span></span>&#123;</span><br><span class="line">        Optional message=Optional.ofNullable(record.value());</span><br><span class="line">        <span class="keyword">if</span> (message.isPresent())&#123;</span><br><span class="line">            Object msg=message.get();</span><br><span class="line">            logger.info(<span class="string">&quot;topic_test2 消费了： +++++++++++++++ Topic:&quot;</span> + topic+<span class="string">&quot;,Record:&quot;</span> + record+<span class="string">&quot;,Message:&quot;</span> + msg);</span><br><span class="line">            ack.acknowledge();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.由于kafka一般应用于Web项目中，这里我就导入了Web的包，使用请求来调用，新建KafkaController类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootkafka.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootkafka.product.KafkaProducter;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:Kafka控制器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/28 16:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/kafka&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaProducter kafkaProducter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">         kafkaProducter.send(<span class="string">&quot;Diamond U are my apple of my eyes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行启动器Application，然后在浏览器输入路径，<a href="http://localhost:8080/kafka/send%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0%E4%BF%A1%E6%81%AF%EF%BC%8C">http://localhost:8080/kafka/send，查看控制台打印信息，</a></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/5.1.png" alt="5.1"></p>
<p>后面是输入的发送信息：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/5.2.png" alt="5.2"></p>
<p>总结，只是简单的使用了一下Kafka，很多功能都没用上，我做的上一个项目，就是使用Kafka+Swagger来开发，真的很舒服，还是太菜了，希望每天进步一点点。</p>
]]></content>
      <categories>
        <category>-Kafka</category>
      </categories>
      <tags>
        <tag>-Docker -Kafka -Zookeeper -Linux -Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot整合Swagger</title>
    <url>/2020/09/14/Springboot%E6%95%B4%E5%90%88Swagger/</url>
    <content><![CDATA[<p>​          Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务，本文使用的swagger_ui.html，使用可视化页面来描述文件，接口的调用方、测试、项目经理等都可以在该页面中对相关接口进行查阅和做一些简单的接口请求，这里写了一个简单的demo进行学习。</p>
<p>1.新建一个Springboot项目Springboot-swagger</p>
<a id="more"></a>

<p>2.导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger-ui --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.springfox&#x2F;springfox-swagger2 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">           &lt;exclusions&gt;</span><br><span class="line">               &lt;exclusion&gt;</span><br><span class="line">                   &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                   &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;&#x2F;exclusion&gt;</span><br><span class="line">           &lt;&#x2F;exclusions&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">   &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>3.新建SwaggerConfig类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.启动SwaggerApplication服务，页面访问<a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/view.png" alt="view"></p>
<p>5.配置Swagger</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置Swagger信息-apiInfo</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//作者信息</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;ZL&quot;</span>,<span class="string">&quot;http://www.zllwsy.com&quot;</span>,<span class="string">&quot;zllwsy@outlook.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;ZL的SwaggerAPI文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;学习永无止境&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;urn:tos&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.配置Swagger分组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.groupName(&quot;ZL&quot;)</span><br></pre></td></tr></table></figure>

<p>7.配置多个分组，多个Docket实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.Swagger的注解注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实体类</span><br><span class="line">@ApiModel(&quot;用户实体类&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @ApiModelProperty(&quot;用户名&quot;)</span><br><span class="line">    public String username;</span><br><span class="line">    @ApiModelProperty(&quot;密码&quot;)</span><br><span class="line">    public String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;控制类</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;只要我们的接口中，返回值存在实体类，就会被扫描到Swagger中</span><br><span class="line">    @PostMapping(value &#x3D; &quot;&#x2F;user&quot;)</span><br><span class="line">    public User user()&#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line"> &#x2F;&#x2F;@ApiOperation放在方法上</span><br><span class="line">   @ApiOperation(&quot;Hello控制类&quot;)</span><br><span class="line">   @GetMapping(value &#x3D; &quot;&#x2F;hello2&quot;)</span><br><span class="line">   public String hello2(@ApiParam(&quot;用户名&quot;) String username)&#123;</span><br><span class="line">    return &quot;hello&quot;+username;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@ApiModel</span><br><span class="line">@ApiModelProperty</span><br><span class="line">@ApiOperation</span><br><span class="line">@ApiParam</span><br></pre></td></tr></table></figure>

<p>9.关于Swagger的更多配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置了Swagger的Docket的bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置要显示的Swagger环境，也就是扫描哪一个application配置文件</span></span><br><span class="line">        Profiles profiles=Profiles.of(<span class="string">&quot;dev&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//获取项目的环境,通过environment.acceptsProfiles判断是否处于自己设定的环境中</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(<span class="string">&quot;ZL&quot;</span>)</span><br><span class="line">                <span class="comment">//enable是否启动swagger，如果为false，则在浏览器中不能访问Swagger</span></span><br><span class="line">                .enable(flag)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//RequestHandlerSelectors配置要扫描接口对的方式</span></span><br><span class="line">                <span class="comment">//basePackage指定要扫描的包</span></span><br><span class="line">                <span class="comment">//any()扫描全部</span></span><br><span class="line">                <span class="comment">//none()不扫描</span></span><br><span class="line">                <span class="comment">//withClassAnnotation扫描类上的注解，参数是一个注解的反射对象</span></span><br><span class="line">                <span class="comment">//withMethodAnnotation扫描方法上的注解</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;cn.zl.swagger.controller&quot;</span>))<span class="comment">//设置扫描的基本包</span></span><br><span class="line">                <span class="comment">//paths路径过滤</span></span><br><span class="line">                <span class="comment">// .paths(PathSelectors.ant(&quot;/zl/**&quot;))</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置Swagger信息-apiInfo</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//作者信息</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;ZL&quot;</span>,<span class="string">&quot;http://www.zllwsy.com&quot;</span>,<span class="string">&quot;zllwsy@outlook.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(</span><br><span class="line">                <span class="string">&quot;ZL的SwaggerAPI文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;学习永无止境&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;urn:tos&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.重新启动SwaggerApplication服务，访问<a href="http://localhost:8081/swagger-ui.html">http://localhost:8081/swagger-ui.html</a></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/ui.png" alt="ui"></p>
]]></content>
      <categories>
        <category>-swagger</category>
      </categories>
      <tags>
        <tag>-swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Typora写了一个Hello World</title>
    <url>/2020/12/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p><a href="https://www.baidu.com/" target="_blank">百度</a>问病，别问，问就是<a href="[https://www.baidu.com/s?ie=UTF-8&wd=%E7%99%8C%E7%97%87](https://www.baidu.com/s?ie=UTF-8&wd=癌症)" target="_blank">癌症</a>，再问再问就是<a href="https://baike.baidu.com/item/%E8%89%BE%E6%BB%8B%E7%97%85/236590?fr=aladdin" target="_blank">艾滋</a>！</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/sss.png" alt="sss"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server<img src="https://gitee.com/zllwsy/PicGo/raw/master/img/test.jpg" alt="test"></h3><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/img.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/xxx.jpg" alt="xxx"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>-Blog System</category>
      </categories>
      <tags>
        <tag>-Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot集成netty</title>
    <url>/2020/11/01/Springboot%E9%9B%86%E6%88%90netty/</url>
    <content><![CDATA[<p>在尝试了Mqtt、Kafka、RabbitMq几种有关消息的技术后，我越发对消息的通信感兴趣，无意中了解到了netty，没错，第一时间我还是懵逼的，但是我看好多人都说netty是深入学习Java的必经之路，那，我，胖虎，要学，</p>
<p>首先什么是netty？</p>
<a id="more"></a>

<p>我大概知道了，但是我不会(其实就是说不清楚，半懂不懂的)，推荐一篇文章，我觉得很Ok，连我都看懂了，你不会看不懂吧？传送门：<a href="https://www.cnblogs.com/MrRightZhao/p/11925307.html" target="_blank">什么是netty–通俗易懂</a>，</p>
<p>所以，看完大概知道啥是netty了吧，如果还不能理解，那就，，，再看一遍吧(反正我是读了两三遍)，接下来就试着使用Sprongboot来集成一下netty，实现一下简单的客户端与服务端的通信，</p>
<p>1.新建项目，导入依赖，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;io.netty&#x2F;netty-all --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.1.42.Final&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.依赖更新一下，我是先开始写客户端的，这里参考了一些文档，但是我真记不得是哪篇了，像我其他笔记，有借鉴我都会贴出来的，抱歉，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.netty.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:聊天客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29 9:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程组</span></span><br><span class="line">        EventLoopGroup loopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2.创建客户端启动助手，完成相关配置</span></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                <span class="comment">//3.设置线程组</span></span><br><span class="line">                .group(loopGroup)</span><br><span class="line">                <span class="comment">//4.设置客户端通道的实现类</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//5.创建一个初始化通道对象 ，//步骤6在MyChatClientInitializer中</span></span><br><span class="line">                .handler(<span class="keyword">new</span> MyChatClientInitializer());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Client is ready ...&quot;</span>);</span><br><span class="line">            <span class="comment">//7.启动客户端去连接服务器端，connect方法是异步的，sync方法是同步阻塞的</span></span><br><span class="line">            ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">52002</span>).sync();</span><br><span class="line">            Channel channel = future.channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//8.手动在控制台输入内容，然后enter发送</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;please enter ...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;exit&quot;</span>.equals(msg)) <span class="keyword">break</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;msg is push ...&quot;</span>);</span><br><span class="line">                channel.writeAndFlush(msg + System.lineSeparator());</span><br><span class="line">            &#125;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//9.关闭连接</span></span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">            System.out.println(<span class="string">&quot;Client is end ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.由于自己也是学习，我就在代码中写入了很详细的步骤和注释内容，接着进行客户端的初始化，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.netty.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:客户端初始化器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29 9:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        socketChannel.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">4096</span>, Delimiters.lineDelimiter()))</span><br><span class="line">                <span class="comment">//编码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8))</span><br><span class="line">                <span class="comment">//解码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8))</span><br><span class="line">                <span class="comment">//6.在pipeline中添加自定义的Handler</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> MyChatClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.客户端的处理器，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.netty.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:客户端的处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29 9:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClientHandler.channelActive&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client: &quot;</span> + ctx);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========|服务端发来的消息: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.服务端和客户端其实差不了太多，服务端的类不一样，客户端是提供ip和端口，然后服务端去绑定，也可以称为监听，这样才能获取到客户端发来的消息，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.netty.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:聊天服务器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29 9:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MychatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个线程组，用来接收客户端连接</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//2.创建一个线程组，处理网络操作</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="comment">//3.创建服务端启动助手来配置参数</span></span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                 <span class="comment">//4.设置两个线程组</span></span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                 <span class="comment">//5.使用NioServerSocketChannel作为服务器端通道的实现</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                 <span class="comment">//6.设置线程队列中等待连接的个数</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                 <span class="comment">//7.保持活动连接状态</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                 <span class="comment">//8.创建一个通道初始化对象 //步骤9在MyChatServerInitializer中</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> MyChatServerInitializer());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Server is ready ...&quot;</span>);</span><br><span class="line">            <span class="comment">//10.绑定端口，bind方法是异步的,sync方法是同步阻塞的</span></span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(<span class="number">52002</span>).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server is starting ...&quot;</span>);</span><br><span class="line">            <span class="comment">//11.关闭通道，关闭线程组</span></span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server is end ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.然后是服务端的初始化类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.netty.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:聊天服务端的初始化器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29 9:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        socketChannel.pipeline()</span><br><span class="line">                .addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">4096</span>, Delimiters.lineDelimiter()))</span><br><span class="line">                <span class="comment">//编码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> StringDecoder(CharsetUtil.UTF_8))</span><br><span class="line">                <span class="comment">//解码器</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> StringEncoder(CharsetUtil.UTF_8))</span><br><span class="line">                <span class="comment">//9.在pipeline中添加自定义的Handler</span></span><br><span class="line">                .addLast(<span class="keyword">new</span> MyChatServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.最后是服务端的处理器，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.netty.work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:聊天服务器的处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/10/29 9:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEPARATOR = System.lineSeparator();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyChatServerHandler.handlerAdded&quot;</span>);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;Server&gt;&quot;</span> + channel.remoteAddress() + <span class="string">&quot;add&quot;</span> + SEPARATOR + <span class="string">&quot;加入\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyChatServerHandler.channelACTIVE&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;client&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;处于连接状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,Object msg)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server: &quot;</span> + ctx);</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========|客户端发来的消息: &quot;</span> + channel.remoteAddress() + <span class="string">&quot;&gt; &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Channel ch : channelGroup) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != channel) &#123;</span><br><span class="line">                ch.writeAndFlush(channel.remoteAddress() + <span class="string">&quot;&gt; &quot;</span> + msg + SEPARATOR);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;自己&quot;</span> + <span class="string">&quot;&gt; &quot;</span> + msg + SEPARATOR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyChatServerHandler.channelInactive&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;client&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;处于断开状态&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyChatServerHandler.handlerRemoved&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.remove(channel); <span class="comment">// Netty会自动寻找断掉的channel，然后移除，可以不用手动移除</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;Server&gt; &quot;</span> + channel.remoteAddress() + <span class="string">&quot; remove&quot;</span> + SEPARATOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.然后开始测试，将服务端和客户端分别启动，服务端：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/6.1.png" alt="6.1"></p>
<p>客户端：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/6.2.png" alt="6.2"></p>
<p>11.客户端给服务端发送消息，我是在控制台输入，其他特殊需求，也可以直接在代码里面写，或者页面实现，</p>
<p>客户端：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/6.3.png" alt="6.3"></p>
<p>服务端：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/6.4.png" alt="6.4"></p>
<p>总结，可以看到消息确实接收到了，但是，有一点难受，就是我实现不了服务端给客户端发送消息，我debug跑了几遍，在客户端监听不了ip和端口，我无法确切的去接收服务端发来的消息，我知道是可以实现的，但是我菜呀，我会继续学习，在后续中实现了，我就进行更新。</p>
]]></content>
      <categories>
        <category>-Netty</category>
      </categories>
      <tags>
        <tag>-Netty -Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之jedis</title>
    <url>/2020/09/13/redis%E4%B9%8Bjedis/</url>
    <content><![CDATA[<p>jedis就是使用java对redis进行操作的客户端，和直接操作redis区别不大，是属于了解知道就行，毕竟现在实际开发中都是封装好的，直接配置文件写好后，直接应用，比如redisson，redisson 不仅封装了 redis ，还封装了对更多数据结构的支持，以及锁等功能，相比于Jedis 功能更加强大，在分布式项目中使用非常广泛，案例：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:使用java操作redis</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 10:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建jedis客户端对象</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.139.188&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//选择使用一个库，默认使用0号库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//获取redis所有key信息</span></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        keys.forEach(key-&gt; System.out.println(<span class="string">&quot;key = &quot;</span>+ key));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作库相关</span></span><br><span class="line">        jedis.flushDB();<span class="comment">//清空当前库</span></span><br><span class="line">        jedis.flushAll();<span class="comment">//清空所有库</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -jedis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之Template</title>
    <url>/2020/09/13/redis%E4%B9%8BTemplate/</url>
    <content><![CDATA[<p>Spring操作redis和java操作redis(也就是jedis)有所不同，通常有三种，第一个是RedisTemplate，第二个是StringRedisTemplate，第三是bound api，</p>
<a id="more"></a>

<p>1.RedisTemplate</p>
<p>​         在RedisTemplate中，对k-v都是有要求的，key和value本身都是JdkSerializationRedisSerializer的序列化，而key默认是String类型，value本身就是Object对象，所以只需要重新设置key的序列化方法，使用StringRedisSerializer就可以了，案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.SpringbootRedisApplication;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 13:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//启动Springboot应用</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = SpringbootRedisApplication.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;<span class="comment">//key Object value Object ====&gt;对象序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//opsForxxx Vlaue String List Set Zset hash</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改key序列化方案 String类型序列</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改hash key的序列化方案</span></span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(Long.valueOf(UUID.randomUUID().toString())).setName(<span class="string">&quot;小陈&quot;</span>).setAge(<span class="number">23</span>).setEmail(<span class="string">&quot;zllwsy@outlook.com&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>,user);<span class="comment">//redis进行设置  对象需要经过序列化</span></span><br><span class="line">        User user1 = (User) redisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">&quot;list&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForSet().add(<span class="string">&quot;set&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForZSet().add(<span class="string">&quot;zset&quot;</span>,user,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;map&quot;</span>,<span class="string">&quot;name&quot;</span>,user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.StringRedisTemplate</p>
<p>​          StringRedisTemplate意思很明了，key和value都是String类型，下面是一些常见操作，案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.SpringbootRedisApplication;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.DataType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ZSetOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 11:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//启动Springboot应用</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = SpringbootRedisApplication.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringRedisTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;<span class="comment">//key ，value都是字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中key相关</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKey</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        stringRedisTemplate.delete(&quot;name&quot;);//删除一个key</span></span><br><span class="line">        Boolean hasKey = stringRedisTemplate.hasKey(<span class="string">&quot;name&quot;</span>);<span class="comment">//判断某个key是否存在</span></span><br><span class="line">        System.out.println(hasKey);</span><br><span class="line">        DataType name = stringRedisTemplate.type(<span class="string">&quot;name&quot;</span>);<span class="comment">//判断key所对应值的类型</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        Set&lt;String&gt; keys = stringRedisTemplate.keys(<span class="string">&quot;*&quot;</span>);<span class="comment">//获取redis中所有</span></span><br><span class="line">        keys.forEach(key -&gt; System.out.println(<span class="string">&quot;key = &quot;</span>+ key));</span><br><span class="line">        Long expire = stringRedisTemplate.getExpire(<span class="string">&quot;name&quot;</span>);<span class="comment">//获取key的超时时间</span></span><br><span class="line">        System.out.println(expire);<span class="comment">//-1,代表永不超时；-2 key不存在，&gt;=0 超时时间</span></span><br><span class="line">        stringRedisTemplate.randomKey();<span class="comment">//所及获取一个key</span></span><br><span class="line">        stringRedisTemplate.rename(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;age1&quot;</span>);<span class="comment">//修改key的名字，要求key必须存在，不存在会报错</span></span><br><span class="line">        stringRedisTemplate.renameIfAbsent(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;age1&quot;</span>);<span class="comment">//也是修改key的名字，但是会判断key是否存在</span></span><br><span class="line">        stringRedisTemplate.move(<span class="string">&quot;name&quot;</span>,<span class="number">1</span>);<span class="comment">//移动key到指定库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中字符串,opsForValue实际就是操作redis中的String类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小张&quot;</span>);<span class="comment">//设置 key value</span></span><br><span class="line">        String name = stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);<span class="comment">//获取value</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;2357&quot;</span>,<span class="number">60</span>, TimeUnit.SECONDS);<span class="comment">//设置一个key的超时时间</span></span><br><span class="line">        stringRedisTemplate.opsForValue().append(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;你是个好人&quot;</span>);<span class="comment">//追加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//操作redis中list类型，opsForList实际就是操作redis中list类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForList().leftPush(<span class="string">&quot;names&quot;</span>,<span class="string">&quot;小黑&quot;</span>);<span class="comment">//创建一个列表，并放入一个元素</span></span><br><span class="line">        stringRedisTemplate.opsForList().leftPushAll(<span class="string">&quot;names&quot;</span>,<span class="string">&quot;小花&quot;</span>,<span class="string">&quot;小王&quot;</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        ArrayList&lt;Object&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;xiaosan&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForList().leftPushAll(<span class="string">&quot;names&quot;</span>, String.valueOf(names));<span class="comment">//创建一个列表，放入多个元素</span></span><br><span class="line">        List&lt;String&gt; stringList = stringRedisTemplate.opsForList().range(<span class="string">&quot;names&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);<span class="comment">//遍历list</span></span><br><span class="line">        stringList.forEach( value -&gt; System.out.println(<span class="string">&quot;value = &quot;</span>+ value));</span><br><span class="line">        stringRedisTemplate.opsForList().trim(<span class="string">&quot;names&quot;</span>,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//截取指定区间的list,前三个，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作redis中set类型，opsForSet实际就是操作redis中set类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForSet().add(<span class="string">&quot;sets&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李三&quot;</span>,<span class="string">&quot;xiaoming&quot;</span>);<span class="comment">//添加</span></span><br><span class="line">        Set&lt;String&gt; sets = stringRedisTemplate.opsForSet().members(<span class="string">&quot;sets&quot;</span>);<span class="comment">//成员</span></span><br><span class="line">        sets.forEach( value -&gt; System.out.println(<span class="string">&quot;value = &quot;</span> +value));</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForSet().size(<span class="string">&quot;sets&quot;</span>);<span class="comment">//获取set集合元素个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//操作redis中zset类型，opsForZSet实际就是操作redis中zset类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testZset</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForZSet().add(<span class="string">&quot;zsets&quot;</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">100</span>);<span class="comment">//创建并放入元素</span></span><br><span class="line">        Set&lt;String&gt; zsets = stringRedisTemplate.opsForZSet().range(<span class="string">&quot;zsets&quot;</span>, <span class="number">1</span>, -<span class="number">1</span>);<span class="comment">//指定范围查询</span></span><br><span class="line">        zsets.forEach( value -&gt; System.out.println(<span class="string">&quot;value = &quot;</span>+value));</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zsets1 = stringRedisTemplate.opsForZSet().rangeByScoreWithScores(<span class="string">&quot;zsets&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        zsets1.forEach( typedTuple-&gt; &#123;</span><br><span class="line">            System.out.println(typedTuple.getValue());</span><br><span class="line">            System.out.println(typedTuple.getScore());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//操作redis中Hash类型，opsForHash实际就是操作redis中Hash类型</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHash</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForHash().put(<span class="string">&quot;maps&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);<span class="comment">//创建一个hash类型，并放入key value</span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;bir&quot;</span>,<span class="string">&quot;2020-2-2&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForHash().putAll(<span class="string">&quot;maps&quot;</span>,map);<span class="comment">//放入多个key value</span></span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; values = stringRedisTemplate.opsForHash().multiGet(<span class="string">&quot;maps&quot;</span>, Arrays.asList(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>));<span class="comment">//获取多个key</span></span><br><span class="line">        String value = (String) stringRedisTemplate.opsForHash().get(<span class="string">&quot;maps&quot;</span>,<span class="string">&quot;name&quot;</span>);<span class="comment">//获取hash中某个key的值</span></span><br><span class="line">        List&lt;Object&gt; vals = stringRedisTemplate.opsForHash().values(<span class="string">&quot;maps&quot;</span>);<span class="comment">//获取所有values</span></span><br><span class="line">        Set&lt;Object&gt; keys = stringRedisTemplate.opsForHash().keys(<span class="string">&quot;maps&quot;</span>);<span class="comment">//获取所有key</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.Bound Api</p>
<p>​          bound api其实就是一种简化操作，是由Spring data 为了方便对redis进行更友好的操作而提供的，案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.SpringbootRedisApplication;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.BoundListOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.BoundValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 13:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//启动Springboot应用</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = SpringbootRedisApplication.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBoundAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Diamond&quot;</span>);</span><br><span class="line">        stringRedisTemplate.opsForValue().append(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;你是一个好人&quot;</span>);</span><br><span class="line">        String s = stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果确认是对一个key多次操作，则对key进行绑定</span></span><br><span class="line">        <span class="comment">//滴哦字符串类型key进行绑定 后续所有操作都是基于这个key的操作，后续的操作参数就少了key的值</span></span><br><span class="line">        BoundValueOperations&lt;String, String&gt; nameValue = stringRedisTemplate.boundValueOps(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        nameValue.set(<span class="string">&quot;Diamond&quot;</span>);</span><br><span class="line">        nameValue.append(<span class="string">&quot;你是一个好人&quot;</span>);</span><br><span class="line">        String s1 = nameValue.get();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对list set zset hash</span></span><br><span class="line"></span><br><span class="line">        BoundListOperations&lt;String, String&gt; listsValue = stringRedisTemplate.boundListOps(<span class="string">&quot;lists&quot;</span>);</span><br><span class="line">        listsValue.leftPushAll(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        List&lt;String&gt; range = listsValue.range(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        range.forEach( value -&gt; System.out.println(value));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//set</span></span><br><span class="line"><span class="comment">//        stringRedisTemplate.boundSetOps();</span></span><br><span class="line">        <span class="comment">//zset</span></span><br><span class="line"><span class="comment">//        stringRedisTemplate.boundZSetOps();</span></span><br><span class="line">        <span class="comment">//hash</span></span><br><span class="line"><span class="comment">//        stringRedisTemplate.boundHashOps();</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.针对日后处理key value 都是String 使用StringRedisTemplate</span></span><br><span class="line"><span class="comment">         * 2.针对日后处理key value 存在对象 使用RedisTemplate</span></span><br><span class="line"><span class="comment">         * 3.针对同一个key多次操作可以使用boundXXXops()的api，简化书写</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -redisTemplate -stringRedisTemplate -bound api</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之哨兵机制</title>
    <url>/2020/09/13/redis%E4%B9%8B%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>简单来说哨兵就是带有自动故障转移功能的主从架构 </p>
<p>1.下载配置sentinel文件，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;redis-stable&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure>

<p>2./var/lib/docker/sentinel/sentinel.conf/修改配置文件，然后复制一份到容器外部/etc/redis/sentinel.conf，</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 0.0.0.0    ：外部访问</span><br><span class="line"> </span><br><span class="line">daemonize yes   :后台运行</span><br><span class="line"></span><br><span class="line">sentinel monitor mymaster 192.168.139.188 6379 1   ：设置哨兵，主机ip，端口，哨兵数量</span><br></pre></td></tr></table></figure>

<p>3.docker运行一个哨兵，docker ps查看是否运行成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name sentinel -p 26379:26379 -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;sentinel&#x2F;sentinel.conf:&#x2F;etc&#x2F;redis&#x2F;sentinel.conf -d redis</span><br></pre></td></tr></table></figure>

<p>4.进入容器内部</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it sentinel &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>5.启动哨兵，记得一定要指定配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-sentinel &#x2F;etc&#x2F;redis&#x2F;sentinel.conf</span><br></pre></td></tr></table></figure>

<p>6.启动哨兵客户端，记得一定要指定端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -p 26379</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/sentinel.png" alt="sentinel"></p>
<p>7.info命令查看哨兵情况，在最底部有哨兵信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sentinel</span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line">sentinel_simulate_failure_flags:0</span><br><span class="line">master0:name&#x3D;mymaster,status&#x3D;ok,address&#x3D;192.168.139.188:6379,slaves&#x3D;2,sentinels&#x3D;1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/showSentinel.png" alt="showSentinel"></p>
<p>8.将主机6379容器关闭，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop redis</span><br></pre></td></tr></table></figure>

<p>9.有三种方式可以验证，一是在哨兵客户端info里面查看，最底部的master的端口已经改变，二是可以分别查看两个从机的信息(使用info replication命令)，可以看到其中一个的role已经变成了master，三是从机是不具备写操作的，可以在两个从机分别进行写操作，不报错的就是新的主机。</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/cantSet.png" alt="cantSet"></p>
<p>10.容器目前运行情况为一个可视化工具，一个主机，两个从机，一个哨兵</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/showAll.png" alt="showAll"></p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之主从复制</title>
    <url>/2020/09/13/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>1.拷贝两份redis.conf；</p>
<p>2.分别设置replicaof配置：196.168.139.188 6379(在redis6.0.7版本中，slaveof单词已经被replicaof替换)，注意：主机不要打开replicaof的配置；</p>
<a id="more"></a>

<p>3.分别设置各自的端口6380、6381；</p>
<p>4.启动三个redis，6379为主机，6380、6381为从机；</p>
<p>5.因为主机redis已经启动，这里需要再启动两个slave从机容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 6380:6380 --name slave1 -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;slave1&#x2F;redis.conf:&#x2F;etc&#x2F;slave1&#x2F;redis.conf -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;slave1&#x2F;data:&#x2F;data -d redis redis-server &#x2F;etc&#x2F;slave1&#x2F;redis.conf --appendonly yes</span><br><span class="line"></span><br><span class="line">docker run -p 6381:6381 --name slave2 -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;slave2&#x2F;redis.conf:&#x2F;etc&#x2F;slave2&#x2F;redis.conf -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;slave2&#x2F;data:&#x2F;data -d redis redis-server &#x2F;etc&#x2F;slave2&#x2F;redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>

<p>6.可以进入容器，查看role信息；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it redis redis-cli -p 6379</span><br><span class="line">docker exec -it slave1 redis-cli -p 6380</span><br><span class="line">docker exec -it slave2 redis-cli -p 6381</span><br><span class="line"></span><br><span class="line">分别输入命令查看信息</span><br><span class="line">info replication</span><br><span class="line"></span><br><span class="line">可以看到6379的role显示为master</span><br><span class="line">其他两个显示为slave</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/slave1.png" alt="slave1"></p>
<p>7.从机会自动同步主机数据，但是，并不能实现故障转移功能，从机只是存储数据备份而已；</p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -redis.conf -slave</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之持久化</title>
    <url>/2020/09/13/redis%E4%B9%8B%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<h4 id="redis持久化："><a href="#redis持久化：" class="headerlink" title="redis持久化："></a>redis持久化：</h4><p>​                    redis的持久化一般有两种方式，一个是快照，也就是常说的RDB持久化，另一个就是AOF持久化，两则之间的差别其实挺大，希望看完本篇文章后您能找到合适你的方法。</p>
<h5 id="方式一：快照snapshot：保存这一时刻的数据状态，这是默认开启快照，由于保存的文件是以-rdb形式结尾的文件，因此这种方式也称之为RDB持久化方式。"><a href="#方式一：快照snapshot：保存这一时刻的数据状态，这是默认开启快照，由于保存的文件是以-rdb形式结尾的文件，因此这种方式也称之为RDB持久化方式。" class="headerlink" title="方式一：快照snapshot：保存这一时刻的数据状态，这是默认开启快照，由于保存的文件是以.rdb形式结尾的文件，因此这种方式也称之为RDB持久化方式。"></a>方式一：快照snapshot：保存这一时刻的数据状态，这是默认开启快照，由于保存的文件是以.rdb形式结尾的文件，因此这种方式也称之为RDB持久化方式。</h5><a id="more"></a>

<p>快照生成方式：1.客户端方式：BGSAVE和SAVE指令</p>
<p>​                            2.服务器配置自动触发</p>
<h6 id="1-客户端方式："><a href="#1-客户端方式：" class="headerlink" title="1.客户端方式："></a>1.客户端方式：</h6><p>​                   BGSAVE方式：在redis-cli客户端直接输入命令：BGSAVE。客户端可以使用BGSAVE命令来创建一个快照，当接收到客户端的BGSAVE命令时，redis会调用fork’来创建一个子进程，然后子进程负责将快照写入磁盘中，而父进程则继续处理命令请求。</p>
<p>​                   在刚开始的时候，父子进程贡献相同内存，直到父进程或子进程对内存进行了写操作之后，对被写入的内存的共享才会结束服务，子进程是不会进行写操作的，这样就保证了在没有客户端请求的时候能够最大速度的处理子线程，如果有客户端请求的时候父进程才会用很小一部分请求去处理客户端请求，</p>
<p>​                   SAVE方式：在redis-cli客户端直接输入命令：SAVE，接收到SAVE命令的redis服务器在快照创建完毕之前将不再响应任何其他的命令，SAVE命令并不常用，使用SAVE命令在快照创建完毕之前，redis处于阻塞状态，无法对外服务。</p>
<h6 id="2-服务器方式："><a href="#2-服务器方式：" class="headerlink" title="2.服务器方式："></a>2.服务器方式：</h6><p>​                   在redis.conf配置中是默认开启BGSAVE快照的，只要满足任何一项都会生效RDB持久化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1  ：如果十五分钟内有一个key发生变化，那么就十五分钟执行一次BGSAVE</span><br><span class="line">save 300 10 ：如果五分钟内有十个key发生变化，那么就五分钟执行一次</span><br><span class="line">save 60 1000 ：如果一分钟内有一万个key发生变化，那么一分钟就执行一次</span><br></pre></td></tr></table></figure>

<p>​                   服务器接收到客户端shutdown指令的时候，会执行一个save命令，阻塞所有的客户端，不再执行客户端执行发送的任何命令，并且在save命令执行完毕之后关闭服务器。</p>
<h6 id="对应可调整的配置文件："><a href="#对应可调整的配置文件：" class="headerlink" title="对应可调整的配置文件："></a>对应可调整的配置文件：</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb  :生成的快照的文件名</span><br><span class="line">dir .&#x2F;r  :生成快照的保存目录，默认是基于redis脚本的根目录，可以在docker启动一个镜像的时候指定</span><br><span class="line">rdbchecksum yes  ：导入rdb恢复数据时，是否检验rdb的完整性</span><br><span class="line">rdbcompression yes  ： 导出的rdb文件是否压缩</span><br></pre></td></tr></table></figure>

<p> 注意：RDB快照方式存在隐患，如果客户端刚刚加入新的数据，但是还没有达到快照生成的条件，这个时候突然断点，将会导致数据直接丢失， 也就是快照间隔问题  。</p>
<p>优势：1) RDB文件相比AOF占用的空间更小，恢复数据的速度更快；</p>
<p>​           2) 如果创建RDB文件时出现了错误，Redis不会将它用于替换原来的文件，所以出错的时不会影响到之前保存的版本；</p>
<p>​           3) 通过合理的配置可以放redis每隔一段时间就保存一次数据库副本，可以很方便的将数据还原到特定的时间点</p>
<p>缺点:  1) 如果硬件、系统、Redis三者其中之一出现问题而崩溃，Redis会丢  失全部数据，保留下来的数据只有上一个时间点创建的快照。如果数据对于应用程序来说非常重要，那么出现错误时的损失会非常大；</p>
<p>​          2) fork子进程占用的内存随着数据库中数据的增加而增加，耗费的时间也会越来越多</p>
<h5 id="方式二：AOF-append-only-file：将所有redis写命令记录到日志文件中，调用AOF时，会重写执行所有的写操作，以实现数据数据持久的绝对安全，"><a href="#方式二：AOF-append-only-file：将所有redis写命令记录到日志文件中，调用AOF时，会重写执行所有的写操作，以实现数据数据持久的绝对安全，" class="headerlink" title="方式二：AOF append only file：将所有redis写命令记录到日志文件中，调用AOF时，会重写执行所有的写操作，以实现数据数据持久的绝对安全，"></a>方式二：AOF append only file：将所有redis<span style="color:blue"><em>写命令</em></span>记录到日志文件中，调用AOF时，会重写执行所有的写操作，以实现数据数据持久的绝对安全，</h5><p>1.修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes  ：开启AOF持久化，也可以在docker run的时候指定</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  :修改指定生成的文件名称</span><br></pre></td></tr></table></figure>

<p>2.生成的appendonly.aof的文件和dump.rdb位于同一位置，我的为docker映射下的data文件夹里面</p>
<p>3.日志追加频率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">always[谨慎使用]</span><br><span class="line">说明：每个redis写命令都要同步写入磁盘，严重降低redis速度</span><br><span class="line">everysec[推荐]</span><br><span class="line">说明：每秒执行一次同步显示的将多个写命令同步到磁盘</span><br><span class="line">no[不推荐]</span><br><span class="line">说明：由操作系统决定何时同步</span><br></pre></td></tr></table></figure>

<p>4.问题：AOF的持久化文件会变得越来越大</p>
<p>5.AOF重写：用来在一定程度上减小AOF文件的体积</p>
<p>6.触发重写的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在客户端输入：BGREWRITEAOF</span><br><span class="line">服务器配置方式自动触发：</span><br><span class="line">auto-aof-rewrite-percentage 100  ：一次后重写要求的体积的百分比</span><br><span class="line">auto-aof-rewrite-min-size 64mb  ：初始化文件体积大小</span><br><span class="line">解释：在开启AOF持久化的情况下，当AOF文件体积大于64M，会做一次重写，而第二次重写时要求AOF文件的体积比上一次重写之后体积大了至少一倍(100%)时，会自动触发，如果重写过于频繁，auto-aof-rewrite-percentage设置得更大</span><br><span class="line">64M重写后可能变成20M，第二次重写就以20M为起始，当文件体积达到40M的时候才会触发重写，重写后可能变成18M，第三次重写就以18M为起始，当文件体积达到36M的时候触发重写，一直持续下去，</span><br></pre></td></tr></table></figure>

<p>7.重写原理</p>
<p>重写AOF文件的操作，并没有读取旧的AOF文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的AOF文件，替换原有的文件这点和快照有点类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.redis调用fork，现在有父子两个进程，子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令</span><br><span class="line">b.父进程继续处理client请求，除了把写命令写入到原来的AOF文件中，同时把收到的写命令缓存起来，这样就能保证如果子进程重写失败的话也不会出问题</span><br><span class="line">c.当子进程把快照内容以写命令的方式写入临时文件后，子进程发信号通知父进程，然后父进程把缓存的写命令也写入到临时文件</span><br><span class="line">d.现在父进程可以使用临时文件替换老的AOF文件，并重命名，后面收到的写命令也开始往新的AOF文件中追加</span><br></pre></td></tr></table></figure>

<p>8.一张看视频的时候截的重写分析图</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/AOF%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86.png" alt="AOF重写原理"></p>
<p>redis两重持久化方案的总结：</p>
<p>​      具体使用哪种持久化方案取决于用户的数据和应用决定，其实小孩子才做选择，我是大人，所以我都要QAQ。</p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -rdb -aof</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之搭建集群</title>
    <url>/2020/09/13/redis%E4%B9%8B%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<p>Redis集群redis-cluster维护的一个个节点，每一个redis集群至少一个节点，节点再去维护Solt槽</p>
<p>Redis集群最大物理节点数不能超过16384个(0-16383)</p>
<a id="more"></a>

<p>CRC16算法特点：</p>
<p> *对集群模式下所有的key进行CRC16计算，计算的结果始终在0-16383之间</p>
<p>*对客户端的key进行CRC16计算时同一个key多次经过CRC16计算结果始终一致</p>
<p>*对客户端的不同key进行CRC16计算，计算的结果会出现不同的key的结果一致</p>
<p>在以前的配置基础上在redis-conf中将cluster的配置打开即可，下面是集群分析图，来自视频截图：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/cluster.png" alt="cluster"></p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>redis之数据库常用命令</title>
    <url>/2020/09/12/redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>​          redis数据库的一些常用命令，可以实现对数据库的一些简单操作或者获取一些信息，前提是已经安装了并且进入容器，不懂的可以看看点击<a href="../redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">redis在docker中的使用</a>查看，常用的命令：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keys *：查询当前库所有键</span><br><span class="line">exists &lt;key&gt;:判断某个键是否存在，返回结果为1则存在，为0不存在</span><br><span class="line">type &lt;key&gt;:查看键的类型</span><br><span class="line">del &lt;key&gt;:删除某各键，返回结果为1则存在，为0不存在</span><br><span class="line">expire &lt;key&gt; &lt;seconds&gt;:为键值设置过期事件，单位秒</span><br><span class="line">ttl &lt;key&gt;:查看还有多少秒过期，-1表示永不过期，-2表示已经过期</span><br><span class="line">dbsize:查看当前数据库的key的数量</span><br><span class="line">flushdb:清空当前数据库</span><br><span class="line">flushall:清空所有的数据库</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis缓存总结</title>
    <url>/2020/09/13/redis%E4%B9%8B%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="Redis在Springboot项目实现简单的初步缓存"><a href="#Redis在Springboot项目实现简单的初步缓存" class="headerlink" title="Redis在Springboot项目实现简单的初步缓存"></a>Redis在Springboot项目实现简单的初步缓存</h4><p>新建了一个demo项目，来实现一下缓存，了解了一下mybatis自带的二级缓存和使用redis作为缓存的差异，感觉很不完善，但是我也是新手入门，慢慢学习成长中……</p>
<p>1.application.yml中配置mysql和mybatis</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  #Mysql配置</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;demo?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">  #Redis配置</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.139.188  #ip</span><br><span class="line">    port: 6379   #端口号</span><br><span class="line">    database: 0  #具体哪一个数据库，0-15</span><br><span class="line"></span><br><span class="line">#Mybatis配置</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:cn&#x2F;zl&#x2F;springbootredis&#x2F;mapper&#x2F;*.xml</span><br><span class="line">  type-aliases-package: cn.zl.springbootredis.dao</span><br><span class="line"></span><br><span class="line">#开启dao层的日志级别，便于查看sql语句</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    cn:</span><br><span class="line">      zl:</span><br><span class="line">        springbootredis:</span><br><span class="line">          dao: debug</span><br></pre></td></tr></table></figure>

<p>2.User实体类以及数据库表的设计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 12:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/6WU%WECHY%7B2H2APZHZD5%R2.png" alt="img"></p>
<p>3.编写sql语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;cn.zl.springbootredis.dao.UserDao&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--开启mybatis的二级缓存，也是本地缓存，存在问题就是无法分布式实现缓存，并且每次结束Application都会清空缓存--&gt;</span><br><span class="line">    &lt;cache&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--findAll--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findAll&quot; resultType&#x3D;&quot;cn.zl.springbootredis.entity.User&quot;&gt;</span><br><span class="line">       select * from user</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;!--findById--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;cn.zl.springbootredis.entity.User&quot;&gt;</span><br><span class="line">       select * from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;!--delete--&gt;</span><br><span class="line">    &lt;delete id&#x3D;&quot;delete&quot; parameterType&#x3D;&quot;Long&quot;&gt;</span><br><span class="line">       delete from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;delete&gt;</span><br><span class="line">    &lt;!--save--&gt;</span><br><span class="line">    &lt;insert id&#x3D;&quot;save&quot; parameterType&#x3D;&quot;cn.zl.springbootredis.entity.User&quot;&gt;</span><br><span class="line">       insert into user values(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;email&#125;)</span><br><span class="line">    &lt;&#x2F;insert&gt;</span><br><span class="line">    &lt;!--update--&gt;</span><br><span class="line">    &lt;update id&#x3D;&quot;update&quot; parameterType&#x3D;&quot;cn.zl.springbootredis.entity.User&quot;&gt;</span><br><span class="line">       update user set name &#x3D; #&#123;name&#125;,password &#x3D; #&#123;password&#125;,age &#x3D; #&#123;age&#125;,email &#x3D; #&#123;email&#125; where id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<p>4.接口实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 14:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.业务层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 14:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.service.UserServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.entity.User;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.dao.UserDao;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.service.UserService.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 14:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        userDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.update(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.SpringbootRedisApplication;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.entity.User;</span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.service.UserService.UserService;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 14:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//启动Springboot应用</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = SpringbootRedisApplication.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span></span>&#123;<span class="comment">//测试缓存</span></span><br><span class="line">        userService.findAll().forEach(user -&gt; System.out.println(<span class="string">&quot;user =&quot;</span> + user));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================================================&quot;</span>);</span><br><span class="line">        userService.findAll().forEach(user -&gt; System.out.println(<span class="string">&quot;user =&quot;</span> + user));<span class="comment">//第二次会从mybatis的二级缓存获取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User byId = userService.findById(<span class="number">55L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================================================&quot;</span>);</span><br><span class="line">        User byId1 = userService.findById(<span class="number">55L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.delete(<span class="number">2L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">2L</span>).setName(<span class="string">&quot;Hali&quot;</span>).setAge(<span class="number">21</span>).setPassword(<span class="string">&quot;333&quot;</span>).setEmail(<span class="string">&quot;wwww@163.com&quot;</span>);</span><br><span class="line">        userService.save(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">1L</span>).setName(<span class="string">&quot;Honey&quot;</span>).setAge(<span class="number">22</span>).setPassword(<span class="string">&quot;334&quot;</span>).setEmail(<span class="string">&quot;nnn@163.com&quot;</span>);</span><br><span class="line">        userService.update(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.在没有使用redis作为缓存类型之前，一般是使用mybatis自带的二级缓存机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在mapper.xml中开启二级缓存</span><br><span class="line"> &lt;!--开启mybatis的二级缓存，也是本地缓存，存在问题就是无法分布式实现缓存，并且每次结束Application都会清空缓存--&gt;</span><br><span class="line">    &lt;cache&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>.原理：首次查询会从数据库查询，然后将数据存储在本地缓存中，其实也就是调用了Cache，再次查询的时候就实现缓存击中，但是每次重启项目或者说重启进程，都将会清空本地的缓存，又会重新从数据库查询，再加入本地缓存，这样效率很低</p>
<p>7.引入redis作为缓存类型，添加type属性，指向自己配置的redis缓存类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--开启mybatis的二级缓存，也是本地缓存，存在问题就是无法分布式实现缓存，并且每次结束Application都会清空缓存，指定type--&gt;</span><br><span class="line">   &lt;cache type&#x3D;&quot;cn.zl.springbootredis.cache.RedisCache&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>8.通过自定义RedisCache，实现Cache中的接口，来实现自定义的Redis缓存功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.zl.springbootredis.util.ApplicationContextUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> sun.awt.SunHints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zhanglang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/7 16:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须存在构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCache</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回cache唯一标识</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在缓存中放入值  redis RedisTemplate StringRedisTemplate</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key: &quot;</span> + key.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;value: &quot;</span> + value);</span><br><span class="line">        <span class="comment">//通过Application工具类获取redisTemplate</span></span><br><span class="line"><span class="comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span></span><br><span class="line"><span class="comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"><span class="comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用redisHash类型作为缓存存储模型  key hashkey value</span></span><br><span class="line">        getRedisTemplate().opsForHash().put(id.toString(),key.toString(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从缓存中获取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key: &quot;</span> + key.toString());</span><br><span class="line">        <span class="comment">//通过Application工具类获取redisTemplate</span></span><br><span class="line"><span class="comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span></span><br><span class="line"><span class="comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"><span class="comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据key 从redis的hash类型中获取数据</span></span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().get(id.toString(), key.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意：此方法为mybatis保留方法，默认没有实现，目前暂未实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;根据指定key删除缓存&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空redis中的缓存</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;清空缓存&quot;</span>);</span><br><span class="line">        <span class="comment">//通过Application工具类获取redisTemplate</span></span><br><span class="line"><span class="comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span></span><br><span class="line"><span class="comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"><span class="comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span></span><br><span class="line">        <span class="comment">//清空namespace</span></span><br><span class="line">        getRedisTemplate().delete(id.toString());<span class="comment">//清空缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过Application工具类获取redisTemplate</span></span><br><span class="line"><span class="comment">//        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(&quot;redisTemplate&quot;);</span></span><br><span class="line"><span class="comment">//        redisTemplate.setKeySerializer(new StringRedisSerializer());</span></span><br><span class="line"><span class="comment">//        redisTemplate.setHashKeySerializer(new StringRedisSerializer());</span></span><br><span class="line">        <span class="comment">//获取hash中key value数量</span></span><br><span class="line">        <span class="keyword">return</span> getRedisTemplate().opsForHash().size(id.toString()).intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装redisTemplate</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisTemplate <span class="title">getRedisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过Application工具类获取redisTemplate</span></span><br><span class="line">        RedisTemplate redisTemplate = (RedisTemplate) ApplicationContextUtils.getBean(<span class="string">&quot;redisTemplate&quot;</span>);</span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        redisTemplate.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：普通的二级缓存通过namespace来实现，具有很大的局限性，而通过redis来实现缓存，数据都存放在redis中，一次添加缓存能使用很久，但是这是单表情况，多表的时候会出问题，</p>
<p>比如一个Student表，一个Class表，通过一个classId关联，在Student的实体类中有一个Class class对象，当我对class表进行修改的时候，清空缓存只会清空class这个对应id的缓存，而student中因为缓存没有清空重新生成，所以class信息还是以前的class信息。</p>
<p>优化方法：使用cache-ref，将缓存放在一个id里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--关联多张表的关系缓存处理，这样就把缓存放入到了同一个id里面，清空缓存的时候会全部清空--&gt;</span><br><span class="line">&lt;cache-ref namespace&#x3D;&quot;cn.zl.springbootredis.entity.Student&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>还有就是设计缓存的优化：</p>
<p>缓存优化策略——-对key的设计简洁化</p>
<p>算法：MD5</p>
<p>特点：a.一切文件字符串等经过md5处理之后，都会生成32位16进制字符串；</p>
<p>b.不同内容文件经过md5进行加密，加密结果一定不一致；</p>
<p>c.相同内容文件多次经过md5生成结果始终一致</p>
<p>直接使用Spring自带的Md5转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zl.springbootredis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.util.DigestUtils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/9/8 9:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKeyMd5</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//利用Spring框架提供的md5工具类</span></span><br><span class="line">       <span class="keyword">return</span> DigestUtils.md5DigestAsHex(key.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后在RedisCache中将key进行修整：</span><br><span class="line">Md5Utils.getKeyMd5(key.toString())</span><br></pre></td></tr></table></figure>

<p>注意：如果使用了哨兵机制，在yml配置文件中，其它配置不变，但是redis的配置需要进行修整，不再是连接具体的redis主机，而是设置监听的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Redis配置</span><br><span class="line">redis:</span><br><span class="line">  sentinel:</span><br><span class="line">    # master是指的在sentinel.conf中书写的监听名称</span><br><span class="line">    master: mymaster</span><br><span class="line">    # 连接的不再是一个具体的redis主机，写的是多个哨兵节点</span><br><span class="line">    nodes: 192.168.139.188:26379</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -cache -mybatis -md5</tag>
      </tags>
  </entry>
  <entry>
    <title>redis在docker中的使用</title>
    <url>/2020/09/12/redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>​          最近闲来无事，公司无活，索性把redis从基本操作到集群操作，全部操作了一遍，Linux是使用VM，ssh工具是使用Xshell7，文件传输是用的Xftp，Linux使用的centos7系统，运行环境是docker，redis可视化软件用的RedisDesktopManager，docker可视化界面用的portainer，宿主机是windows10，编辑器使用的IDEA2020.2，项目使用的Springboot框架，Mysql可视化工具是Navicat，观看的视频来源为<a href="https://www.bilibili.com/video/BV1jD4y1Q7tU" target="_blank">编程不良人</a>，视频中并未使用docker容器，本博客仅仅是用于学习积累，谢谢。</p>
<p>1.centos7的安装由于网上资源众多，且本博客为博主学习积累使用，安装流程鄙人已经十分了然于胸，就不再记录，记得将yum源更新并更换阿里源，否则速度较慢，在此基础上，安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>2.设置docker的阿里镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo </span><br></pre></td></tr></table></figure>

<p>3.安装docker-ce</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure>

<p>4.启动docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>5.在阿里云平台里，搜索容器镜像服务，最下方有一个镜像加速器，用自己的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;xxxxxxxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>6.重载配置，重启docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>7.进行portainer可视化页面拉取，和redis远程</p>
<p>8..docker安装后的默认路径是：/var/lib/docker/</p>
<p>9.拉取运行portainer：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --restart&#x3D;always --name portainer -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v &#x2F;Users&#x2F;lee&#x2F;dev&#x2F;docker_file&#x2F;portainer&#x2F;data:&#x2F;data docker.io&#x2F;portainer&#x2F;portainer</span><br></pre></td></tr></table></figure>

<p>10.页面运行：linux的ip+端口号(9000)</p>
<p>11.拉取最新版redis：docker pull redis</p>
<p>12.在/var/lib/docker/目录下新建redis文件夹</p>
<p>13.在redis文件夹内新建data文件夹</p>
<p>14.从官网下载redis.conf然后导入到redis文件夹下面</p>
<p>15.复制一份redis.conf和data文件夹到/etc/redis/下面(redis文件夹也是自己创建的)，然后修改一下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize no ：yes代表守护进程，但是yes的时候无法外网访问，我用的no</span><br><span class="line">port 6379 ：访问端口，可自己定义，不和外部映射端口冲突就行</span><br><span class="line">bind 127.0.0.1 ：绑定的主机地址，因为我要外网访问，直接注释掉，或者0.0.0.0(代表允许一切客户端连接)</span><br><span class="line">databases 16 ：数据库数量，从0开始，默认16个，1-15，可随意修改，数据库之间互不印象</span><br><span class="line">dir .&#x2F; :指定数据库存放的目录</span><br><span class="line">requirepass foobared ：设置redis连接密码，默认关闭，我没用</span><br><span class="line">appendonly yes ：开启持久化</span><br></pre></td></tr></table></figure>

<p>16.启动redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data -d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>

<p>17.进入交互：docker exec -it  【image id / name】 redis-cli</p>
<p>18.能够进入容器表示成功</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/1.png" alt="1"></p>
<p>19.最后可以在宿主机中使用redis-desktop-manager进行连接，已经成功</p>
<p>注：其中涉及到配置docker的阿里云镜像，还有配置阿里云镜像加速器，都在阿里云平台里面搜索docker镜像加速即可(需登录)</p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -docker -linux</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基本类型之hash</title>
    <url>/2020/09/12/redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8Bhash/</url>
    <content><![CDATA[<p>Redis hash是一个键值对集合<br>Redis hash是一个string类型的key和value的映射表，hash特别适合用于存储对象<br>类是Java里面的Map&lt;String.Object&gt;，常用命令：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hset &lt;key&gt; &lt;field&gt; &lt;value&gt;:给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt;</span><br><span class="line">hget &lt;key1&gt; &lt;field&gt;:从&lt;key1&gt;集合 &lt;field&gt;中取出value</span><br><span class="line">hmset &lt;key1&gt; &lt;field1&gt; &lt;key2&gt; &lt;field2&gt;.。。：批量设置hash值</span><br><span class="line">hexists key &lt;field&gt;:查看哈希表key中，给定域field是否存在</span><br><span class="line">hkeys &lt;key&gt;:列出该hash集合的所有value</span><br><span class="line">hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;:为哈希表key中的域field的值加上增量increment</span><br><span class="line">hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;:将哈希表key中的域field的值设置为value，当且仅当域field不存在</span><br></pre></td></tr></table></figure>

<p>注：存在环境问题的请点击<a href="../redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">redis在docker中的使用</a></p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -hash</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基本类型之list</title>
    <url>/2020/09/12/redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8Blist/</url>
    <content><![CDATA[<p>Redis的list列表，相当于java中的list集合 其特点是元素是有序的，并且允许值重复，常用命令：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lpush &lt;key&gt; &lt;value&gt; ...：将某个值加入到一个key列表的头部,可存放多个value，如果key不存在会自动创建一个key</span><br><span class="line">lpushx &lt;key&gt; &lt;value&gt;...：和lpush命令效果相同，但是它必须要求key是存在的，x其实就是省略了exists单词rpush &lt;key&gt; &lt;value&gt; ...：将某个值加入到一个key列表末尾,与lpush相反</span><br><span class="line">rpushx &lt;key&gt; &lt;value&gt; ...：和lpushx类似</span><br><span class="line">lpop &lt;key&gt;：返回和溢出列表左边的第一个元素</span><br><span class="line">rpop &lt;key&gt;：返回和溢出列表右边的第一个元素</span><br><span class="line">lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;:获取某一个下标区间内的元素</span><br><span class="line">llen &lt;key&gt;：获取列表元素个数</span><br><span class="line">lset &lt;key&gt; &lt;index&gt; &lt;value&gt;：设置某一个指定索引的值(索引必须存在)</span><br><span class="line">lindex &lt;key&gt; &lt;index&gt;：获取某一个指定索引位置的元素</span><br><span class="line">lrem &lt;key&gt; &lt;count&gt; &lt;value&gt;：删除指定重复元素，count为个数</span><br><span class="line">ltrim &lt;key&gt; &lt;start&gt; &lt;stop&gt;：保留列表中特定区间内的元素</span><br><span class="line">linsert &lt;key&gt; &lt;BEFORE|AFTER&gt; &lt;pivot&gt; &lt;value&gt;：在某一个元素之前，之后插入新元素</span><br></pre></td></tr></table></figure>

<p>注：存在环境问题的请点击<a href="../redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">redis在docker中的使用</a></p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -list</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基本类型之string</title>
    <url>/2020/09/12/redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8Bstring/</url>
    <content><![CDATA[<p>​          redis、docker都已经安装成功(没看的朋友可以点击<a href="../redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">redis在docker中的使用</a>)，那么接下来肯定就到里redis的数据类型了，这里先说一说string类型。</p>
<p>​          string字符串是作为Redis最基本的类型，一个key对应一个value，并且string类型是二进制安全的，那么意味着Redis的string可以包含任何数据，比如jpg图片或者序列化的对象，而一个Redis中字符串value的大小最多可以是512M，下列是string的一些常用命令：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &lt;key&gt;:查询对应的键值</span><br><span class="line">set &lt;key&gt; &lt;value&gt;:添加键值对（原本有值的话会覆盖）</span><br><span class="line">append &lt; key&gt; &lt;value&gt;:将给定的&lt;value&gt;追加到原值的末尾</span><br><span class="line">strlen &lt;key&gt;:获取键值的长度</span><br><span class="line">setnx &lt;key&gt; &lt;value&gt;:只有在key不存在时设置key的值</span><br><span class="line">incr &lt;key&gt;:将key中存储的数字值增1，只能对数字值操作，如果为空，新增值为1</span><br><span class="line">decr &lt;key&gt;::将key中存储的数字值减1，只能对数字值操作，如果为空，新增值为-1</span><br><span class="line">incrby&#x2F;decrbu &lt;key&gt; &lt;步长&gt;:将key中存储的数字值增减，自定义步长</span><br><span class="line">incr key：对存储再指定key的数值执行原子的加1操作</span><br><span class="line">mset: &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;...:同时设置一个或多个key-value对</span><br><span class="line">mget: &lt;key1&gt; &lt;key2&gt; &lt;key3&gt;...:同时获取多个value</span><br><span class="line">msetnx：&lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;...:同时设置一个或多个key-value对，当且仅当所有给定的key都不存在</span><br><span class="line">getrange:&lt;key&gt; &lt;起始位置&gt;&lt;结束位置&gt;：获取值的范围，类似java中的substring</span><br><span class="line">setrange &lt;key&gt; &lt;起始位置&gt;&lt;value&gt;:用&lt;value&gt;覆盖&lt;key&gt;锁存贮的字符串值，从&lt;起始位置&gt;开始</span><br><span class="line">setex &lt;key&gt; &lt;过期时间&gt;:设置键值的同时hi，设置过期时间，单位秒</span><br><span class="line">getset &lt;key&gt; &lt;value&gt;:以新换旧，设置了新值同时获得旧值</span><br></pre></td></tr></table></figure>

<p>​          这是一些很常用的命令，由于PigGo上传图片太麻烦，就没有一一上传，只是记载了方法和解释，每个命令都是我写过的，在redis没有问题的情况下，是完全没问题的，可以使用keys * 来查看，或者用宿主机器上的RedisDesktopManager来连接查看。</p>
<p>经典问题：redis是原子性操作吗？</p>
<p>首先原子性的概念：所谓的原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何contextswitch(切换到另一个线程)</p>
<p>1.在单线程中，能够在单条指令中完成的操作都可以认为时原子操作，因为中断只能发生于指令之间<br>2.在多线程中，不能被其它进程（线程）打断的操作就原子操作<br>Redis单命令时原子性主要得益于Redis的单线程<br>java中的i++是否为原子性？<br>答：不是，一共分为三步。取得i值，加1，再放进去，</p>
<p>注：存在环境问题的请点击<a href="../redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">redis在docker中的使用</a></p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -string</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基本类型之zset</title>
    <url>/2020/09/12/redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8Bzset/</url>
    <content><![CDATA[<p>Redis有序集合zset与set非常相似，是一个没有重复元素的字符串集合，不同之处是有序集合的每个成员都关联了一个评分（score），常用命令：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;:将一个或多个member元素及其score值加入到有序集合key当中</span><br><span class="line">zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;:返回有序集key中，下标在&lt;start&gt; &lt;stop&gt;之间的元素，带WITHSCORED，可以让分数一起和值返回到结果集</span><br><span class="line">zrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt;：返回有序集key中，所有的score值介于min和max之间的成员，有序集成员按score值递增次序排列</span><br><span class="line">zreverangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt;：同上，改为递减，从大到小</span><br><span class="line">zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt;:为元素的score加上增量</span><br><span class="line">zrem &lt;key&gt; &lt;value&gt;:删除该集合下，指定值的元素</span><br><span class="line">zcount &lt;key&gt; &lt;value&gt; &lt;min&gt; &lt;max&gt;:统计该集合，分数区间内的元素个数</span><br><span class="line">zrank &lt;key&gt; &lt;value&gt;:返回该值在集合中的排名，从0开始</span><br></pre></td></tr></table></figure>

<p>开发中的小例子：如何利用zset实现一个文章访问量的排行榜？<br>首先新建数据：zadd topn 1000 honglou 2000 xiyou 3000 sanguo按照从大到小排名：zrevrange topn 0 -1 withscores结果：1) “sanguo”2) “3000”3) “xiyou”4) “2000”5) “honglou”6) “1000”</p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -zset</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基本类型之set</title>
    <url>/2020/09/12/redis%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8Bset/</url>
    <content><![CDATA[<p>Redis set对外提供的功能与list类似，是一个列表的功能，1.特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个好的选择，2.并且set提供了判断某个成员是否在一个set集合内的重要接口<br>Redis的set是string类型的无序不可重复的集合，它的底层其实是一个value为null的hash表，所以添加、删除和查找的复杂度都是O(1)，常用命令：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt;... :将一个或多个member元素加入到集合key当中，已经存在于集合的member元素将被忽略</span><br><span class="line">smembers &lt;key&gt; :取出该集合的所有值</span><br><span class="line">sismember &lt;key&gt; &lt;value&gt;:判断集合&lt;key&gt;是否为含有该&lt;value&gt;值。有则返回1，没有返回0</span><br><span class="line">scard &lt;key&gt;:返回该集合的元素个数</span><br><span class="line">srem &lt;key&gt; &lt;value1&gt; &lt;value1&gt;:删除该集合种某个元素</span><br><span class="line">spop &lt;key&gt;:随机从该集合种吐出一个值</span><br><span class="line">srandmember &lt;key&gt; &lt;n&gt;:随机从该集合种取出n个值，不会从集合种删除</span><br><span class="line">sinter &lt;key1&gt; &lt;key1&gt;:返回两个集合的交集元素</span><br><span class="line">sunion &lt;key1&gt; &lt;key1&gt;:返回两个集合的并集元素</span><br><span class="line">sdiff &lt;key1&gt; &lt;key1&gt;:返回两个集合的差集元素（最后取前面集合剩下的）</span><br></pre></td></tr></table></figure>

<p>注：存在环境问题的请点击<a href="../redis%E5%9C%A8docker%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">redis在docker中的使用</a></p>
]]></content>
      <categories>
        <category>-redis</category>
      </categories>
      <tags>
        <tag>-redis -set</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器部署jpress-一-阿里云服务器配置</title>
    <url>/2020/11/02/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%B8%80-%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>和朋友闲聊的时候，刚好马上双十一，说他要买云服务器，我一想，这有必要吗，买个云服务器还是安装linux系统，和虚拟机没啥区别呀，我给他说死也不会用云服务器(没钱买)，然后他说可以试用一个月，嗯？其实还是可以试试的，刚好我觉得可能还没有虚拟机好用呢(真香),然后就想尝试一下云服务器部署，找了一个开源的jpress项目，开搞。</p>
<a id="more"></a>

<p>购买我就不多说了，不可能作为it行业的人，连在一个中文网站购买商品的能力都没有，我没有购买，是因为我习惯使用虚拟机(呸，臭男人，你就是没钱)，反正我就是领的试用一个月，目前双十一，挺便宜的，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/11.1.png" alt="11.1"></p>
<p>1.点击更多，有一个“网络和安全组”，再点击“安全组配置”，这里面涉及到外面的访问端口，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/11.2.png" alt="11.2"></p>
<p>2.进入后点击实例名称，进入规制页面，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/11.3.png" alt="11.3"></p>
<p>3.这里面就是需要的一些端口号，建议使用快速添加，其他都不用更改，只需要添加个人需要的端口就好，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/11.4.png" alt="11.4"></p>
<p>4.然后回到实例页面，点击远程连接，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/11.5.png" alt="11.5"></p>
<p>6.使用VNC远程连接，进去后就会要求你输入密码，这就是你创建实例的时候让你设置的(自己购买或者使用的应该都知道),</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/11.6.png" alt="11.6"></p>
<p>7.这就进入了linux页面，当然你也可以更管系统，也在更多里面，一般来说我都是使用Xshell来进行连接和执行一些操作的，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/11.7.png" alt="11.7"></p>
<p>总结，没什么难度，信息社会的今天，就是一个购买商品然后使用商品的过程，不要想的那么复杂，接下来，就可以在云服务器上”为所欲为”了(手动狗头)，然后我就测试一下部署jpress开源博客系统到云服务器吧。</p>
]]></content>
      <categories>
        <category>-云服务器</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器部署jpress-二-阿里云安装mysql</title>
    <url>/2020/11/02/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%BA%8C-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<p>服务器已经购买(试用)好了，并且能够成功远程连接成功了，如果还有问题，请参看：</p>
<a id="more"></a>

<p><a href="../%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%B8%80-%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/index.html">云服务器部署jpress-一-阿里云服务器配置</a></p>
<p>，还有就是java环境需要安装，如果不会的请参看：</p>
<p><a href="../Linux%E5%BF%AB%E6%8D%B7%E5%AE%89%E8%A3%85jdk/index.html">Linux快捷安装jdk</a></p>
<p>1.首先检查是否安装了mysql，如果没有打印信息则表示没有，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br><span class="line">或</span><br><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure>

<p>2.安装mysql，我安装的mysql8，下载安装包，然后再执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>3.开始安装，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y mysql-server</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.1.png" alt="8.1"></p>
<p>4.查看服务开机启动状态，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files | grep mysqld</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.2.png" alt="8.2"></p>
<p>5.设置开机启动，执行命令，再查看一下状态，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable mysqld.service</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.3.png" alt="8.3"></p>
<p>6.然后可能有的版本需要查看初始密码，但是我是安装的mysql8，初始密码是为空的，可以进入”/var/log/mysql/mysqld.log”文件查看，可以看到是empty password，当然其他版本会有密码，也是在这里查看，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.4.png" alt="8.4"></p>
<p>7.登录mysql，输入密码的位置直接回车就好，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<p>8.修改密码，先执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure>

<p>再执行mysql8版本修改密码的命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;八位密码&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.5.png" alt="8.5"></p>
<p>9.开启远程访问，也就是让root账号的host变为’%’，先查看权限，输入命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select host,user,plugin from user; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.6.png" alt="8.6"><br>10.修改权限后再查看，输入命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set host &#x3D; &#39;%&#39; where user &#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.7.png" alt="8.7"></p>
<p>11.可以看到修改成功，最后也是最重要的一步，我开始就忘了，刷新修改，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.8.png" alt="8.8"></p>
<p>12.这时候当然是用本地可视化工具远程连接一下，看是否成功，我是用的navicat，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/8.9.png" alt="8.9"></p>
<p>总结，没得问题，其实我用过很多次虚拟机了，这次是因为第一次用云服务器，顺便学习一下云服务器部署项目，然后再安装tomcat。</p>
]]></content>
      <categories>
        <category>-云服务器</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器部署jpress-三-阿里云安装tomcat</title>
    <url>/2020/11/02/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%B8%89-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85tomcat/</url>
    <content><![CDATA[<p>到目前为止，服务器OK，mysql也是没问题，如果你还有问题请参看：</p>
<a id="more"></a>

<p><a href="../%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%B8%80-%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/index.html">云服务器部署jpress-一-阿里云服务器配置</a></p>
<p><a href="../%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%BA%8C-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85mysql/index.html">云服务器部署jpress-二-阿里云安装mysql</a></p>
<p>1.下载tomcat，我是使用的tomcat9，为了方便自己以后，所以我提供了百度云链接，</p>
<p>链接：<a href="https://pan.baidu.com/s/1cM3qyCZR0AC3DW4z7jKSGQ">https://pan.baidu.com/s/1cM3qyCZR0AC3DW4z7jKSGQ</a><br>提取码：d48v<br>2.使用xftp将压缩包传输到linux系统中，我是放在/home/tomcat/目录下的，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/9.1.png" alt="9.1"></p>
<p>3.解压tomcat，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar –xzvf apache-tomcat-8.0.29.tar.gz</span><br></pre></td></tr></table></figure>

<p>4.等待解压完成，可以使用ll查看目录，已经有一个文件夹，可以改名一下，还有就是可以选择进入/conf/server.xml文件,将8080改为80，80会被服务器自动省略，就可以用ip访问了，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/9.2.png" alt="9.2"></p>
<p>5.然后进入bin目录，启动tomcat，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;startup.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/9.3.png" alt="9.3"></p>
<p>6.可以看到已经启动成功，然后在浏览器中，使用云服务器的公网ip进行访问，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/9.4.png" alt="9.4"></p>
<p>总结，现在基本使用Springboot项目，所以配置tomcat的机会少了很多，一般都是部署项目的时候使用，这个还是很有必要掌握一下。</p>
]]></content>
      <categories>
        <category>-云服务器</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器部署jpress-四-部署jpress</title>
    <url>/2020/11/02/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E5%9B%9B-%E9%83%A8%E7%BD%B2jpress/</url>
    <content><![CDATA[<p>服务器OK，mysql没毛病，tomcat也启动访问成功，如果还有问题请参看：</p>
<a id="more"></a>

<p><a href="../%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%B8%80-%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/index.html">云服务器部署jpress-一-阿里云服务器配置</a></p>
<p><a href="../%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%BA%8C-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85mysql/index.html">云服务器部署jpress-二-阿里云安装mysql</a></p>
<p><a href="../%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2jpress-%E4%B8%89-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85tomcat/index.html">云服务器部署jpress-三-阿里云安装tomcat</a></p>
<p>1.首先是下载jpress的war包，可以去<a href="https://http://jpress.io/download" target="_blank">jpress官网</a>，下载，我这里也提供了我是用的war包版本，</p>
<p>链接：<a href="https://pan.baidu.com/s/1MWzICLOq5fFDZ_HaAL-pGg">https://pan.baidu.com/s/1MWzICLOq5fFDZ_HaAL-pGg</a><br>提取码：1w02<br>2.照例将jpress的war包使用Xftp传输到tomcat的webapps目录下面，不用解压，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/10.1.png" alt="10.1"></p>
<p>3.重新启动tomcat，会自动解压，保证数据库能够连接上，不用创建数据库，因为jpress可以自动为你创建，重启后运行tomcat，在浏览器上访问ip/你的war包名，运行成功会进入这个页面，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/10.2.png" alt="10.2"></p>
<p>4.以此下一步，填写，一直到成功，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/10.3.png" alt="10.3"></p>
<p>5.使用注册的超级账号登录后台(注意如果不是第一次登录，后续到后台管理，就在路径后面加一个admin),</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/10.4.png" alt="10.4"></p>
<p>6.编写文章，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/10.5.png" alt="10.5"></p>
<p>7.发布后，可点击左上角跳转到网站上看效果，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/10.6.png" alt="10.6"></p>
<p>总结，jpress开源博客系统就部署成功了，总的来说，难度不高，是一次很好的部署项目到云服务器的经历，有何不懂的，可以留言，有问题也请指出，鄙人也是第一次做，难免有问题，最后我想说云服务器真挺香的，啥都不用管，随时使用，也不用配置什么，也不占用内存，一个ssh连接就用，害，有钱我也卖了。</p>
]]></content>
      <categories>
        <category>-云服务器</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Jpress</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式总结</title>
    <url>/2021/01/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>要点：     </p>
<p>1.是某个类只能有一个实例， 构造器私有化  </p>
<p>2.是它必须自行创建这个实例，含有一个该类的静态变量来保存这个唯一的实例  </p>
<p>3.是它必须自行向整个系统提供这个实例，对外提供获取该实例对象的方式：直接暴露、用静态变量的get方法获取</p>
<a id="more"></a>

<p>常见形式：       </p>
<p>饿汉式：直接创建对象，不存在线程安全问题   </p>
<p>懒汉式：延迟创建对象，用的时候创建</p>
<p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;懒汉式-线程安全的懒汉式，可以在静态方法后面加synchronized关键字加锁变为安全</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">    &#x2F;&#x2F;将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">    private static Singleton instance；</span><br><span class="line">  &#x2F;&#x2F;构造方法私有化</span><br><span class="line">  private Singleton()&#123; &#125;</span><br><span class="line">  &#x2F;&#x2F;静态方法返回该实例</span><br><span class="line">  public static (synchronized) Singleton getInstance()&#123;</span><br><span class="line">    if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">        instance&#x3D;new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    return instane;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;饿汉式</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">            &#x2F;&#x2F;直接创建对象</span><br><span class="line">            private static Singleton instance&#x3D;new Singleton()；</span><br><span class="line">            &#x2F;&#x2F;构造方法私有化</span><br><span class="line">            private Singleton()&#123;  &#125;</span><br><span class="line">            &#x2F;&#x2F;静态方法返回该实例</span><br><span class="line">            public static Singleton getInstance()&#123;</span><br><span class="line">              return instance;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态内部类</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">             private static class SingletonHolder&#123;</span><br><span class="line">             private static final Singleton INSTANCE&#x3D;new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">             private Singleton()&#123; &#125;</span><br><span class="line">             private static final Singleton getInstance()&#123;</span><br><span class="line">             return SingletonHolder.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;枚举</span><br><span class="line">public enum Singleton&#123;</span><br><span class="line">             INSTANCE;</span><br><span class="line">             public void whateverMethod()&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;双重校验锁</span><br><span class="line">public class Singleton&#123;</span><br><span class="line">             &#x2F;&#x2F;将自身实例化对象设置为一个属性，并用static修饰</span><br><span class="line">             private static Singleton instance;</span><br><span class="line">             &#x2F;&#x2F;构造方法私有化</span><br><span class="line">             private Singleton()&#123;&#125;</span><br><span class="line">             &#x2F;&#x2F;静态方法返回该实例</span><br><span class="line">             public static Singleton getInstance()&#123;</span><br><span class="line">             &#x2F;&#x2F; 第一次检查instance是否被实例化出来，如果没有进入if块</span><br><span class="line">             if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    synchronized(Singleton.class)&#123;</span><br><span class="line">                      &#x2F;&#x2F; 某个线程取得了类锁，实例化对象前第二次检查instance是否已经被实例化出来，如果没有，才最终实例出对象</span><br><span class="line">                     if(instance&#x3D;&#x3D;null)&#123;</span><br><span class="line">                        instance&#x3D;new Singleton();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">             &#125;</span><br><span class="line">               return instance;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-一-阿里云服务器搭建CAS</title>
    <url>/2020/11/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%B8%80-%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACAS/</url>
    <content><![CDATA[<p>有了云服务器，我是真的就停不下来，啥都想学，啥都想干，这不，单点登录它来了，结合云服务器进行一次单点登录的实现，如果不知道啥是单点登录的，百度百科欢迎你，其实就是多个系统一次登录，就像我最近报名考研，我登录了研招网，然后报名是单独一个系统我就不用登录可以直接使用接口功能，然后又需要到学信网进行学历校验，直接跳转，也不需要登录，不知道能不能理解，简单来说就是相互信任的系统一次登录，开整！</p>
<a id="more"></a>

<p>1.下载CAS到本地，可以去官网<a href="https://github.com/apereo/cas/releases/tag/v4.0.0" target="_blank">Github上下载</a>，我这里也为自己提供了4.0.0的版本，</p>
<p>链接：<a href="https://pan.baidu.com/s/1gTkIH5rja2Y5Wl3jrMIuWA">https://pan.baidu.com/s/1gTkIH5rja2Y5Wl3jrMIuWA</a><br>提取码：4uhi </p>
<p>2.下载完成后，解压，进入cas-server-4.0.0\modules的目录下，有一个cas-server-webapp-4.0.0.war的包，通过Xftp传输到云服务中，上次部署Jpress已经有一个tomcat了，我是直接复制了一份到cas文件夹下(自己建的)，然后将war放在tomcat的webapps下面，然后启动tomcat，基本命令不会忘记了吧，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;startup.sh  :启动tomcat</span><br><span class="line">.&#x2F;shutdown.sh  :停止tomcat</span><br><span class="line">ps -ef | grep tomcat  :查看正在运行的tomcat</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/13.1.png" alt="13.1"></p>
<p>这里有一个问题需要提一下，就是tomcat的端口问题，两个tomcat端口一定不能重复</p>
<p>3.然后直接外网访问，用户名是casuser，初始密码是Mellon，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/13.2.png" alt="13.2"></p>
<p>4.可以看到已经运行成功，这就算是cas的服务器，另外这里需要注意的是，两个tomcat的端口一定不能重复，不只是外网访问的端口，还有shutdown的端口，我这里是都能访问的，给看一下部署的Jpress，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/13.3.png" alt="13.3"></p>
<p>总结，人有了贪欲，突然想买云服务器了，好方便啊，啊啊！明明我可以很快乐，都是没钱害了我。</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-三-阿里云安装Docker和Redis</title>
    <url>/2020/11/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%B8%89-%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85Docker%E5%92%8CRedis/</url>
    <content><![CDATA[<p>然后需要安装一下Redis，其实可以不用docker，个人爱好，其实这里和普通centos系统安装几乎一模一样，只有细微的区别，centos7安装docker和redis请参看：</p>
<a id="more"></a>

<p>1.安装Docker存储驱动的依赖包,执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>2.添加稳定的Docker软件源，其实也就是阿里云的，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum config-manager --add-repo&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>3.安装Docker，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install -y docker-ce --nobest</span><br></pre></td></tr></table></figure>

<p>这里遇到了一个坑，但是我记录了一下如何解决的，忘记了截图看看错，如果这里报错，就是少了一个包，执行命令安装就好了，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;fedora&#x2F;30&#x2F;x86_64&#x2F;stable&#x2F;Packages&#x2F;containerd.io-1.2.6-3.3.fc30.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>4.启动docker，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>5.设置Docker开机启动，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>6.然后，是不是一顿折腾，可能还有错，来了，给力的脚本，执行直接搞定，执行命令，安装结束，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/17.1.png" alt="17.1"></p>
<p>7.在阿里云平台里，搜索容器镜像服务，最下方有一个镜像加速器，用自己的，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;xxxxxxxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>8.重载配置，重启docker，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>9.拉取最新版redis：docker pull redis</p>
<p>10.在/var/lib/docker/目录下新建redis文件夹</p>
<p>11.在redis文件夹内新建data文件夹</p>
<p>12.从官网下载redis.conf然后导入到redis文件夹下面</p>
<p>13.复制一份redis.conf和data文件夹到/etc/redis/下面(redis文件夹也是自己创建的)，然后修改一下配置，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize no ：yes代表守护进程，但是yes的时候无法外网访问，我用的no</span><br><span class="line">port 6379 ：访问端口，可自己定义，不和外部映射端口冲突就行</span><br><span class="line">bind 127.0.0.1 ：绑定的主机地址，因为我要外网访问，直接注释掉，或者0.0.0.0(代表允许一切客户端连接)</span><br><span class="line">databases 16 ：数据库数量，从0开始，默认16个，1-15，可随意修改，数据库之间互不印象</span><br><span class="line">dir .&#x2F; :指定数据库存放的目录</span><br><span class="line">requirepass foobared ：设置redis连接密码，默认关闭，我没用</span><br><span class="line">appendonly yes ：开启持久化</span><br></pre></td></tr></table></figure>

<p>14.启动redis，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf -v &#x2F;var&#x2F;lib&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data -d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>

<p>15.使用命令查看镜像和实例，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/17.2.png" alt="17.2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/17.3.png" alt="17.3"></p>
<p>16.最后使用Windows上的Redis的可视化工具连接测试一下，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/17.4.png" alt="17.4"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/17.5.png" alt="17.5"></p>
<p>17.因为默认启动的实例是没有密码的，所以需要手动设置，首先执行命令进入容器，再进入客户端，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it redis &#x2F;bin&#x2F;bash</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123122756317.png" alt="image-20201123122756317"></p>
<p>18.查看是否配置密码，再设置密码，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config get requirepass</span><br><span class="line">config set requirepass xxxxxx</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123122911384.png" alt="image-20201123122911384"></p>
<p>19.使用可视化工具测试连接，分别展示没有密码和有密码的情况，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123123023896.png" alt="image-20201123123023896"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201123123048184.png" alt="image-20201123123048184"></p>
<p>总结，其实和我的另一篇差不多一样，但是可能是为了让我一个月阿里云服务器试用的存在感强一些，也是为了记录单点登录整个流程，当有需要的时候，可以直接全文浏览复制后就能跑起来，还是记录了一波。</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Docker -Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-七-模块System-a</title>
    <url>/2020/11/29/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%B8%83-%E6%A8%A1%E5%9D%97System-a/</url>
    <content><![CDATA[<p>害，Sso-server模块的认证中心已经完成，我自己逻辑很清晰，但是我感觉写的有点乱，但是别慌，我后面会提供完整的源码，Sso-server模块不懂的请参看：</p>
<a id="more"></a>

<p><a href="../%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E5%85%AD-%E6%A8%A1%E5%9D%97Sso-server/index.html">单点登录-六-模块Sso-server</a></p>
<p>1.编写System-a模块，一个登录页面，同样放在templates下面，展示一下用户和唯一标识，真实需求会将ticket隐藏，并对cookie中的信息进行加密处理，后台再接密，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//layui.hcwl520.com.cn/layui/css/layui.css?v=201811010202&quot;</span>  <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;padding: 20px; background-color: #F2F2F2;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-row layui-col-space15&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-col-md12&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-card&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-card-header&quot;</span>&gt;</span>系统A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-card-body&quot;</span>&gt;</span></span><br><span class="line">                    用户：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;userInfo.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>登录成功<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                    ticket：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;userInfo.ticket&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;layui-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-item&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-input-block&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layui-btn&quot;</span> <span class="attr">lay-submit</span>=<span class="string">&quot;&quot;</span> &gt;</span>退出登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//layui.hcwl520.com.cn/layui/layui.js?v=201811010202&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.编写控制器，由于是从session中获取，所以不需要业务层，直接获取就可以，我还写了一个退出请求，退出的时候同步清楚cookie就可以了，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:控制器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 10:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">goHome</span><span class="params">(HttpSession session, Model model,HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取数据，跳转页面，说实话，很久没写过跳转页面了，都是返回json数据</span></span><br><span class="line">        Object userInfo = session.getAttribute(<span class="string">&quot;userInfo&quot;</span>);</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;userInfo&quot;</span>,session.getAttribute(<span class="string">&quot;userInfo&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取ticket</span></span><br><span class="line">        String ticket = SsoCookieUtil.getCookie(request,<span class="string">&quot;ticket&quot;</span>);</span><br><span class="line">        <span class="comment">//请求sso-server退出登录</span></span><br><span class="line">        <span class="keyword">boolean</span> isLogout = restTemplate.getForObject(ServerConstant.SSO_URL+<span class="string">&quot;logout?ticket=&quot;</span>+ticket,Boolean.class);</span><br><span class="line">        <span class="keyword">if</span>(isLogout)&#123;</span><br><span class="line">            <span class="comment">//清除cookie</span></span><br><span class="line">            SsoCookieUtil.setCookie(response,<span class="string">&quot;ticket&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户已登出&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登出失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.这里需要主义的是，必须写一下restTemplate的配置类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 13:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(RestTemplateBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先获取到converter列表</span></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; converters = builder.build().getMessageConverters();</span><br><span class="line">        <span class="keyword">for</span>(HttpMessageConverter&lt;?&gt; converter : converters)&#123;</span><br><span class="line">            <span class="comment">//因为我们只想要jsonConverter支持对text/html的解析</span></span><br><span class="line">            <span class="keyword">if</span>(converter <span class="keyword">instanceof</span> MappingJackson2HttpMessageConverter)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">//先将原先支持的MediaType列表拷出</span></span><br><span class="line">                    List&lt;MediaType&gt; mediaTypeList = <span class="keyword">new</span> ArrayList&lt;&gt;(converter.getSupportedMediaTypes());</span><br><span class="line">                    <span class="comment">//加入对text/html的支持</span></span><br><span class="line">                    mediaTypeList.add(MediaType.TEXT_HTML);</span><br><span class="line">                    mediaTypeList.add(MediaType.APPLICATION_JSON);</span><br><span class="line">                    mediaTypeList.add(MediaType.valueOf(MediaType.APPLICATION_JSON_VALUE));</span><br><span class="line">                    <span class="comment">//将已经加入了text/html的MediaType支持列表设置为其支持的媒体类型列表</span></span><br><span class="line">                    ((MappingJackson2HttpMessageConverter) converter).setSupportedMediaTypes(mediaTypeList);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.最重要的一步，就是编写拦截器，将请求全部拦截，然后转发到拦截类里面，new LoginInterceptor()则是刚刚写的预处理，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:拦截器配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/6 14:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所要拦截的请求路径</span></span><br><span class="line">    String[] addPathPatterns = &#123;</span><br><span class="line">            <span class="string">&quot;/**&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要拦截的请求路径</span></span><br><span class="line">    String[] excludePathPatterns = &#123;</span><br><span class="line">            <span class="string">&quot;/user/error&quot;</span>,<span class="string">&quot;/user/out&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor()).addPathPatterns(addPathPatterns).excludePathPatterns(excludePathPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>到这里A系统就完成，就一个从session中获取用户信息的控制器，一个登录成功返回的页面，一个拦截器和一个restTeplate配置类，测试将在后面操作，</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Docker -nacos -System-a</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-九-单点登录功能测试</title>
    <url>/2020/11/29/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%B9%9D-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Sso-server模块、System-a、System-b模块都完成了，还有疑问的请参看：</p>
<a id="more"></a>

<p><a href="../%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E5%85%AD-%E6%A8%A1%E5%9D%97Sso-server/index.html">单点登录-六-模块Sso-server</a></p>
<p><a href="../%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%B8%83-%E6%A8%A1%E5%9D%97System-a/index.html">单点登录-七-模块System-a</a></p>
<p><a href="../%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E5%85%AB-%E6%A8%A1%E5%9D%97System-b.html">单点登录-八-模块System-b</a></p>
<p>1.首先，使用redis可视化工具保证redis的0号库没有任何数据，然后启动多个服务，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128153726603.png" alt="image-20201128153726603"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128153932621.png" alt="image-20201128153932621"></p>
<p>2.为了跨域，修改host，默认Windows路径是C:\Windows\System32\drivers\etc，配置三个域名，我是使用了SwitchHost工具，记得以管理呀身份运行，无论是用软件还是修改本地，软件可以直接<a href="https://www.electronjs.org/apps/switchhosts" target="_blank">switchhosts官网</a>下载，这里我就不提供了，是免费的，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128154523388.png" alt="image-20201128154523388"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128154351971.png" alt="image-20201128154351971"></p>
<p>3.运行路径，直接浏览器输入aa.test.com:9085/home，由于我上传不了视频，就没法演示这个变化了，输入路径后会自动跳转到登录页面，uuid就是根据预处理里面写的获取的session的id，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128154733475.png" alt="image-20201128154733475"></p>
<p>4.随便输入什么，只要用户名和密码一致就行，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128154835138.png" alt="image-20201128154835138"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128154855944.png" alt="image-20201128154855944"></p>
<p>5.查看redis，是否生成了ticket，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128154924011.png" alt="image-20201128154924011"></p>
<p>6.登录b系统，也是在浏览器输入bb.test.com:9085/home，这里就不会进行跳转，而是直接后台验证，验证通过，直接返回页面，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128155151021.png" alt="image-20201128155151021"></p>
<p>7.对比两图，可以看出JSESSIONID的值是不同的，而A系统的uuid就是JSESSIONID，而b系统的uuid，ticket和A系统是相同的，这就简单实现了单点登录，</p>
<p>8.随便在哪个系统点击退出登录，然后马上看redis，可以看到数据已经被清空，再查看a系统的页面，一刷新又跳转到了登录页面，因为ticket已经为null，所以又开始走重定向路径，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128155923388.png" alt="image-20201128155923388"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128155939151.png" alt="image-20201128155939151"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128160011045.png" alt="image-20201128160011045"></p>
<p>9.基本完成那就开始考虑安全问题，虽然我验证的时候已经考虑了，其实在checkTicket接口是做了安全措施，就是每次验证就删除旧的ticket，生成新的ticket，并且按理说cookie只是保存当前浏览器，其他地方是不一样的，但是不可否认有的人就是可以获取到，那么就需要对cookie加密，我觉得只对ticket加密即可，这里提供一下，在保存ticket到cookie的时候加密，在获取cookie中的ticket时候解密，这是来源网上的AES方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:加密工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SALT = <span class="string">&quot;1io10fdgadfjvower389fhday29834aguourfwpg0w82dllfkfadf&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AES_SALT = <span class="string">&quot;g^&amp;*g%^F766R&amp;PIpGY&amp;%yg%yt$^RyfU&amp;UT*ugyTR^R^uf&amp;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 明文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalBlockSizeException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">AESEncode</span><span class="params">(String content)</span> <span class="keyword">throws</span> IllegalBlockSizeException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyGenerator keygen = KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            keygen.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(AES_SALT.getBytes()));</span><br><span class="line">            SecretKey original_key = keygen.generateKey();</span><br><span class="line">            <span class="keyword">byte</span>[] raw = original_key.getEncoded();</span><br><span class="line">            SecretKey key = <span class="keyword">new</span> SecretKeySpec(raw, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">            <span class="keyword">byte</span>[] byte_encode = content.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] byte_AES = cipher.doFinal(byte_encode);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BASE64Encoder().encode(byte_AES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | BadPaddingException | UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 明文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">AESDecode</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyGenerator keygen = KeyGenerator.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            keygen.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(AES_SALT.getBytes()));</span><br><span class="line">            SecretKey original_key = keygen.generateKey();</span><br><span class="line">            <span class="keyword">byte</span>[] raw = original_key.getEncoded();</span><br><span class="line">            SecretKey key = <span class="keyword">new</span> SecretKeySpec(raw, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">            <span class="keyword">byte</span>[] byte_content = <span class="keyword">new</span> BASE64Decoder().decodeBuffer(content);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] byte_decode = cipher.doFinal(byte_content);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(byte_decode, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | IOException | BadPaddingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.由于感觉写的有点乱，给一下项目的git地址，有问题可以留言，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;zllwsy&#x2F;Commont&#x2F;tree&#x2F;master&#x2F;Springboot-sso</span><br></pre></td></tr></table></figure>

<p>11.有细心的可以发现，其实还有个模块没有使用，那就是System-gateway，其实我本身是用了，但是发现我就一个请求，完全用不着，给一下yml配置文件，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9087</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">xxx.xxx.xxx.xxx:8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">5ced42ff-fe7d-418e-8aab-1c3e0bcaf487</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 路由（routes：路由，它由唯一标识（ID）、目标服务地址（uri）、一组断言（predicates）和一组过滤器组成（filters）。filters 不是必需参数。）</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="comment"># 是否和服务注册与发现组件结合，设置为 true 后可以直接使用应用名称调用服务</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment"># 路由标识（id：标识，具有唯一性）   简单尝试</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">route_a</span></span><br><span class="line">          <span class="comment"># 目标服务地址（uri：地址，请求转发后的地址）</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://aa.test.com:9085</span></span><br><span class="line">          <span class="comment"># 路由条件（predicates：断言，匹配 HTTP 请求内容）</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="comment">## 转发地址格式为 uri/archive</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/home</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">System-gateway</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>12.也可以在启动器里面添加一个配置的bean，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.routes()</span><br><span class="line">            <span class="comment">//basic proxy</span></span><br><span class="line">            .route(r -&gt; r.path(<span class="string">&quot;/home&quot;</span>)</span><br><span class="line">                    .uri(<span class="string">&quot;https://aa.test.com:9085&quot;</span>)</span><br><span class="line">            ).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.顺便提供一下Springcloud gateway的官方文档的地址路径，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cloud.spring.io&#x2F;spring-cloud-static&#x2F;spring-cloud-gateway&#x2F;2.2.1.RELEASE&#x2F;reference&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>单点登录完成，有点瑕疵，勉强完成，还是自己的底蕴太差，很多考虑不周全，如果后面有时间我会更新单点登录，使用CAS来做一做，有问题还请各位大佬提出，小弟在此感谢了。</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Docker -nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-二-CAS配置修改</title>
    <url>/2020/11/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%BA%8C-CAS%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>上一篇已经安装并访问成功，这里需要对配置进行一些修改，必须登录的账户密码等等，上一篇安装请参看：</p>
<a id="more"></a>

<p><a href="../%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%B8%80-%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BACAS/index.html">单点登录-一-阿里云服务器搭建CAS</a></p>
<p>1.首先先给CAS服务中心添加一个自己的账户，先找到cas的那个tomcat，进入tomcatCas\webapps\cas\WEB-INF目录，修改deployerConfigContext.xml文件，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi deployerConfigContext.xml</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.1.png" alt="14.1"></p>
<p>2.在bean id为primaryAuthenticationHandler的下面加入自己的map键值对，因为https认证是收费的，所以去除掉，在bean id为proxyAuthenticationHandler的下面添加一个配置请求p:requireSecure=”false”，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.2.png" alt="14.2"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.3.png" alt="14.3"></p>
<p>3.修改cas.properties文件，将端口号改为和tomcat一致，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi cas.properties</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.4.png" alt="14.4"></p>
<p>4.进入tomcatCas/webapps/cas/WEB-INF/spring-configuration目录，修改配置文件，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ticketGrantingTicketCookieGenerator.xml</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.5.png" alt="14.5"></p>
<p>5.在bean id 为ticketGrantingTicketCookieGenerator下面，将p:cookieSecure=”true”的值改为false，将p:cookieMaxAge=”-1”的值改为3600，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.6.png" alt="14.6"></p>
<p>6.同目录下，修改warnCookieGenerator.xml，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi warnCookieGenerator.xml</span><br></pre></td></tr></table></figure>

<p>7.在bean id 为warnCookieGenerator下面，将p:cookieSecure=”true”的值改为false，将p:cookieMaxAge=”-1”的值改为3600，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.7.png" alt="14.7"></p>
<p>8.重新启动tomcat，然后使用刚刚自己设置的账号密码登录，登录成功，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/14.8.png" alt="14.8"></p>
<p>总结，我开始是打算试用CAS作为认证中心的，但是，朋友告诉我，你既然打算学单点登录，肯定要先试试自己实现而不是试用框架呀，我就想说框架不就是拿来简化开发的吗，他给我了灵魂一击：自己搭建不仅理解很深，后面用框架也更简单。好吧，所以我打算使用Springboot+Redis来搭建单点登录，等完成后，如果有空再来尝试一下CAS。</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-八-模块System-b</title>
    <url>/2020/11/29/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E5%85%AB-%E6%A8%A1%E5%9D%97System-b/</url>
    <content><![CDATA[<p>系统A已经完成了，系统B其实没什么差别，主要的逻辑都已经在Sso-server模块中完成，如果还有所不懂请参看文档：</p>
<a id="more"></a>

<p><a href="../%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E5%85%AD-%E6%A8%A1%E5%9D%97Sso-server/index.html">单点登录-六-模块Sso-server</a></p>
<p><a href="../%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%B8%83-%E6%A8%A1%E5%9D%97System-a/index.html">单点登录-七-模块System-a</a></p>
<p>1.确实相差不多，给一下源码即可，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//layui.hcwl520.com.cn/layui/css/layui.css?v=201811010202&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;padding: 20px; background-color: #F2F2F2;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-row layui-col-space15&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-col-md12&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-card&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-card-header&quot;</span>&gt;</span>系统B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-card-body&quot;</span>&gt;</span></span><br><span class="line">                    用户：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;userInfo.userName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>登录成功<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                    ticket：<span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;userInfo.ticket&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;layui-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-item&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-input-block&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layui-btn&quot;</span> <span class="attr">lay-submit</span>=<span class="string">&quot;&quot;</span> &gt;</span>退出登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//layui.hcwl520.com.cn/layui/layui.js?v=201811010202&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.控制器，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/9 11:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">goHome</span><span class="params">(HttpSession session, Model model, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        Object userInfo = session.getAttribute(<span class="string">&quot;userInfo&quot;</span>);</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;userInfo&quot;</span>,session.getAttribute(<span class="string">&quot;userInfo&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取ticket</span></span><br><span class="line">        String ticket = SsoCookieUtil.getCookie(request,<span class="string">&quot;ticket&quot;</span>);</span><br><span class="line">        <span class="comment">//请求sso-server退出登录</span></span><br><span class="line">        <span class="keyword">boolean</span> isLogout = restTemplate.getForObject(ServerConstant.SSO_URL+<span class="string">&quot;logout?ticket=&quot;</span>+ticket,Boolean.class);</span><br><span class="line">        <span class="keyword">if</span>(isLogout)&#123;</span><br><span class="line">            <span class="comment">//清除cookie</span></span><br><span class="line">            SsoCookieUtil.setCookie(response,<span class="string">&quot;ticket&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户已登出&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登出失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.restTemplate配置类，我也想A的配置类，但是着实实现不了，只能再写一次了，其实A和B系统都只用退出登录需要用到，需要嫌麻烦，可以不写退出，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/9 11:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">goHome</span><span class="params">(HttpSession session, Model model, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        Object userInfo = session.getAttribute(<span class="string">&quot;userInfo&quot;</span>);</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;userInfo&quot;</span>,session.getAttribute(<span class="string">&quot;userInfo&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取ticket</span></span><br><span class="line">        String ticket = SsoCookieUtil.getCookie(request,<span class="string">&quot;ticket&quot;</span>);</span><br><span class="line">        <span class="comment">//请求sso-server退出登录</span></span><br><span class="line">        <span class="keyword">boolean</span> isLogout = restTemplate.getForObject(ServerConstant.SSO_URL+<span class="string">&quot;logout?ticket=&quot;</span>+ticket,Boolean.class);</span><br><span class="line">        <span class="keyword">if</span>(isLogout)&#123;</span><br><span class="line">            <span class="comment">//清除cookie</span></span><br><span class="line">            SsoCookieUtil.setCookie(response,<span class="string">&quot;ticket&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;用户已登出&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登出失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.拦截器配置，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:拦截器配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/6 14:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所要拦截的请求路径</span></span><br><span class="line">    String[] addPathPatterns = &#123;</span><br><span class="line">            <span class="string">&quot;/**&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要拦截的请求路径</span></span><br><span class="line">    String[] excludePathPatterns = &#123;</span><br><span class="line">            <span class="string">&quot;/user/error&quot;</span>,<span class="string">&quot;/user/out&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor()).addPathPatterns(addPathPatterns).excludePathPatterns(excludePathPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>基本已经完成了逻辑代码的编写，下面就是开始测试，还有就是有关于cookie安全问题的思考，写的很乱，还请见谅。</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Docker -nacos -System-b</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-五-Doccker安装配置nacos</title>
    <url>/2020/11/24/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E4%BA%94-Doccker%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnacos/</url>
    <content><![CDATA[<p>既然决定使用微服务框架，那肯定还是nacos香，我的nacos依然是放在Linux系统中，并且使用了docker容器，</p>
<a id="more"></a>

<p>1.docker安装nacos，我是直接安装了最新的，如果需要指定版本，直接后面:xx就可以了，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124094505739.png" alt="image-20201124094505739"></p>
<p>2.启动nacos的镜像，并设置开机启动，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --env MODE&#x3D;standalone --name nacos -d -p 8848:8848 nacos&#x2F;nacos-server</span><br><span class="line"></span><br><span class="line">docker update --restart&#x3D;always 71b1262f7ba0</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124095348910.png" alt="image-20201124095348910"></p>
<p>3.进入容器内部，然后查看目录，然后进入conf，使用vim命令修改application.properties配置文件，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it nacos &#x2F;bin&#x2F;bash</span><br><span class="line">vi application.properties</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124101228476.png" alt="image-20201124101228476"></p>
<p>4.修改配置文件，主要是数据库类型，数据库IP，数据库名，数据库的用户名和密码，然后重启nacos，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124102754128.png" alt="image-20201124102754128"></p>
<p>5.连接阿里云里面的数据库，进入容器内部，然后新建一个数据库，执行命令，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database nacos_config;</span><br><span class="line">show database;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124101751957.png" alt="image-20201124101751957"></p>
<p>6.新建表，表数据来自<a href="https://github.com/alibaba/nacos/blob/develop/distribution/conf/nacos-mysql.sql" target="_blank">nacos数据Sql</a>，执行语句，语句太多，就不在这里写了，有需要可以留言，然后查看数据表，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124102320717.png" alt="image-20201124102320717"></p>
<p>7.这个时候就可以直接访问了，我遇到了一个小问题，就是端口，需要在阿里云的安全组配置中配置8848的端口，然后再访问，ip:8848/nacos，默认的用户名和密码都是nacos，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124110415451.png" alt="image-20201124110415451"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124110515805.png" alt="image-20201124110515805"></p>
<p>8.测试一个配置文件，查看数据库是否生成，可以看到同步生成了数据，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124110804638.png" alt="image-20201124110804638"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124110832515.png" alt="image-20201124110832515"></p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Docker -nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-四-搭建Springboot项目</title>
    <url>/2020/11/06/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E5%9B%9B-%E6%90%AD%E5%BB%BASpringboot%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>云服务器的搭建先暂停一下，这里谈论一下思路，搭建之前肯定要确认思路，我是打算试用Springboot+Redis来实现单点登录的，具体的思路：</p>
<a id="more"></a>

<p>A.首先将三个服务都启动，分别端口为8080、8081、8082；</p>
<p>B.用户调用系统a的接口，后台对所有请求进行拦截，如果当前用户没有登录，则重定向登录页面；</p>
<p>C.登录页面登录成功后会跳转到系统a的登录成功页面，同时sso服务中心会生成一个唯一的ticket，存储到redis中，设置一个过期时间；</p>
<p>D.用户继续调用系统b的接口，这个时候的b的Domain已经获取到了ticket，它会将带有ticket的url请求提交到sso服务中心，服务中心会将这个ticket和redis中的ticket进行比较，然后肯定相同，因为系统b的ticket本来就和系统a的ticket一样，验证通过直接放行，然后将ticket再次存入到cookie和redis中，同时更新ticket的过期时间；</p>
<p>E.用户退出任意一个系统，就会清空cookie，这个时候访问另一个系统的功能，会发现也已经处于未登录状态，这样就实现了单点登录。</p>
<p>1.搭建一下后台项目结构，新建一个Springboot项目，什么依赖都不需要加，这是作为父项目的，新建成功后，将除了pom文件外的其他文件全部删除，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/18.1.png" alt="18.1"></p>
<p>2.右键刚刚新建的项目，new一个module，还是Springboot项目Sso-server，专门作为sso的服务认证中心，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/18.2.png" alt="18.2"></p>
<p>3.右键父项目，new一个module，还是Springboot项目System-a，作为系统a，一会用来登录，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/18.3.png" alt="18.3"></p>
<p>4.右键父项目，new一个module，还是Springboot项目System-b，作为系统b，一会a系统登录成功，b系统则应该不用登录就能调用结果,</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/18.5.png" alt="18.5"></p>
<p>5.这是整体项目结构，思路和项目结构都明确下来，就开始一步一步编写，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/18.4.png" alt="18.4"></p>
<p>6.做到这里，我以为已经很完善了，但是我尝试了一下Springboot的拦截器，它拦截不到其他模块的请求！无奈想了半天，我觉得这里有两种解决方案，一个是不做两个系统，在一个系统里面，然后使用postman来直接测试接口，另一个当然就复杂了，使用gateway网关拦截，我思考了一会，选择了使用gateway网关，既然都使用了gateway网关，那不如直接搞个小型的微服务架构出来，所以搭建新模块System-gateway，这里做网关拦截过滤，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124090913651.png" alt="image-20201124090913651"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124090953452.png" alt="image-20201124090953452"></p>
<p>总结，这一步其实尤为关键，说实话，现在代码复用率和工具的便捷性那么高，很少需要自原生的去写了，所有思路变得更加重要，要明白实现一个功能点的逻辑，而不是走一步看一步，一个bug改半天，最后发现出发点就不对，诸君共勉。</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Docker -Redis -Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>本地包导入pom依赖方法总结</title>
    <url>/2021/01/29/%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%AF%BC%E5%85%A5pom%E4%BE%9D%E8%B5%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一般来说，都是直接使用依赖，但总有一些情况想要把本地包加入maven依赖，有两种实现方法。</p>
<a id="more"></a>

<h4 id="第一种：通过命令的方式，"><a href="#第一种：通过命令的方式，" class="headerlink" title="第一种：通过命令的方式，"></a>第一种：通过命令的方式，</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install:install-file  </span><br><span class="line"> -DgroupId&#x3D;com.taobao    -DartifactId&#x3D;taobao-sdk  </span><br><span class="line"> -Dversion&#x3D;2.8   -Dpackaging&#x3D;jar    -Dfile&#x3D;E:\IdeaWorkplace\redis\lib\taobao-sdk-java-auto.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20210129140844678.png" alt="image-20210129140844678"></p>
<p>然后pom里面直接依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.taobao&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;taobao-sdk&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第二种方法：使用插件，"><a href="#第二种方法：使用插件，" class="headerlink" title="第二种方法：使用插件，"></a>第二种方法：使用插件，</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.5&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;true&lt;&#x2F;skipTests&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<p>然后再添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.taobao&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;taobao-sdk&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;system&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;systemPath&gt;E:\IdeaWorkplace\redis\lib\taobao-sdk-java-auto.jar&lt;&#x2F;systemPath&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-mvn -pom</tag>
      </tags>
  </entry>
  <entry>
    <title>探索equals必须重写hashCode方法的原理</title>
    <url>/2021/01/29/%E6%8E%A2%E7%B4%A2equals%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>hashCode()的作用是获取哈希码，它实际上返回了一个int整数，这个哈希码的作用就是确定该对象在哈希表中的索引位置，并且hashCode()方法被定义在Object.java中，这就意味着java中任何类都包含了hashCode()函数；</p>
<a id="more"></a>

<p>为什么要有hashCode呢？</p>
<p>通过HashSet查重来理解：</p>
<p>​             当把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值作比较，如果没有相同的hashCode，但是如果发现有相同的hashCode值的对象，这时就会调用equals()方法来检查equals相等的对象是否真的相同，如果相同，则HashSet不会让其加入操作成功，如果不同，则重新散列到其他位置，这样大大减少了equals的次数，提高了执行效率，</p>
<p>由此得到hashCode和equals的规定：</p>
<p>​                如果两个对象相等，则hashCode值一定相同；</p>
<p>​                如果两个对象相等，则两个对象分别调用equals都返回true；</p>
<p>​                如果两个对象的hashCode相等，则两个对象并不一定相等；</p>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-@CacheEvict</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇blog</title>
    <url>/2020/08/13/%E7%AC%AC%E4%B8%80%E7%AF%87blog/</url>
    <content><![CDATA[<p>读书与人生(测试博客上传)<br>哲学家吉尔伯特曾经讽刺人类不过是剃净了毛的猴子，史密斯据以反驳的理由是：人类会著书，会读书。人类能将心灵的精华诉诸文字，流传后世，也只有人类，才能阅读先哲的智慧，从中获益。<br>拿破仑有句名言：“真正的征服，唯一不令人遗憾的征服，就是对于无知的征服。”此话从这位雄霸欧洲的帝王口中道出，更添一番深意，令人回味无穷。无疑。对于知识的追求，令人身心愉快。</p>
<a id="more"></a>

<p>读书是精神王国的探险，是灵魂的壮游，是内在灵性不断成长的源泉。书籍改变了世界，读书丰富了人生。<br>对于一位真正的读书人，读书之意不在寻求什么“黄金屋”、“千钟粟”与“颜如玉”，读书自然不是一件需锥刺股、头悬梁的苦差，而是人生的一大享受。一册好书，往往浓缩了作者一生的全部情感体验与思想洞见。所以，智者苏格拉底声称，一册好书能引诱他走遍全世界。宋代诗人尤袤对书的赞语更富于浪漫的味道，所谓：“饥读之以当肉，寒读之以当裘，贫贱读之以当友朋，寂寞读之以当金石琴瑟也。”书人心境，历历可见。<br>静夜如水，放下帘儿，泡上一杯清茗，独自于灯下展读，悠悠然游于道。夜读的境界醇厚如酒，以至“三更有梦书当枕”，连梦中也飘逸出阵阵书香了。<br>雨天读书另有一番幽趣。在滴滴答答的敲檐声中最宜于开卷了。选择一个惬意的姿势，让整个心灵浸润于大师的泽惠里，怡然如西湖卧游，静定如枯荷听雨。待街灯四起，掩卷沉思，心里是抑制不住的莫名的怅惘和美丽的忧郁。<br>至于金圣叹所言“雪夜闭户读禁书”，那样一个富于神秘色彩的环境，那样一册富于诱惑力的书，构成的意趣自然令书人神而往之了。<br>读书是件乐事，访书、淘书、购书、藏书也是件乐事。郑西谛访得一册所需古书，“往往大喜数日，如大将之克名城”。不得已而售书时，竟如“李后主挥泪斩宫娥”之黯然。阿英说起上海城隍庙的旧书店、旧书摊，如数家珍。像英国书痴乔治•吉辛那样，为买一套好书而克扣口腹之欲的体验，得书后摩挲书页的幸福，恐怕书人都有同感。持四壁为书，漫步于书林小径，作绕室旅行，自是别有风光。静静地伫立于书橱前，单是那一个个书名，便是一串串动人的故事。随手抽出一册，若是重读之书，如晤旧友，那是亲切而坦诚的长谈，透着往事的温馨；若是未裁之新书，则庆幸终于有了阅读时间，那份负疚便可收回。何况，除了书本身的故事外，还有隐进书页的无数故事：那买书的艰辛，得书的欢欣，赠书人的情谊……一册册书，便可串起一寸寸生命的时光。<br>不过，坐拥书城须时时输入相识的清新空气才是。进得书山，出得书山，方是纵意书卷。酸腐气太盛，难免不被人讥为书呆子，想孔乙己那样，自然要不得。今日，科举取士已成过去，现代社会涤荡了古人读书特有的浪漫意味，商浪冲击下，所患不是书呆子多，而是读书人少。然而，对于今日的读书人来说，要在霓光璀璨中独守一柱青灯，则要抵制更多的诱惑。但我们欣喜地看到，大浪淘沙，留下了一群痴心不改的真正的读书人，他们更为执著地坚守人类的精神空间，努力探寻生命转圜的途径。<br>书是小人生，人生是大书</p>
]]></content>
      <categories>
        <category>-Blog System</category>
      </categories>
      <tags>
        <tag>-test</tag>
      </tags>
  </entry>
  <entry>
    <title>调用start()方法为什么会执行run()方法</title>
    <url>/2021/01/06/%E8%B0%83%E7%94%A8start-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%89%A7%E8%A1%8Crun-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-Start -Run</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存失效模式</title>
    <url>/2021/01/29/%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>注解@CacheEvict，修改数据后，就自动清空缓存，下次执行后再重新生成缓存</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CacheEvict(value &#x3D; &quot;category&quot;,key &#x3D; &quot;&#39;getLevel1Categorys&#39;&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="1-同时进行多种缓存操作-：-Caching"><a href="#1-同时进行多种缓存操作-：-Caching" class="headerlink" title="1.同时进行多种缓存操作 ：@Caching"></a>1.同时进行多种缓存操作 ：@Caching</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;    @Caching(evict &#x3D; &#123;</span><br><span class="line">&#x2F;&#x2F;            @CacheEvict(value &#x3D; &quot;category&quot;,key &#x3D; &quot;&#39;getLevel1Categorys&#39;&quot;),</span><br><span class="line">&#x2F;&#x2F;            @CacheEvict(value &#x3D; &quot;category&quot;,key &#x3D; &quot;&#39;getCatalogJson&#39;&quot;)</span><br><span class="line">&#x2F;&#x2F;    &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-删除某个分区下所有数据：-CacheEvict"><a href="#2-删除某个分区下所有数据：-CacheEvict" class="headerlink" title="2.删除某个分区下所有数据：@CacheEvict"></a>2.删除某个分区下所有数据：@CacheEvict</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@CacheEvict(value &#x3D; &quot;category&quot;,allEntries &#x3D; true)</span><br></pre></td></tr></table></figure>

<h4 id="3-存储同一类型的数据，都可以指定成同一分区"><a href="#3-存储同一类型的数据，都可以指定成同一分区" class="headerlink" title="3.存储同一类型的数据，都可以指定成同一分区"></a>3.存储同一类型的数据，都可以指定成同一分区</h4>]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-@CacheEvict</tag>
      </tags>
  </entry>
  <entry>
    <title>边遍历边移除Collection的元素</title>
    <url>/2021/01/06/%E8%BE%B9%E9%81%8D%E5%8E%86%E8%BE%B9%E7%A7%BB%E9%99%A4Collection%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>边遍历边移除Collection的唯一正确方式是使用Iterator.remove()方法，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Interger&gt; it &#x3D; list.iterator();</span><br><span class="line">wuhile(it.haasNext())&#123;</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">常见的错误代码：</span><br><span class="line">    for(Integer i : list)&#123;</span><br><span class="line">        list.remove();&#x2F;&#x2F;会报异常</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-Remove</tag>
      </tags>
  </entry>
  <entry>
    <title>重写HashCode的原理</title>
    <url>/2021/01/06/%E9%87%8D%E5%86%99HashCode%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>​       hashCode()的作用是获取哈希码，它实际上返回了一个int整数，这个哈希码的作用就是确定该对象在哈希表中的索引位置，并且hashCode()方法被定义在Object.java中，这就意味着java中任何类都包含了hashCode()函数；</p>
<p>为什么要有hashCode呢？</p>
<a id="more"></a>

<p>通过HashSet查重来理解：</p>
<p>​             当把对象加入HashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashCode值作比较，如果没有相同的hashCode，但是如果发现有相同的hashCode值的对象，这时就会调用equals()方法来检查equals相等的对象是否真的相同，如果相同，则HashSet不会让其加入操作成功，如果不同，则重新散列到其他位置，这样大大减少了equals的次数，提高了执行效率，</p>
<p>由此得到hashCode和equals的规定：</p>
<p>​                如果两个对象相等，则hashCode值一定相同；</p>
<p>​                如果两个对象相等，则两个对象分别调用equals都返回true；</p>
<p>​                如果两个对象的hashCode相等，则两个对象并不一定相等；</p>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-HashCode</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发下缓存失效问题</title>
    <url>/2021/01/29/%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>是缓存是在开发中最长遇到的问题，这是总结的经常遇到的几种情况。</p>
<a id="more"></a>

<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>指查询一个一定不存在的数据，由于缓存时不命中，将区查询数据库，但是数据库也无此记录，我们没有将这次查询的null下入缓存，将导致这个不存在的数据每次请求都要到存储层区查询，失去了缓存的意义<br>风险：利用不存在的数据进行攻击，数据库瞬间压力增大，最终导致崩溃<br>解决：null结果缓存，并加入短暂过期时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#是否缓存空指,防止缓存穿透</span><br><span class="line">spring.cache.redis.cache-null-values&#x3D;true</span><br></pre></td></tr></table></figure>

<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>对于一些设置了过期时间的key，如果这些key可能会在某个时间点被超高并发的访问，是一种非常“热点”的数据<br>如果这个key在大量请求同时进来前政好失效，那么所有堆这个key的数据查询都落在了DB，我们成为缓存击穿<br>解决：加锁，大量并发只让一个去查，其他人等待，查到以后释放锁，其他人获取到锁，先查缓存，就会有数据，不用区DB，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Cacheable(value &#x3D; &#123;&quot;category&quot;&#125;,key &#x3D; &quot;#root.method.name&quot;,sync &#x3D; true)</span><br></pre></td></tr></table></figure>

<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>指在我们设置缓存时key采取了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬间压力过重雪崩<br>解决：原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这一每一个缓存的过期时间的额重复率就会降低，很难引发集体失效的事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#存活时间，单位是毫秒</span><br><span class="line">spring.cache.redis.time-to-live&#x3D;3600000</span><br></pre></td></tr></table></figure>

<h4 id="缓存一致性解决方案"><a href="#缓存一致性解决方案" class="headerlink" title="缓存一致性解决方案"></a>缓存一致性解决方案</h4><p>我们能放进缓存的数据本就不应该是实时性、一致性要求超高的，所以缓存数据的时候加上过期时间，保证每天拿到的当前最新数据即可；<br>我们不应该过度设计，增加系统的复杂性；<br>遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。<br>解决：1.双写模式      </p>
<p>​            2.失效模式<br>gulimall中使用失效模式： 1.缓存的所有数据都有过期时间，数据过期下一次查询触发主动更新  2.读写数据的时候，加上分布式的读写锁，</p>
]]></content>
      <categories>
        <category>-随笔</category>
      </categories>
      <tags>
        <tag>-缓存失效</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql进阶--索引失效准则</title>
    <url>/2020/11/21/Mysql%E8%BF%9B%E9%98%B6-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%87%86%E5%88%99/</url>
    <content><![CDATA[<p><strong>索引失效（应该避免）</strong></p>
<p>导致索引失效的一些准则，也算是一些规范，在实际开发中，在满足业务的条件下，可以尽量的避免，以达到优化的效果。</p>
<a id="more"></a>

<p>1.首先新建一张员工表，并插入数据，建立复合索引，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE staffs(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    &#96;name&#96; VARCHAR(24)NOT NULL DEFAULT&#39;&#39; COMMENT&#39;姓名&#39;,</span><br><span class="line">    &#96;age&#96; INT NOT NULL DEFAULT 0 COMMENT&#39;年龄&#39;,</span><br><span class="line">    &#96;pos&#96; VARCHAR(20) NOT NULL DEFAULT&#39;&#39; COMMENT&#39;职位&#39;,</span><br><span class="line">    &#96;add_time&#96; TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT&#39;入职时间&#39;</span><br><span class="line">)CHARSET utf8 COMMENT&#39;员工记录表&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO staffs(&#96;name&#96;,&#96;age&#96;,&#96;pos&#96;,&#96;add_time&#96;) VALUES(&#39;z3&#39;,22,&#39;manager&#39;,NOW());</span><br><span class="line">INSERT INTO staffs(&#96;name&#96;,&#96;age&#96;,&#96;pos&#96;,&#96;add_time&#96;) VALUES(&#39;July&#39;,23,&#39;dev&#39;,NOW());</span><br><span class="line">INSERT INTO staffs(&#96;name&#96;,&#96;age&#96;,&#96;pos&#96;,&#96;add_time&#96;) VALUES(&#39;2000&#39;,23,&#39;dev&#39;,NOW());</span><br><span class="line"></span><br><span class="line">ALTER TABLE staffs ADD INDEX index_staffs_nameAgePos(&#96;name&#96;,&#96;age&#96;,&#96;pos&#96;);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113153457208.png" alt="image-20201113153457208"></p>
<p><strong>索引失效准则：</strong></p>
<ol>
<li>全值匹配我最爱</li>
<li>最佳左前缀法则：如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</li>
<li>不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少<code>select *</code></li>
<li>mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li>
<li><code>is null</code>，<code>is not null</code> 也无法使用索引（早期版本不能走索引，后续版本应该优化过，可以走索引）</li>
<li>like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描操作</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它连接时会索引失效</li>
</ol>
<blockquote>
<p>最佳左匹配法则：带头大哥不能死，中间兄弟不能断</p>
</blockquote>
<p>概念：如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始并且<strong>不跳过索引中的列</strong>，</p>
<p>只有第一个查询条件 name 的时候：</p>
<ul>
<li>type=ref，进行了优化</li>
<li>key = index_staffs_nameAgePos 表明索引生效</li>
<li>ref = const ，这个常量就是查询时的 ‘July’ 字符串常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113154231090.png" alt="image-20201113154231090"></p>
<p>在name的基础上加上age查询条件的时候：</p>
<ul>
<li>type=ref，进行了优化</li>
<li>key = index_staffs_nameAgePos 表明索引生效</li>
<li>ref = const,const ，两个常量分别就代表了“July”和“23”，这两个查询条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;AND age &#x3D; 23;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113154649743.png" alt="image-20201113154649743"></p>
<p>在name、age的基础上再加上pos查询条件：</p>
<ul>
<li>type=ref，进行了优化</li>
<li>key = index_staffs_nameAgePos 表明索引生效</li>
<li>ref = const,const,const ，三个常量分别就代表了“July”和“23”和“dev”，这三个查询条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;AND age &#x3D; 23 AND pos &#x3D; &#39;dev&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113155032536.png" alt="image-20201113155032536"></p>
<p>并且可以注意到，key_len的数值也在变化：74-&gt;78-&gt;140，就算忘记了它的涵义，但是key_len那么明显，什么的长度，别忘了这是在干嘛，执行一条sql，并且使用索引，就算还是不知道是索引长度，就算把它作为sql的执行长度，也应该是越短越好，</p>
<p>尝试去掉name查询条件：</p>
<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE age &#x3D; 23 AND pos &#x3D; &#39;dev&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113155719578.png" alt="image-20201113155719578"></p>
<p>尝试去掉age查询条件：</p>
<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE pos &#x3D; &#39;dev&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113155932855.png" alt="image-20201113155932855"></p>
<p><strong>毫无疑问，当name条件去掉以后，索引就不再生效了，说明老大哥确实不能死，死了后面都不再生效，</strong></p>
<p>那试试去掉age查询字段，留下name和pos呢：</p>
<ul>
<li>type=ref，毫无疑问，索引生效了，</li>
<li>key = index_staffs_nameAgePos，表明索引生效</li>
<li>ref = const，说明只有一个字段生效了，而查看它的key_len是为74的，而key_len代表的是索引的长度，并且这个数字很熟悉，因为在前面单独查询name的时候就为74，那就说明这个const代表的只会是“July”这个查询条件，</li>
</ul>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113160634862.png" alt="image-20201113160634862"></p>
<p>这又证明了当中间条件age去掉之后，后面的索引也不再生效了，说明了<strong>带头大哥不能死，中间兄弟也不能断</strong>，</p>
<blockquote>
<p>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</p>
</blockquote>
<p>还是先只设置name一个查询条件：</p>
<ul>
<li>type=ref，毫无疑问，索引生效了，</li>
<li>key = index_staffs_nameAgePos，表明索引生效</li>
<li>ref = const，代表了”July”查询条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113161724300.png" alt="image-20201113161724300"></p>
<p>对name使用left进行截断操作：</p>
<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE LEFT(name,4) &#x3D; &#39;July&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113161923839.png" alt="image-20201113161923839"></p>
<p>而我们查看两条sql的查询结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM staffs WHERE LEFT(name,4) &#x3D; &#39;July&#39;;</span><br><span class="line">SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113162049543.png" alt="image-20201113162049543"></p>
<p>毫无疑问，结果是一致的，但是name进行了left截断操作的语句的索引失效了，所以，<strong>不要对索引的字段进行计算，将会导致索引失效</strong>，</p>
<blockquote>
<p>存储引擎不能使用索引中范围条件右边的列</p>
</blockquote>
<p>先看一下全值匹配，也就是三个查询条件都是=：</p>
<ul>
<li>type=ref，进行了优化</li>
<li>key = index_staffs_nameAgePos 表明索引生效</li>
<li>ref = const,const,const ，三个常量分别就代表了“July”和“23”和“dev”，这三个查询条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;AND age &#x3D; 23 AND pos &#x3D; &#39;dev&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113163028278.png" alt="image-20201113163028278"></p>
<p>那试一试将age改为范围查询条件呢：</p>
<ul>
<li>type = range ，表示范围扫描</li>
<li>key = index_staffs_nameAgePos 表示索引生效</li>
<li>ref = NULL ，且key_len为78，表明了范围搜索使其后面的索引均失效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;AND age &gt; 25 AND pos &#x3D; &#39;dev&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113163356914.png" alt="image-20201113163356914"></p>
<p>可以看出来，在范围查询后的索引会失效，所以，<strong>不要使用索引范围右边(也就是后面)的字段(列)，</strong></p>
<blockquote>
<p>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少 select  *</p>
</blockquote>
<p>先使用select * 来查询：</p>
<ul>
<li>type = ref，表示范围扫描</li>
<li>key = index_staffs_nameAgePos 表示索引生效</li>
<li>ref = const,const,const，分别代表了三个常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &#x3D; &#39;July&#39;AND age &#x3D; 25 AND pos &#x3D; &#39;dev&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113164523102.png" alt="image-20201113164523102"></p>
<p>再单独查询字段：</p>
<ul>
<li>type = ref，表示范围扫描</li>
<li>key = index_staffs_nameAgePos 表示索引生效</li>
<li>ref = const,const,const，分别代表了三个常量</li>
<li>而这里的Extra变为了Using index，这是覆盖索引，表示使用索引列进行查询，很大程度的提高查询的效率，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name, age, pos FROM staffs WHERE name &#x3D; &#39;July&#39;AND age &#x3D; 25 AND pos &#x3D; &#39;dev&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113164500550.png" alt="image-20201113164500550"></p>
<p>所以，*<em>最好使用覆盖索引，索引列和查询列保持一致，减少select * 查询*</em>，</p>
<blockquote>
<p>mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p>
</blockquote>
<p>在使用 != 会 &lt;&gt; 时会导致索引失效：</p>
<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name !&#x3D; &#39;July&#39;;</span><br><span class="line">EXPLAIN SELECT * FROM staffs WHERE name &lt;&gt; &#39;July&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113165317184.png" alt="image-20201113165317184"></p>
<p>有的时候确实一些业务要求这样写，不能为了索引而索引，该写还是要写，只能说在保证业务的情况下去进行优化，</p>
<blockquote>
<p>is null，is not null也无法使用索引</p>
</blockquote>
<p>使用is null,is not null导致索引失效：</p>
<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name is null;</span><br><span class="line">EXPLAIN SELECT * FROM staffs WHERE name is not null;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113165712133.png" alt="image-20201113165712133"></p>
<blockquote>
<p>like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描操作，所以like % 写在查询条件的最右边</p>
</blockquote>
<p>使用like，前后都添加通配符：</p>
<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name like &#39;%July%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113170411196.png" alt="image-20201113170411196"></p>
<p>使用like，前面加通配符，后面不加：</p>
<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name like &#39;%July&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113170500892.png" alt="image-20201113170500892"></p>
<p>使用like，后面加通配符，前面不加：</p>
<ul>
<li>type = range ，表示like是范围扫描</li>
<li>key = index_staffs_nameAgePos 表示索引生效</li>
<li>ref = NULL ，表明了范围搜索使其后面的索引均失效，那是不是代表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM staffs WHERE name like &#39;July%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113170536703.png" alt="image-20201113170536703"></p>
<p>由上面三种情况可以得出，<strong>like的通配符%最好加右边</strong>，但是有的时候就是需要前后加通配符，<strong>如何解决like ‘%字符串%’时索引不被使用的方法？</strong></p>
<blockquote>
<p>解决like ‘%字符串%’ 索引失效的问题：覆盖索引</p>
</blockquote>
<p>1.创建一张user表，并插入部分数据，执行语句，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;tbl_user&#96;(</span><br><span class="line">    &#96;id&#96; INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    &#96;name&#96; VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    &#96;age&#96;INT(11) DEFAULT NULL,</span><br><span class="line">    &#96;email&#96; VARCHAR(20) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY(&#96;id&#96;)</span><br><span class="line">)ENGINE&#x3D;INNODB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_user(&#96;name&#96;,&#96;age&#96;,&#96;email&#96;)VALUES(&#39;1aa1&#39;,21,&#39;a@163.com&#39;);</span><br><span class="line">INSERT INTO tbl_user(&#96;name&#96;,&#96;age&#96;,&#96;email&#96;)VALUES(&#39;2bb2&#39;,23,&#39;b@163.com&#39;);</span><br><span class="line">INSERT INTO tbl_user(&#96;name&#96;,&#96;age&#96;,&#96;email&#96;)VALUES(&#39;3cc3&#39;,24,&#39;c@163.com&#39;);</span><br><span class="line">INSERT INTO tbl_user(&#96;name&#96;,&#96;age&#96;,&#96;email&#96;)VALUES(&#39;4dd4&#39;,26,&#39;d@163.com&#39;);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113171405716.png" alt="image-20201113171405716"></p>
<p>2.新建一条复合索引，为了解决通配符问题，使用覆盖索引，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_user_nameAge ON tbl_user(name, age);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113171736749.png" alt="image-20201113171736749"></p>
<p>3.测试覆盖索引，也就是说name和age这两个字段，在作为索引的情况下，是否能解决通配符后不被引用的问题，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name, age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT name FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT id FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT id, name FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT id, age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT id, name, age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;;</span><br></pre></td></tr></table></figure>

<p>查询name，age：</p>
<ul>
<li>type=index，索引生效了，</li>
<li>key = idx_user_nameAge，表明索引生效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name, age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113172301789.png" alt="image-20201113172301789"></p>
<p>查询id：</p>
<ul>
<li>type=index，索引生效了，默认主键索引</li>
<li>key = idx_user_nameAge，表明索引生效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113172547154.png" alt="image-20201113172547154"></p>
<p>单独查询name和age：</p>
<ul>
<li>type=index，索引生效了，</li>
<li>key = idx_user_nameAge，表明索引生效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT name FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113172459510.png" alt="image-20201113172459510"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113172710719.png" alt="image-20201113172710719"></p>
<p>查询id和name、age的搭配查询的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT id, name FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT id, age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;; </span><br><span class="line">EXPLAIN SELECT id, name, age FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>type=index，索引生效了，</li>
<li>key = idx_user_nameAge，表明索引生效</li>
</ul>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113172857346.png" alt="image-20201113172857346"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113172908822.png" alt="image-20201113172908822"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113172917802.png" alt="image-20201113172917802"></p>
<p>上面的sql，查询的东西至少都是和索引有所关联，所以都生效了，那么再测试一个查询不属于索引的字段呢，</p>
<p>查询id, name, age, email 或者 *：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;;</span><br><span class="line">EXPLAIN SELECT id, name, age, email FROM tbl_user WHERE NAME LIKE &#39;%aa%&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>type=ALL，毫无疑问，进行了全表扫描，</li>
<li>key = null，表明索引并没有生效</li>
<li>ref = null，说明ref没有索引字段生效，</li>
</ul>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113173213108.png" alt="image-20201113173213108"></p>
<p>从上述的测试可以看出，如果业务中非要用双百分号通配符like，而<strong>要实现索引生效的最好方式，就是使用覆盖索引，也就是查询的字段加入索引，</strong></p>
<blockquote>
<p>字符串不加单引号索引失效</p>
</blockquote>
<p>先查看正确的情况，也就是正常使用单引号:</p>
<ul>
<li>type = ref，表示范围扫描</li>
<li>key = index_staffs_nameAgePos 表示索引生效</li>
<li>ref = const，代表了一个常量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from staffs where name&#x3D;&#39;2000&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113173658523.png" alt="image-20201113173658523"></p>
<p>而忘记写单引号的情况，那么 mysql 会为我们进行隐式的类型转换，但凡进行了类型转换，索引都会失效，如果还记得的话，在第三条准则有说：</p>
<ul>
<li>type = ALL，表示全表查询</li>
<li>key = null表示索引失效</li>
<li>ref = null，代表没有索引字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from staffs where name&#x3D;2000;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113173841162.png" alt="image-20201113173841162"></p>
<blockquote>
<p>少用or，用它连接时会索引失效</p>
</blockquote>
<p>使用or的情况;</p>
<ul>
<li>type = ALL，表示全表查询</li>
<li>key = null表示索引失效</li>
<li>ref = null，代表没有索引字段</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">explain select * from staffs where name&#x3D;&#39;z3&#39; or name &#x3D; &#39;July&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113174214845.png" alt="image-20201113174214845"></p>
<p>总结，十大失效准则，避免这些情况就是生效原则，一些常见的索引处理会使用到，</p>
<p>小demo;</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201113174719189.png" alt="image-20201113174719189"></p>
]]></content>
      <categories>
        <category>-MySQL进阶</category>
      </categories>
      <tags>
        <tag>-Mysql -索引 -索引失效准则 -Explain</tag>
      </tags>
  </entry>
  <entry>
    <title>单点登录-六-模块Sso-server</title>
    <url>/2020/11/29/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95-%E5%85%AD-%E6%A8%A1%E5%9D%97Sso-server/</url>
    <content><![CDATA[<p>nacos安装完成，那么就需要在配置文件中配置，并且在nacos服务中新建命名空间，</p>
<a id="more"></a>

<p>1.首先在nacos中新建一个命名空间，用于注册服务到nacos中，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124141635630.png" alt="image-20201124141635630"></p>
<p>2.引入当前需要的依赖，因为这是父子工程，所以可以直接放在主依赖中，然后其他模块直接引用，我是全部放在了Sso-server中，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">           &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">       &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.添加配置文件，因为我喜欢yml文件格式，所以我将properties文件修改为了yml文件，这个可以根据自己的爱好，当然多个配置文件的时候要注意他们有不同的加载顺序，相同的配置会被覆盖，redis不设置哪个库的话，会默认使用0号库，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Sso-server</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx.xxx.xxx.107</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxx</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">114.215</span><span class="number">.203</span><span class="number">.107</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">4c4dae70-45b6-4cd9-997d-5138800b41d2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span>  <span class="comment">#prefix：指定模板所在的目录</span></span><br><span class="line">    <span class="attr">check-template-location:</span> <span class="literal">true</span>  <span class="comment">#check-tempate-location: 检查模板路径是否存在</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span>  <span class="comment">#cache: 是否缓存，开发模式下设置为false，避免改了模板还要重启服务器，线上设置为true，可以提高性能。</span></span><br><span class="line">    <span class="attr">suffix:</span>  <span class="string">.html</span></span><br><span class="line">    <span class="comment">#encoding: UTF-8</span></span><br><span class="line">    <span class="comment">#content-type: text/html</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br></pre></td></tr></table></figure>

<p>4.由于端口占用，我将端口修改为了9085，然后记得在启动器上加上注解@EnableDiscoveryClient，然后查看服务列表，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124143402690.png" alt="image-20201124143402690"></p>
<p>5.使用同样的方式，只需要修改端口，服务名和命名空解，将模块System-b和模块System-gateway一起注册，Sso-server不用注册，它是作为认证中心的，</p>
<p>模块System-b：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124143653767.png" alt="image-20201124143653767"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124151439700.png" alt="image-20201124151439700"></p>
<p>模块System-gateway：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124143952162.png" alt="image-20201124143952162"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201124152603493.png" alt="image-20201124152603493"></p>
<p>模块Sso-server：</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201127111848700.png" alt="image-20201127111848700"></p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201127112024455.png" alt="image-20201127112024455"></p>
<p>6.我是在网上随便找了一个登录页面，放在resources/templates路径下面，因为这是Springboot默认扫描页面的路径，只有两个参数，用户名和密码，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;//layui.hcwl520.com.cn/layui/css/layui.css?v=201811010202&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;margin-left: 25%;margin-right: 25%;margin-top:150px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;padding: 20px; background-color: #F2F2F2;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-row layui-col-space15&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-card&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fieldset</span> <span class="attr">class</span>=<span class="string">&quot;layui-elem-field layui-field-title&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">legend</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;layui-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-item&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-label&quot;</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-input-block&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">lay-verify</span>=<span class="string">&quot;title&quot;</span> <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入标题&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">class</span>=<span class="string">&quot;layui-input&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-item&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-label&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-input-block&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">lay-verify</span>=<span class="string">&quot;required&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入&quot;</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">autocomplete</span>=<span class="string">&quot;off&quot;</span> <span class="attr">class</span>=<span class="string">&quot;layui-input&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-form-item&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layui-input-block&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layui-btn&quot;</span> <span class="attr">lay-submit</span>=<span class="string">&quot;&quot;</span> <span class="attr">lay-filter</span>=<span class="string">&quot;demo1&quot;</span>&gt;</span>立即提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">class</span>=<span class="string">&quot;layui-btn layui-btn-primary&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">class</span>=<span class="string">&quot;layui-elem-quote layui-text&quot;</span>&gt;</span></span><br><span class="line">                SSO登录演示：用户名和密码相同即可登录</span><br><span class="line">            <span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//layui.hcwl520.com.cn/layui/layui.js?v=201811010202&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>7.编写控制器，明确思路，a系统登录，监测到没有ticket，跳转到登录页面，编写登录页面跳转和登录控制器，并将源url和uuid都保存到cookie中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录页面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> originalUrl  源url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uuid  客户端唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/loginPage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">loginPage</span><span class="params">(String originalUrl, String uuid, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        SsoCookieUtil.setCookie(response, <span class="string">&quot;originalUrl&quot;</span>, originalUrl, ServerConstant.REDIS_TICKET_ALIVE_SECONDS);</span><br><span class="line">        SsoCookieUtil.setCookie(response, <span class="string">&quot;uuid&quot;</span>, uuid, ServerConstant.REDIS_TICKET_ALIVE_SECONDS);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String userName, String password, HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> loginSuccess = loginService.login(userName, password);</span><br><span class="line">        <span class="keyword">if</span> (loginSuccess)&#123;</span><br><span class="line">            <span class="comment">//获取客户端唯一标识</span></span><br><span class="line">            String uuid = SsoCookieUtil.getCookie(request, <span class="string">&quot;uuid&quot;</span>);</span><br><span class="line">            <span class="comment">//创建ticket</span></span><br><span class="line">            String ticket = loginService.createTicket(uuid);</span><br><span class="line">            <span class="comment">//存入redis，测试180秒过期</span></span><br><span class="line">            redisTemplate.opsForValue().set(ServerConstant.REDIS_TICKET_PREFIX + ticket,userName,ServerConstant.REDIS_TICKET_ALIVE_SECONDS, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">//回源url</span></span><br><span class="line">            String originalUrl = SsoCookieUtil.getCookie(request,<span class="string">&quot;originalUrl&quot;</span>) + <span class="string">&quot;?ticket=&quot;</span> + ticket;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//重定向到源url</span></span><br><span class="line">                response.sendRedirect(originalUrl);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loginSuccess;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>8.编写service层，主要是两个方法，一个是创建唯一的ticket值，和登录，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 11:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">createTicket</span><span class="params">(String uuid)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String userName,String password)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>9.业务实现，创建ticket我随便采用了规制，SALT是EncryptUtil工具类里面定义的一个常量，为了时间有限，就没有连接数据库，而登录只要用户名和密码相等则登录成功，我相信连接数据库的难度应该都会吧，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createTicket</span><span class="params">(String uuid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5DigestAsHex((EncryptUtil.SALT+uuid+System.currentTimeMillis()).getBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName.equalsIgnoreCase(password);<span class="comment">//用户名等于密码即可登录</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>10.EncryptUtil加密工具类,后面为了保证安全需要对cookie进行加密处理，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:加密工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SALT = <span class="string">&quot;1io10fdgadfjvower389fhday29834aguourfwpg0w82dllfkfadf&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>11.设置服务的部分常量，其他应该都能看懂，说一下SSO_URO和COOKIE_DOMAIN，因为按照cookie的规范，一个cookie只能用于一个域名，不能发给其他的域名，doamin就代表了cookie所在的域，如网址为<a href="http://www.baidu.com/test%EF%BC%8C%E9%82%A3%E4%B9%88domain%E9%BB%98%E8%AE%A4%E4%B8%BAwww.baidu.com%E3%80%82%E8%80%8C%E8%A6%81%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%A6%82%E5%9F%9FA%E4%B8%BAaa.test.com%EF%BC%8C%E5%9F%9FB%E4%B8%BAbb.test.com%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E5%9F%9FA%E7%94%9F%E4%BA%A7%E4%B8%80%E4%B8%AA%E4%BB%A4%E5%9F%9FA%E5%92%8C%E5%9F%9FB%E9%83%BD%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84cookie%E5%B0%B1%E8%A6%81%E5%B0%86%E8%AF%A5cookie%E7%9A%84domain%E8%AE%BE%E7%BD%AE%E4%B8%BA.test.com%EF%BC%9B%E5%A6%82%E6%9E%9C%E8%A6%81%E5%9C%A8%E5%9F%9FA%E7%94%9F%E4%BA%A7%E4%B8%80%E4%B8%AA%E4%BB%A4%E5%9F%9FA%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E8%80%8C%E5%9F%9FB%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84cookie%E5%B0%B1%E8%A6%81%E5%B0%86%E8%AF%A5cookie%E7%9A%84domain%E8%AE%BE%E7%BD%AE%E4%B8%BAbb.test.com,%E6%88%91%E8%BF%99%E9%87%8C%E6%98%AF%E4%B8%BA%E4%BA%86%E8%AE%A9A%E5%92%8CB%E9%83%BD%E8%83%BD%E8%AE%BF%E9%97%AE%EF%BC%8C%E6%89%80%E4%BB%A5%E8%A6%81%E5%B0%86%E5%9F%9F%E8%AE%BE%E7%BD%AE%E4%B8%BAtest.com%EF%BC%8C%E8%80%8C%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83%E7%9A%84%E8%B7%AF%E5%BE%84%E5%88%99%E6%98%AFSSO_URL%EF%BC%8C">www.baidu.com/test，那么domain默认为www.baidu.com。而要实现跨域访问，如域A为aa.test.com，域B为bb.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为bb.test.com,我这里是为了让A和B都能访问，所以要将域设置为test.com，而服务中心的路径则是SSO_URL，</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:服务常量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 10:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConstant</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_TICKET_PREFIX = <span class="string">&quot;TICKET:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REDIS_TICKET_ALIVE_SECONDS = <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ENABLE_DISPOSABLE_TICKET = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SSO_URL = <span class="string">&quot;http://sso.com:9088/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKIE_DOMAIN = <span class="string">&quot;test.com&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>12.编写一个获取cookie和保存cookie的工具类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:SsoCookie服务工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 10:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SsoCookieUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookie</span><span class="params">(HttpServletRequest request, String cookieName)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cookie.getName().equals(cookieName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxAge</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCookie</span><span class="params">(HttpServletResponse response, String cookieName, String value,<span class="keyword">int</span> maxAge)</span> </span>&#123;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, value);</span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        cookie.setMaxAge(maxAge);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置doMainCookie</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookieName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxAge</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDomainCookie</span><span class="params">(HttpServletResponse response,String cookieName,String value,<span class="keyword">int</span> maxAge)</span></span>&#123;</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(cookieName, value);</span><br><span class="line">        cookie.setDomain(ServerConstant.COOKIE_DOMAIN);</span><br><span class="line">        cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        cookie.setMaxAge(maxAge);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.编写拦截器，在认证中心配置拦截器的预处理，而其他系统模块直接拦截请求然后转发到这里就行了，逻辑其实已经说了很多次，并且代码进行了大量注释，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:配置拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zllwsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2020/11/4 10:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Object handler)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//客户端唯一标识uuid，客户端第一次访问时的session作为唯一标识，如果为空则写入cookie中</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        String uuid = SsoCookieUtil.getCookie(request, <span class="string">&quot;uuid&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(uuid))&#123;</span><br><span class="line">            <span class="comment">//如果uuid为空，则将session的id设置为uuid</span></span><br><span class="line">            uuid = session.getId();</span><br><span class="line">            <span class="comment">//将uuid存储到cookie中</span></span><br><span class="line">            SsoCookieUtil.setDomainCookie(response,<span class="string">&quot;uuid&quot;</span>,uuid,<span class="number">3600</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从cookie中获取ticket</span></span><br><span class="line">        String ticket = SsoCookieUtil.getCookie(request, <span class="string">&quot;ticket&quot;</span>);</span><br><span class="line"><span class="comment">//        String ticket = null;</span></span><br><span class="line"><span class="comment">//        if (aesDecode != null)&#123;</span></span><br><span class="line"><span class="comment">//            ticket = EncryptUtil.AESDecode(aesDecode);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果cookie中没有获取到，则从请求中去获取</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(ticket))&#123;</span><br><span class="line"><span class="comment">//            String oldTicketValue = redisTemplate.opsForValue().get(ServerConstant.REDIS_TICKET_PREFIX + ticket);</span></span><br><span class="line"><span class="comment">//            System.out.println(oldTicketValue);</span></span><br><span class="line">            ticket = request.getParameter(<span class="string">&quot;ticket&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果ticket为空</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(ticket))&#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;非法请求：未获取到ticket，重定向到登录页面...&quot;</span>);</span><br><span class="line">            <span class="comment">//由于没有ticket，就重定向认证服务的登录接口</span></span><br><span class="line">            response.sendRedirect(ServerConstant.SSO_URL + <span class="string">&quot;loginPage?originalUrl=&quot;</span> + request.getRequestURL() + <span class="string">&quot;&amp;uuid=&quot;</span> + uuid);</span><br><span class="line"><span class="comment">//            String s = Contstant.SSO_URL + &quot;loginPage?originalUrl=&quot; + request.getRequestURL() + &quot;&amp;uuid=&quot; + uuid;</span></span><br><span class="line"><span class="comment">//            System.out.println(s);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">            <span class="comment">//验证ticket,校验成功返回ticket，实际上校验成功时可以返回用户信息，校验失败则返回null</span></span><br><span class="line">            String t = restTemplate.getForObject(ServerConstant.SSO_URL + <span class="string">&quot;checkTicket?ticket=&quot;</span> + ticket + <span class="string">&quot;&amp;uuid=&quot;</span> + uuid, String.class);</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//通过restTemplate来发送内部http请求，获取用户信息，然后存储到map中</span></span><br><span class="line">                Map userInfo = restTemplate.getForObject(ServerConstant.SSO_URL + <span class="string">&quot;getUserInfo?ticket=&quot;</span> + t, Map.class);</span><br><span class="line">                logger.debug(<span class="string">&quot;ticket验证通过：&quot;</span>,userInfo);</span><br><span class="line">                <span class="comment">//userInfo存入到session中</span></span><br><span class="line">                session.setAttribute(<span class="string">&quot;userInfo&quot;</span>,userInfo);</span><br><span class="line">                <span class="comment">//更新ticket</span></span><br><span class="line"><span class="comment">//                String aesEncode = EncryptUtil.AESEncode(ticket);</span></span><br><span class="line"><span class="comment">//                CookieUtil.setCookie(response,&quot;aesEncode&quot;,t,60);</span></span><br><span class="line">                SsoCookieUtil.setDomainCookie(response,<span class="string">&quot;ticket&quot;</span>,t,<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;非法请求：路径错误，重定向到登录页面...&quot;</span>);</span><br><span class="line">                response.sendRedirect(ServerConstant.SSO_URL + <span class="string">&quot;loginPage?originalUrl=&quot;</span> + request.getRequestURL() + <span class="string">&quot;&amp;uuid=&quot;</span> + uuid);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.第一次登录的时候，uuid和ticket全都为空，uuid被设置为sesssion的id，ticket为空，直接非法请求，然后重定向到刚刚的登录页面，也就是发送login请求，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128143702261.png" alt="image-20201128143702261"></p>
<p>15.使用用户名和密码登录后，ticket被创建并且存储到redis中设置过期时间，然后再重定向到源url，源url其实就是系统登录的路径，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128143925002.png" alt="image-20201128143925002"></p>
<p>16.重定向到了源url，同样还是被拦截器拦截，再一次来到LoginInterceptor类，这个时候uuid有了，ticket有了，开始验证，并存储用户信息，更新cookie，使用的restTemplate来发送请求，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128144157349.png" alt="image-20201128144157349"></p>
<p>17.进入校验请求，检查ticket和存储在redis中的ticket，如果相同，则删除旧的ticket，重新生成新的ticket，并且刷新redis的存活时间，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验ticket</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticket</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uuid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/checkTicket&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">checkTicket</span><span class="params">(String ticket,String uuid)</span></span>&#123;</span><br><span class="line">    String oldTicketValue = redisTemplate.opsForValue().get(ServerConstant.REDIS_TICKET_PREFIX + ticket);</span><br><span class="line">    <span class="comment">//较验ticket</span></span><br><span class="line">        <span class="comment">//当redis存在ticket时验证成功</span></span><br><span class="line">        <span class="keyword">if</span> (ticket != <span class="keyword">null</span> &amp;&amp; oldTicketValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//注意：开启一次性ticket验证时，uuid和ticket必传</span></span><br><span class="line">            <span class="keyword">if</span> (ServerConstant.ENABLE_DISPOSABLE_TICKET) &#123;</span><br><span class="line">                <span class="comment">//清除旧的ticket</span></span><br><span class="line">                redisTemplate.delete(ServerConstant.REDIS_TICKET_PREFIX + ticket);</span><br><span class="line">                <span class="comment">//生成新的ticket</span></span><br><span class="line">                String newTicket = loginService.createTicket(uuid);</span><br><span class="line">                <span class="comment">//保存新的ticket</span></span><br><span class="line">                redisTemplate.opsForValue().set(ServerConstant.REDIS_TICKET_PREFIX + newTicket, oldTicketValue, ServerConstant.REDIS_TICKET_ALIVE_SECONDS, TimeUnit.SECONDS);</span><br><span class="line">                <span class="comment">//返回新ticket</span></span><br><span class="line">                <span class="keyword">return</span> newTicket;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ticket;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>18.校验成功，t为新的ticket，再发送请求，来获取用户信息，存储到map中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticket</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/getUserInfo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getUserInfo</span><span class="params">(String ticket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟根据ticket获取用户用户名,根据用户名获取用户信息</span></span><br><span class="line">    String userName = redisTemplate.opsForValue().get(ServerConstant.REDIS_TICKET_PREFIX + ticket);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(userName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, String&gt; userInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    userInfo.put(<span class="string">&quot;userName&quot;</span>, userName);</span><br><span class="line">    userInfo.put(<span class="string">&quot;ticket&quot;</span>, ticket);</span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>19.使用getUserInfo接口获取要用户信息，回到拦截器，将其存储到session中，然后更新cookie，注意这里需要使用设置了域的cookie方法，到此，登录成功，其他系统登录的时候，因为cookie中存在ticket和uuid就可以直接走保存用户信息刷新存活时间的路径，</p>
<p><img src="https://gitee.com/zllwsy/PicGo/raw/master/img/image-20201128144852483.png" alt="image-20201128144852483"></p>
<p><strong>总结：</strong></p>
<p>其实确实有点乱，我想干干净净的写每一个模块，而实际开发的时候都是相互交叉的，并不是说写了认证中心，再写A，并且我是实现了功能再开始写，着实有点乱，请见谅，后面会给出所有源码的地址。</p>
]]></content>
      <categories>
        <category>-单点登录</category>
      </categories>
      <tags>
        <tag>-阿里云 -Linux -Docker -nacos -Sso-server</tag>
      </tags>
  </entry>
</search>
